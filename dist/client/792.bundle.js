/*! For license information please see 792.bundle.js.LICENSE.txt */
(()=>{var t={845:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ConfiguratorCallbackHandler=void 0;const r=n(682),i="NOT IMPLEMENTED CALLBACK: ";e.ConfiguratorCallbackHandler=class{callbackLog(t){var e;null===(e=this._callbackLogger)||void 0===e||e.logCallback(t)}set callbackLogger(t){this._callbackLogger=t}setLoader(t){this._configurationLoader=t}setConstructor(t){this._configurationConstructor=t}isReady(){this.callbackLog("isReady")}requestAssets(t){const e=[],n=[],i=[],a=[],s=[],o=[];for(const l of t)switch(this.callbackLog(`requestAssets ${l.type.value} ${l.id}`),l.type.value){case r.CORE_ASSET_TYPE.ITEM:e.push(l.id);break;case r.CORE_ASSET_TYPE.COMPONENT:n.push(l.id);break;case r.CORE_ASSET_TYPE.EXTERNAL_MESH:i.push(l);break;case r.CORE_ASSET_TYPE.MATERIAL_PROPERTIES:a.push(l.id);break;case r.CORE_ASSET_TYPE.MATERIAL_GROUP:s.push(l.id);break;case r.CORE_ASSET_TYPE.EXTERNAL_OBJ_URL:i.push(l);break;case r.CORE_ASSET_TYPE.EXTERNAL_SVG_URL:o.push(l);break;default:this.callbackLog(`requestAssets not implemented ${l.type.value}`)}this._loadItemConfigurations(e),this._loadComponents(n),this._requestExternalMeshes(i),this._requestMaterialProperties(a),this._requestMaterialsInGroup(s),this._requestSVGs(o)}_loadItemConfigurations(t){this._configurationLoader?(this.callbackLog(`loadItemConfigurations ${t}`),this._configurationLoader.requestItems(t)):this.callbackLog(i+"loadItemConfigurations")}_loadComponents(t){if(this._configurationLoader)for(const e of t)this.callbackLog(`loadComponent ${e}`),this._configurationLoader.requestComponent(e);else this.callbackLog(i+"loadComponent")}_requestExternalMeshes(t){if(this._configurationLoader)for(const e of t)this.callbackLog(`requestExternalMesh ${e.id}, ${e.value}`),this._configurationLoader.requestExternalMesh(e.id,e.value);else this.callbackLog(i+"requestExternalMesh")}_requestMaterialProperties(t){this._configurationLoader?(this.callbackLog(`requestMaterialProperties ${t}`),this._configurationLoader.requestMaterialProperties(t)):this.callbackLog(i+"requestMaterialProperties")}_requestMaterialsInGroup(t){this._configurationLoader?(this.callbackLog(`requestMaterialsInGroup ${t}`),this._configurationLoader.requestMaterialsInGroup(t)):this.callbackLog(i+"requestMaterialsInGroup")}_requestSVGs(t){if(this._configurationLoader)for(const e of t)this.callbackLog(`requestSVGs ${e.id}, ${e.value}`),this._configurationLoader.requestSvg(e.id,e.value);else this.callbackLog(i+"requestSVGs")}configurationLoaded(t,e,n,r,a,s){this._configurationLoader?(this.callbackLog(`configurationLoaded ${n}`),this._configurationLoader.objectConfigurationLoaded(t,e,n,r,a,s)):this.callbackLog(i+"configurationLoaded")}configurationLoadingError(t){this._configurationLoader?(this.callbackLog(`configurationLoadingError ${t}`),this._configurationLoader.objectConfigurationLoadingError(t)):this.callbackLog(i+"configurationLoadingError")}configurationSaved(t,e,n,r){this.callbackLog(i+"configurationSaved")}componentDefinitionLoaded(t,e){this._configurationLoader?(this.callbackLog(`componentDefinitionLoaded ${t}, ${e}`),this._configurationLoader.componentDefinitionLoaded(t,e)):this.callbackLog(i+"componentDefinitionLoaded")}componentDefinitionLoadingError(t,e){this.callbackLog(i+"componentDefinitionLoadingError")}componentConfigurationUpdated(t,e){this._configurationLoader?(this.callbackLog(`componentConfigurationUpdated ${t}, ${e?"gemoetry changed":""}'`),this._configurationLoader.componentConfigurationUpdated(t,e)):this.callbackLog(i+"componentConfigurationUpdated")}componentMetaUpdated(t){this._configurationLoader?(this.callbackLog(`componentMetaUpdated ${t.componentId}`),this._configurationLoader.componentUpdated(t)):this.callbackLog(i+"componentMetaUpdated")}componentDeleted(t){this._configurationLoader?(this.callbackLog(`componentDeleted ${t}`),this._configurationLoader.componentDeleted(t)):this.callbackLog(i+"componentDeleted")}planObjectCreated(t,e){this._configurationLoader?(this.callbackLog(`planObjectCreated ${t}, ${e}`),this._configurationLoader.objectCreated(t,e)):this.callbackLog(i+"planObjectCreated")}planObjectUpdated(t,e){this._configurationLoader?(this.callbackLog(`planObjectUpdated ${t}`),this._configurationLoader.objectUpdated(t,e)):this.callbackLog(i+"planObjectUpdated")}planObjectDeleted(t){this._configurationLoader?(this.callbackLog(`planObjectDeleted ${t}`),this._configurationLoader.objectDeleted(t)):this.callbackLog(i+"planObjectDeleted")}planObjectConfigurationUpdated(t,e,n,r,a){this._configurationLoader?(this.callbackLog(`planObjectConfigurationUpdated ${t} ${n} ${r} ${a}`),this._configurationLoader.objectConfigurationUpdated(t,e,n,r,a)):this.callbackLog(i+"planObjectConfigurationUpdated")}sceneCleared(){this._configurationLoader?(this.callbackLog("sceneCleared"),this._configurationLoader.sceneCleared()):this.callbackLog(i+"sceneCleared")}listOfVariants(t,e){this.callbackLog(i+"listOfVariants")}listOfVariantsError(t,e){this.callbackLog(i+"listOfVariantsError")}Editor3dComponentCreated(t,e,n,r,a){this._configurationConstructor?(this.callbackLog(`Editor3dComponentCreated ${t}`),r?this._configurationConstructor.componentCreated(t,e,n,a,r):this._configurationConstructor.rootComponentCreated(t,e,n,a)):this.callbackLog(i+"Editor3dComponentCreated")}Editor3dComponentDocked(t,e,n,r,a){this.callbackLog(i+"Editor3dComponentDocked")}Editor3dAddDockPreview(t,e){this.callbackLog(i+"Editor3dAddDockPreview")}Editor3dSetPreviewPointAssociations(t,e){this.callbackLog(i+"Editor3dSetPreviewPointAssociations")}Editor3dSetPreviewLineAssociations(t,e){this.callbackLog(i+"Editor3dSetPreviewLineAssociations")}Editor3dPreviewConstructionDone(t,e){this.callbackLog(i+"Editor3dPreviewConstructionDone")}Editor3dGeometryReady(t){this._configurationConstructor?(this.callbackLog(`Editor3dGeometryReady ${t}`),this._configurationConstructor.geometryReady(t)):this.callbackLog(i+"Editor3dGeometryReady")}Editor3dGeometryNotReady(t){this._configurationConstructor?(this.callbackLog(`Editor3dGeometryNotReady ${t}`),this._configurationConstructor.geometryNotReady(t)):this.callbackLog(i+"Editor3dGeometryNotReady")}Editor3dBeginConstruction(t,e){this._configurationConstructor?(this.callbackLog(`Editor3dBeginConstruction ${t}`),this._configurationConstructor.beginConstruction(t,e)):this.callbackLog(i+"Editor3dBeginConstruction")}Editor3dEndConstruction(t){this._configurationConstructor?(this.callbackLog(`Editor3dEndConstruction ${t}`),this._configurationConstructor.endConstruction(t)):this.callbackLog(i+"Editor3dEndConstruction")}Editor3dAddMesh(t,e,n,r,a,s){this._configurationConstructor?(this.callbackLog(`Editor3dAddNamedMesh ${t} ${e} ${n}`),this._configurationConstructor.addMesh(t,e,n,a.materialId,a.transform,s.vertices,s.indices,s.uvCoords,s.normals,r,a.uvTransform,a.materialAttributes)):this.callbackLog(i+"Editor3dAddNamedMesh")}Editor3ChangedMesh(t,e,n,r){this._configurationConstructor?(this.callbackLog(`Editor3ChangedNamedMesh ${t} ${e} ${n}`),this._configurationConstructor.changedMesh(t,e,n,r.materialId,r.transform,r.uvTransform,r.materialAttributes)):this.callbackLog(i+"Editor3ChangedNamedMesh")}Editor3dRemoveMesh(t,e){this._configurationConstructor?(this.callbackLog(`Editor3dRemoveMesh ${t} ${e}`),this._configurationConstructor.removeMesh(t,e)):this.callbackLog(i+"Editor3dRemoveMesh")}Editor3dPlanObjectConstructionDone(t){this._configurationConstructor?(this.callbackLog(`Editor3dPlanObjectConstructionDone ${t}`),this._configurationConstructor.objectConstructionDone(t)):this.callbackLog(i+"Editor3dPlanObjectConstructionDone")}}},397:function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.ConfiguratorCoreInstance=void 0;const i=n(877),a=r(n(125)),s=n(896);class o extends s.CoreModuleInstance{constructor(t){super(a.default,t)}getConfiguratorModule(){return this._configuratorCoreModule}getConfigurator(){return this._configuratorKernel}get configurationExporter(){if(!this._configurationExporter){const t=this._configuratorCoreModule;this._configurationExporter=t.newConfigurationExporter()}return this._configurationExporter}async init(t,e){var n,r,a;this._configuratorKernel||(this._configuratorCoreModule=await this.newModule(),null===(n=this._configuratorCoreModule)||void 0===n||n.setExternalHelpers(t,{convertCObject:i.convertCObject}),e&&(null===(r=this._configuratorCoreModule)||void 0===r||r.registerConfiguratorCallback(e)),this._configuratorKernel=this._configuratorCoreModule?new this._configuratorCoreModule.Kernel:void 0,null===(a=this._configuratorKernel)||void 0===a||a.useEnvironmentGeometry(!0))}static async newConfiguratorCore(t,e,n){const r=new o(n);return await r.init(t,e),r}}e.ConfiguratorCoreInstance=o},682:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CORE_VALUE_PRESENTATION_MODE=e.CORE_UNIT_TYPE=e.CORE_UNIT_STRING_TYPE=e.CORE_UNIT=e.CORE_TYPE=e.CORE_EXPORT_TYPE=e.CORE_DIMENSION_TYPE=e.CORE_ASSET_TYPE=e.CORE_PARAMETER_TYPE_STRING=e.CORE_UNIT_TYPE_STRING=void 0,e.CORE_UNIT_TYPE_STRING={UNKNOWN_UNIT:"unknown",LENGTH:"length",AREA:"area",ANGLE:"angle",COUNT:"count"},e.CORE_PARAMETER_TYPE_STRING={UNKNOWN:"",INTEGER:"Integer",DECIMAL:"Decimal",STRING:"String",BOOLTYPE:"Boolean",MATERIAL:"Material"},e.CORE_ASSET_TYPE={ITEM:0,COMPONENT:1,EXTERNAL_MESH:2,MATERIAL_PROPERTIES:3,MATERIAL_GROUP:4,EXTERNAL_OBJ_URL:5,EXTERNAL_SVG_URL:6},e.CORE_DIMENSION_TYPE={X:0,Y:1,Z:2},e.CORE_EXPORT_TYPE={TC:0,IMOSIX:1,HOMAGIX:2,BLUEOCEANPOC:3},e.CORE_TYPE={UNKNOWN:0,INTEGRAL:1,DECIMAL:2,STRING:3,MATERIAL:4},e.CORE_UNIT={INCHFEET:0,MM:1,CM:2,INCH:3,FEET:4},e.CORE_UNIT_STRING_TYPE={NOUNITSTRING:0,LONGUNITSTRING:1,SHORTUNITSTRING:2},e.CORE_UNIT_TYPE={LENGTH:0,AREA:1,ANGLE:2,COUNT:3},e.CORE_VALUE_PRESENTATION_MODE={DYNAMIC:0,FIXED:1}},877:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.convertCObject=e.utilityStringToUTF16=e.utilityToArray=void 0,e.utilityToArray=t=>{let e=[];if(t){let n=t.size();for(let r=0;r<n;r++)e.push(t.get(r))}return e},e.utilityStringToUTF16=t=>decodeURIComponent(encodeURIComponent(t)),e.convertCObject=t=>{if(!t){const e=typeof t;return"number"===e||"boolean"===e?t:null}if(!t.hasOwnProperty("size")&&t.size&&"function"==typeof t.size){let n=(0,e.utilityToArray)(t);for(let t=0;t<n.length;t++)n[t]=(0,e.convertCObject)(n[t]);return"string"==typeof n?(0,e.utilityStringToUTF16)(n):n}if("object"==typeof t)for(let n in t)t.hasOwnProperty(n)&&(t[n]=(0,e.convertCObject)(t[n]));return"string"==typeof t?(0,e.utilityStringToUTF16)(t):t}},896:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CoreModuleInstance=void 0,e.CoreModuleInstance=class{constructor(t,e){this._wasmModule=t,this._coreModule=null!=e?e:{}}async newModule(){try{return await this._wasmModule(this._coreModule)}catch(t){console.error(t)}}}},560:function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.PlannerConfiguratorInstance=e.PlannerCoreInstance=void 0;const i=n(149),a=n(877),s=r(n(930)),o=n(896);class l extends o.CoreModuleInstance{constructor(t){super(s.default,t)}get planModelViewHelper(){return this._plannerCoreModule.PlanModelViewHelper}dispose(){var t,e;this._plannerCallback&&(null===(t=this._plannerCoreModule)||void 0===t||t.unregisterPlannerCallback(this._plannerCallback)),this._configuratorCallback&&(null===(e=this._plannerCoreModule)||void 0===e||e.unregisterConfiguratorCallback(this._configuratorCallback))}getPlannerModule(){return this._plannerCoreModule}newPlanInteractionHandler(){const t=new this._plannerCoreModule.PlanInteractionHandler;return t.init(t,1,30,{value:i.CORE_SNAP_MODE.WITHIN_SNAP_DISTANCE},{value:i.CORE_SNAP_MODE.WITHIN_SNAP_DISTANCE},!0,{value:i.CORE_DRAWING_TYPE.CLICK_PER_CLICK}),t}newCatalogItem(t){return new this._plannerCoreModule.CatalogItem(t)}newCatalogItemFromRapiItem(t){var e,n,r;const i=this.newCatalogItem(t.id),a=i.size;return a.x=t.width||0,a.y=t.depth||0,a.z=t.height||0,i.size=a,i.flipable=null!==(e=null==t?void 0:t.flipable)&&void 0!==e&&e,t.layer&&(i.layer=t.layer),i.orderable=null!==(n=null==t?void 0:t.orderable)&&void 0!==n&&n,i.scaleable=null!==(r=null==t?void 0:t.scaleable)&&void 0!==r&&r,i.type=t.type||"other",i.detailType=t.detailType||i.type||"other",i.configuration=t.configuration||"",i}catalogItemLoaded(t){this._plannerCoreModule.catalogItemLoaded(t)}async init(t,e,n){var r,i,s;this._plannerCoreModule||(this._plannerCoreModule=await this.newModule(),null===(r=this._plannerCoreModule)||void 0===r||r.setExternalHelpers(t,{convertCObject:a.convertCObject}),n&&(this._configuratorCallback=n,null===(i=this._plannerCoreModule)||void 0===i||i.registerConfiguratorCallback(n)),this._plannerCallback=e,null===(s=this._plannerCoreModule)||void 0===s||s.registerPlannerCallback(e))}static async newPlannerCore(t,e,n,r){const i=new l(r);return await i.init(t,e,n),i}}e.PlannerCoreInstance=l,e.PlannerConfiguratorInstance=class{constructor(t,e){this._plannerCoreInstance=t,this._planInteractionHandler=e}getConfiguratorModule(){return this._plannerCoreInstance.getPlannerModule()}getConfigurator(){return this._planInteractionHandler.getConfiguratorKernel()}get configurationExporter(){if(!this._configurationExporter){const t=this.getConfiguratorModule();this._configurationExporter=t.newConfigurationExporter()}return this._configurationExporter}}},571:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.PlannerCallbackHandler=void 0;const n="NOT IMPLEMENTED PLANNER CALLBACK: ";class r{callbackLog(t){r.enableCallbackLogs&&console.log(t)}requestCatalogItem(t){this.callbackLog(n+"requestCatalogItem")}handlerSwitchedPlans(t,e){this.callbackLog(n+"handlerSwitchedPlans")}planElementAdded(t,e){this.callbackLog(n+"planElementAdded")}planElementChanged(t,e){this.callbackLog(n+"planElementChanged")}planElement3dMeshChanged(t,e){this.callbackLog(n+"planElement3dMeshChanged")}planObjectConfigurationLoaded(t,e,r){this.callbackLog(n+"planObjectConfigurationLoaded")}planObjectConfigurationCreated(t,e){this.callbackLog(n+"planObjectConfigurationCreated")}externalObjectConfigurationChanged(t,e,r){this.callbackLog(n+"externalObjectConfigurationChanged")}externalObjectConfigurationLoaded(t,e,r){this.callbackLog(n+"externalObjectConfigurationLoaded")}externalObjectConfigurationDeleted(t,e,r){this.callbackLog(n+"externalObjectConfigurationDeleted")}externalObjectComponentDeleted(t,e,r,i){this.callbackLog(n+"externalObjectComponentDeleted")}externalObjectConfigurationDuplicated(t,e,r,i){this.callbackLog(n+"externalObjectConfigurationDuplicated")}externalObjectConfigurationsMerged(t,e,r,i){this.callbackLog(n+"externalObjectConfigurationsMerged")}externalObjectComponentSplitOff(t,e,r,i){this.callbackLog(n+"externalObjectComponentSplitOff")}planBoundsChanged(){this.callbackLog(n+"planBoundsChanged")}planHistoryStateChanged(){this.callbackLog(n+"planHistoryStateChanged")}planElementRemoved(t){this.callbackLog(n+"planElementRemoved")}startedDrawing(){this.callbackLog(n+"startedDrawing")}stoppedDrawing(){this.callbackLog(n+"stoppedDrawing")}planCompletelyLoaded(t){this.callbackLog(n+"planCompletelyLoaded")}planCleared(){this.callbackLog(n+"planCleared")}updateMesh2d(t,e,r){this.callbackLog(n+"updateMesh2d")}beginConstruction(t){this.callbackLog(n+"beginConstruction")}endConstruction(t){this.callbackLog(n+"endConstruction")}addMesh(t,e,r,i,a,s){this.callbackLog(n+"addMesh")}beginPlanConstruction(t){this.callbackLog(n+"beginPlanConstruction")}endPlanConstruction(t){this.callbackLog(n+"endPlanConstruction")}addPlanMesh(t,e,r,i,a,s,o){this.callbackLog(n+"addPlanMesh")}}e.PlannerCallbackHandler=r,r.enableCallbackLogs=!1},149:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CORE_WALL_TYPE=e.CORE_WALL_SIDE=e.CORE_WALL_EXTENSION_TYPE=e.CORE_SNAP_MODE=e.CORE_RESIZING_ANCHOR=e.CORE_PLAN_OBJECT_SIDE=e.CORE_PLAN_ELEMENT_TYPE=e.CORE_OPENING_DIRECTION=e.CORE_OBJECT_CONFIGURATION_TYPE=e.CORE_MATERIAL_SOURCE_TYPE=e.CORE_DRAWING_TYPE=e.CORE_CHILD_ENTITY_MODE=void 0,e.CORE_CHILD_ENTITY_MODE={OFF:0,GROUND_COMPONENTS:1,ALL_COMPONENTS:2},e.CORE_DRAWING_TYPE={CONTINOUS:0,CLICK_PER_CLICK:1},e.CORE_MATERIAL_SOURCE_TYPE={NONE:0,CATALOGITEM:1,MATERIAL:2,RGBVALUE:3},e.CORE_OBJECT_CONFIGURATION_TYPE={STATIC:0,CORE:1,EXTERNAL:2},e.CORE_OPENING_DIRECTION={LEFT_CLOCKWISE:0,LEFT_COUNTERCLOCKWISE:1,RIGHT_CLOCKWISE:2,RIGHT_COUNTERCLOCKWISE:3},e.CORE_PLAN_ELEMENT_TYPE={NODE:0,WALL:1,OBJECT:2,FLOOR:3,CEILING:4,TEXT:5,MEASURE:6,IMAGE:7,GROUP:8},e.CORE_PLAN_OBJECT_SIDE={BACK:0,FRONT:1,LEFT:2,RIGHT:3},e.CORE_RESIZING_ANCHOR={CENTER:0,BACKLEFT:1,BACKRIGHT:2,FRONTLEFT:3,FRONTRIGHT:4,BACK:5,FRONT:6,LEFT:7,RIGHT:8},e.CORE_SNAP_MODE={OFF:0,ON_COLLISION:1,ON_COLLISION_ROTATE_WITHIN_DISTANCE:2,WITHIN_SNAP_DISTANCE:3},e.CORE_WALL_EXTENSION_TYPE={EXTENDBEGIN:0,EXTENDEND:1,EXTENDBOTH:2},e.CORE_WALL_SIDE={LEFT:0,RIGHT:1,MIDDLE:2},e.CORE_WALL_TYPE={STANDALONEWALL:0,OUTERWALLLEFT:1,OUTERWALLRIGHT:2,INNERWALL:3}},583:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ConfigurableObject=void 0;const r=n(682);e.ConfigurableObject=class{constructor(t,e,n,r){this._serializedConfiguration="",this._objectData=null,this._listOfParts=null,this._configurationManager=t,this._objectRuntimeId=e,this._hash=n,this._valid=r}get objectRuntimeId(){return this._objectRuntimeId}get hash(){return this._hash}get valid(){return this._valid}get serializedConfiguration(){return this.updateConfiguration(),this._serializedConfiguration}get configuratorObject(){return this.updateObjectData(),this._objectData||null}get parameters(){var t;return this.updateObjectData(),(null===(t=this._objectData)||void 0===t?void 0:t.parameters)||[]}get listOfParts(){return this.updateListOfParts(),this._listOfParts}delete(){var t,e;null===(e=null===(t=this._configurationManager)||void 0===t?void 0:t.configuratorKernel)||void 0===e||e.deletePlanObject(this._objectRuntimeId)}objectChanged(t,e,n){this.resetObjectData(),this._hash=e,this._valid=n,this._serializedConfiguration=t}async changeParameters(t){var e,n;await(null===(n=null===(e=this._configurationManager)||void 0===e?void 0:e.updateManager)||void 0===n?void 0:n.changeParameters(this._objectRuntimeId,t))}removedFromManger(){this._configurationManager=void 0}resetObjectData(){this._hash="",this._valid=!1,this._serializedConfiguration="",this._objectData=null,this._listOfParts=null}updateConfiguration(){var t,e;this._serializedConfiguration||(this._serializedConfiguration=(null===(e=null===(t=this._configurationManager)||void 0===t?void 0:t.configuratorKernel)||void 0===e?void 0:e.getSerializedConfiguration(this._objectRuntimeId))||"")}updateObjectData(){var t,e;if(!this._objectData){const n=null===(e=null===(t=this._configurationManager)||void 0===t?void 0:t.configuratorKernel)||void 0===e?void 0:e.getPlanObject(this._objectRuntimeId);n&&(this._objectData=JSON.parse(JSON.stringify(n)))}}updateListOfParts(){var t,e;if(!this._listOfParts){const n=null===(e=null===(t=this._configurationManager)||void 0===t?void 0:t.configuratorKernel)||void 0===e?void 0:e.getPartList(this._objectRuntimeId);n&&(this._listOfParts=JSON.parse(JSON.stringify(n)))}}async generateTCExport(t=""){return this.generateExport({value:r.CORE_EXPORT_TYPE.TC},t)}async generateExport(t,e=""){var n,r;const i=this._objectRuntimeId;try{if(null===(n=this._configurationManager)||void 0===n?void 0:n.configurationExporter)return this._configurationManager.configurationExporter.setDefaultExportDataDefinition(e),JSON.parse(this._configurationManager.configurationExporter.generateExport(t.value,i,this._configurationManager.configuratorKernel));null===(r=this._configurationManager)||void 0===r||r.configurationExporter.setDefaultExportDataDefinition(e)}catch(e){console.error(e);const n=new Error(`Could not create export JSON ${t.value}`);return Promise.reject(n)}}}},55:(t,e,n)=>{"use strict";e.p=void 0;const r=n(845),i=n(397),a=n(772),s=n(488),o=n(613),l=n(273);class c{constructor(t,e){this._callbackHandler=new r.ConfiguratorCallbackHandler,this._assetRequests=null!=t?t:new l.RapiRequests,this._logger=null!=e?e:new o.Logger}clearAll(){var t;const e=null===(t=this._configuratorCore)||void 0===t?void 0:t.getConfigurator();null==e||e.clearAll()}async init(t,e){if(!this._configuratorCore){this._configuratorCore=await i.ConfiguratorCoreInstance.newConfiguratorCore(this._logger,this._callbackHandler,e);const n=this._configuratorCore.getConfiguratorModule(),r=this._configuratorCore.getConfigurator();r&&n&&(this._configurationLoader=new a.ConfigurationRequests(n,r,this._assetRequests,void 0,this._logger,t),this._configurationConstructor=new a.ConfigurationConstructor(n,r,this._assetRequests,t))}}static async newGeometryConstructor(t,e,n,r){const i=new c(n,r);return await i.init(t,e),i}registerCallbacks(){this._configurationLoader&&this._configurationConstructor&&(this._callbackHandler.setLoader(this._configurationLoader),this._callbackHandler.setConstructor(this._configurationConstructor))}unregisterCallbacks(){this._callbackHandler.setLoader(void 0),this._callbackHandler.setConstructor(void 0)}async constructMesh(t){var e;if(!this._configuratorCore||!this._configurationLoader||!this._configurationConstructor)return{meshData:{meshes:[],materials:[]},materialProperties:[],planComponents:[]};const n=this._configuratorCore.getConfigurator();this.registerCallbacks(),null==n||n.clearAll(),await this._configurationLoader.load(t);const r=await this._configurationConstructor.construct(1);return this.unregisterCallbacks(),this.logMesh(r),(0,s.createConstructionData)(r,null===(e=this._configuratorCore)||void 0===e?void 0:e.getConfigurator())}logMesh(t){this._logger.log("\nGeometry:"),t.meshes.forEach((t=>{const e=t.baked?"baked":`${t.meshId} ${t.geometryName}`;this._logger.log(`${t.runtimeComponentId} ${e} ${t.environmentGeometry?"environment":""} v: ${t.vertices.length} i: ${t.indices.length}`)})),this._logger.log("\nMaterials:"),t.materials.forEach((t=>{var e,n,r;let i="";(null===(e=t.shading)||void 0===e?void 0:e.basecolor)&&(i=`RGB: ${t.shading.basecolor.r}, ${t.shading.basecolor.g}, ${t.shading.basecolor.b}`),this._logger.log(`${t.id} ${i} textures: ${null!==(r=null===(n=t.textureObjects)||void 0===n?void 0:n.length)&&void 0!==r?r:0}`)}))}}e.p=c,c.enableConstructionLogs=!1},772:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ConfigurationConstructor=e.ConfigurationRequests=e.MaterialCache=void 0;const r=n(682),i=n(613);class a{constructor(t){this._cache=new Map,this._assetRequests=t}get materialMap(){return this._cache}async loadMaterials(t){const e=[],n=[];return t.forEach((t=>{this._cache.has(t)?e.push(this._cache.get(t)):n.push(t)})),n.length>0&&(await this._assetRequests.loadMaterials(n)).materials.forEach((t=>{this._cache.set(t.id,t),e.push(t)})),e}}e.MaterialCache=a;class s{constructor(t,e,n,r,a,s){var o;this._componentRequests=[],this._materialPropertyRequests=[],this._externalMeshRequests=[],this._conversationMap=new Map,this.requestSvg=(t,e)=>{},this._configuratorModule=t,this._configurator=e,this._assetRequests=n,this._configurationObjectCallbacks=r,this._logger=null!=a?a:new i.Logger,this._configurator.setUpdateCallbacksOnlyIfGeometryIsReady(null===(o=null==s?void 0:s.updateCallbacksOnlyIfGeometryIsReady)||void 0===o||o)}get configurator(){return this._configurator}async load(t){var e;this._logger.logProgress(`ConfigurationRequests: load ${t}`),s.conversationId++;const n=s.conversationId;let r="";const i=t.split(":").length-1;r=t.startsWith("component@")?`{"componentId":"${t.substr(t.indexOf("@")+1)}"}`:1===i?await this.loadItemDefinition(t):await this.loadConfigurationDefinition(t),this._configurator.loadConfiguration(n,r,{x:0,y:0,z:0}),await this.batchLoad();let a=null;return this._conversationMap.has(n)&&(a=null!==(e=this._conversationMap.get(n))&&void 0!==e?e:null,this._conversationMap.delete(n)),this._logger.logProgress(`ConfigurationRequests: loaded ${t}`),a}async changeParameters(t,e){for(const n of e)this._logger.logProgress(`ConfigurationRequests: set parameter '${n.key}' = '${n.value}' of object ${t}`),this._configurator.setPlanObjectParameter(t,n.key,n.value),await this.batchLoad()}async batchLoad(){for(var t,e,n,r,i,a;(null===(t=this._componentRequests)||void 0===t?void 0:t.length)||(null===(e=this._materialPropertyRequests)||void 0===e?void 0:e.length)||(null===(n=this._externalMeshRequests)||void 0===n?void 0:n.length);){if(null===(r=this._componentRequests)||void 0===r?void 0:r.length){const t=this._componentRequests;this._componentRequests=[],await this.loadComponents(t)}if(null===(i=this._materialPropertyRequests)||void 0===i?void 0:i.length){const t=this._materialPropertyRequests;this._materialPropertyRequests=[],await this.loadMaterialsAndProperties(t)}if(null===(a=this._externalMeshRequests)||void 0===a?void 0:a.length){const t=this._externalMeshRequests;this._externalMeshRequests=[],await this.loadExternalMeshes(t)}}}async loadConfigurationDefinition(t){return(await this._assetRequests.loadConfiguration(t)).configuration.configuration}async loadItemDefinition(t){return(await this._assetRequests.loadItem(t)).item.configuration}componentDefinitionLoaded(t,e){}objectConfigurationLoaded(t,e,n,r,i,a){var s;this._conversationMap.has(t)&&this._conversationMap.get(t)===e||this._logger.error(`Conversation ${t} not found for object ${e}`);const o=Array.from(i);null===(s=this._configurationObjectCallbacks)||void 0===s||s.objectCreatedAndLoaded(e,r,o,a)}objectConfigurationLoadingError(t){}objectConfigurationUpdated(t,e,n,r,i){var a;null===(a=this._configurationObjectCallbacks)||void 0===a||a.objectChanged(t,e,n,r,i)}objectCreated(t,e){this._conversationMap.set(t,e)}objectUpdated(t,e){}objectDeleted(t){var e;null===(e=this._configurationObjectCallbacks)||void 0===e||e.objectDeleted(t)}componentConfigurationUpdated(t,e){}componentUpdated(t){}componentDeleted(t){}sceneCleared(){}requestComponent(t){this._componentRequests.push({componentId:t})}async requestItems(t){for(const e of t){const t=await this.loadItemDefinition(e);this._configurator.assetsLoaded({type:{value:r.CORE_ASSET_TYPE.ITEM},id:e,data:t})}}requestMaterialsInGroup(t){}requestMaterialProperties(t){this._materialPropertyRequests.push(...t)}requestExternalMesh(t,e){this._externalMeshRequests.push({meshId:t,quality:e})}async loadComponents(t){try{const e=t.map((t=>t.componentId)),n=await this._assetRequests.loadComponents(e);t.forEach((t=>{var e;const i=null===(e=n.components)||void 0===e?void 0:e.find((e=>e.id.toLowerCase()===t.componentId.toLowerCase()));if(i){const e=i.configuration;this._configurator.assetsLoaded({type:{value:r.CORE_ASSET_TYPE.COMPONENT},id:t.componentId,data:e})}}))}catch(t){this._logger.exception(t)}}async loadComponent(t){try{const e=(await this._assetRequests.loadComponent(t)).component.configuration;this._configurator.assetsLoaded({type:{value:r.CORE_ASSET_TYPE.COMPONENT},id:t,data:e})}catch(t){this._logger.exception(t)}}async loadMaterialsAndProperties(t){var e;try{const n=await this._assetRequests.loadMaterials(t);let i=[];null===(e=n.materials)||void 0===e||e.forEach((t=>{const e=new this._configuratorModule.StringStringMap,n=t.properties||{};for(let t in n)n.hasOwnProperty(t)&&e.set(t,n[t]);e.size()&&i.push({type:{value:r.CORE_ASSET_TYPE.MATERIAL_PROPERTIES},id:t.id,data:e})})),i.length&&this._configurator.assetsLoaded(i)}catch(t){this._logger.exception(t)}}async loadExternalMeshes(t){try{for(const e of t){const t=await this._assetRequests.loadMesh(e.meshId,e.quality),n=await this._assetRequests.loadMeshData(t.mesh.links.data);for(const t of n.meshDatas){const n=await this._assetRequests.loadData(t.url);this._configurator.assetsLoaded({type:{value:r.CORE_ASSET_TYPE.EXTERNAL_MESH},id:e.meshId,value:e.quality,data:new Uint8Array(n)})}}}catch(t){this._logger.exception(t)}}}e.ConfigurationRequests=s,s.conversationId=0,e.ConfigurationConstructor=class{constructor(t,e,n,r){this._configuratorModule=t,this._configurator=e,this._assetRequests=n}async construct(t,e){this._meshData={meshes:[],materials:[]},this.constructGeometry(t),await this.loadMaterials(t,e);const n=this._meshData;return this._meshData=void 0,n}constructGeometry(t){console.log(`CONSTRUCT: ${t}`),this._configurator.requestPlanObjectConstruction(t),console.log(`... CONSTRUCTED: ${t}`)}async loadMaterials(t,e){if(!this._meshData)return;console.log(`LOAD MATERIALS: ${t}`);const n=Array.from(new Set(this._meshData.meshes.map((t=>t.materialId)))),r=null!=e?e:new a(this._assetRequests);this._meshData.materials=await r.loadMaterials(n),console.log(`... MATERIALS LOADED: ${t}`)}componentCreated(t,e,n,r,i){}rootComponentCreated(t,e,n,r){}geometryReady(t){}geometryNotReady(t){}beginConstruction(t,e){}endConstruction(t){}findMesh(t,e,n){var r;return null===(r=this._meshData)||void 0===r?void 0:r.meshes.find((r=>!r.baked&&r.runtimeComponentId===t&&r.meshId===e&&r.geometryName===n))}addMesh(t,e,n,r,i,a,s,o,l,c,u,h){if(!this._meshData)return;const d=this.findMesh(t,e,n);d?(d.environmentGeometry=c,d.materialId=r,d.vertices=Float32Array.from(a),d.indices=Uint32Array.from(s),d.uvCoords=Float32Array.from(o),d.normals=Float32Array.from(l),d.transform=Float32Array.from(i),d.uvTransform=u?Float32Array.from(u):null,d.materialAttributes=h):this._meshData.meshes.push({runtimeComponentId:t,environmentGeometry:c,baked:!1,meshId:e,geometryName:n,materialId:r,vertices:Float32Array.from(a),indices:Uint32Array.from(s),uvCoords:Float32Array.from(o),normals:Float32Array.from(l),transform:Float32Array.from(i),uvTransform:u?Float32Array.from(u):null,materialAttributes:h})}changedMesh(t,e,n,r,i,a,s){const o=this.findMesh(t,e,n);o&&(o.materialId=r,o.transform=Float32Array.from(i),o.uvTransform=a?Float32Array.from(a):null,o.materialAttributes=s)}removeMesh(t,e){}objectConstructionDone(t){}}},312:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ConfigurationManager=void 0;const r=n(845),i=n(397),a=n(583),s=n(772),o=n(772),l=n(488),c=n(613),u=n(273);class h{constructor(t,e,n){this._callbackHandler=new r.ConfiguratorCallbackHandler,this._objectMap=new Map,this._meshes=new Map,this._assetRequests=null!=t?t:new u.RapiRequests,this._logger=null!=e?e:new c.Logger(c.LOG_LEVEL.LOG),this._materials=null!=n?n:new s.MaterialCache(this._assetRequests)}get configuratorKernel(){return this._configuratorKernel}get updateManager(){return this._configurationLoader}get constructionManager(){return this._configurationConstructor}get objectMap(){return this._objectMap}get meshes(){return this._meshes}dispose(){this.unregisterCallbacks()}static async newConfigurationManager(t,e,n,r){const i=new h(t,e,r);return await i._initConfigurator(n),i}async loadConfiguration(t){var e,n,r;const i=null!==(n=await(null===(e=this.updateManager)||void 0===e?void 0:e.load(t)))&&void 0!==n?n:null;return i&&null!==(r=this._objectMap.get(i))&&void 0!==r?r:null}get configurationExporter(){var t;return null===(t=this._configuratorCoreInstance)||void 0===t?void 0:t.configurationExporter}registerCallbacks(){this._callbackHandler.callbackLogger=this._logger,this._callbackHandler.setLoader(this._configurationLoader),this._callbackHandler.setConstructor(this._configurationConstructor)}unregisterCallbacks(){this._callbackHandler.setLoader(void 0),this._callbackHandler.setConstructor(void 0)}async _initConfigurator(t){if(!this._configuratorCoreInstance){this._configuratorCoreInstance=t||await i.ConfiguratorCoreInstance.newConfiguratorCore(this._logger,this._callbackHandler),this._configuratorKernel=this._configuratorCoreInstance.getConfigurator();const e=this._configuratorCoreInstance.getConfiguratorModule();e&&(this._initCallbackHandler(e),t&&e.registerConfiguratorCallback(this._callbackHandler))}this.registerCallbacks()}_initCallbackHandler(t){this._configuratorKernel&&(this._configurationLoader=new o.ConfigurationRequests(t,this._configuratorKernel,this._assetRequests,this,this._logger),this._configurationConstructor=new o.ConfigurationConstructor(t,this._configuratorKernel,this._assetRequests))}async finishLoadingConfigurations(){var t;await(null===(t=this._configurationLoader)||void 0===t?void 0:t.batchLoad())}async createGeometry(){var t;if(this._configurationConstructor)for(const e of this._objectMap.values()){const n=await(null===(t=this._configurationConstructor)||void 0===t?void 0:t.construct(e.objectRuntimeId,this._materials)),r=(0,l.createConstructionData)(n,this._configuratorKernel);this._meshes.set(e.objectRuntimeId,r)}}objectCreated(t,e){var n;null===(n=this._configurationLoader)||void 0===n||n.objectCreated(t,e)}objectCreatedAndLoaded(t,e,n,r){for(const t of n)this._logger.error(t);this._objectMap.set(t,new a.ConfigurableObject(this,t,e,r)),this._logger.logProgress(`ConfigurationManager: Object with id ${t} created and loaded`)}objectChanged(t,e,n,r,i){if(this._objectMap.has(t)){const i=this._objectMap.get(t);i&&(i.objectChanged(e,n,r),this._logger.logProgress(`ConfigurationManager: Object with id ${t} changed`))}else console.log("object not found")}objectDeleted(t){if(this._objectMap.has(t)){const e=this._objectMap.get(t);e&&e.removedFromManger(),this._objectMap.delete(t),this._logger.logProgress(`ConfigurationManager: Object with id ${t} removed`)}}}e.ConfigurationManager=h},488:(t,e)=>{"use strict";var n;Object.defineProperty(e,"__esModule",{value:!0}),e.getPlanComponents=e.createConstructionData=e.getMaterialProperties=e.getTextureProperties=e.isUVIdentityMatrix=e.RAPI_TEXTURE_TYPE=void 0,function(t){t.RGB="RGB",t.RGBA="RGBA",t.XYZ="XYZ",t.ORM="ORM",t.EMRGB="EMRGB",t.CCRG="CCRG",t.CCXYZ="CCXYZ",t.SHRGBA="SHRGBA",t.SPRGBA="SPRGBA",t.TTRG="TTRG"}(n||(e.RAPI_TEXTURE_TYPE=n={})),e.isUVIdentityMatrix=t=>6===t.length&&1===t[0]&&0===t[1]&&0===t[2]&&1===t[3]&&0!==t[4]&&0!==t[5],e.getTextureProperties=t=>({url:t.url,mmWidth:t.mmWidth,mmHeight:t.mmHeight}),e.getMaterialProperties=t=>{let n,r,i,a,s,o,l,c,u,h=!1;return t.textureObjects&&t.textureObjects.forEach((t=>{var d;const p=(0,e.getTextureProperties)(t);switch(null===(d=t.mapping)||void 0===d?void 0:d.toUpperCase()){case"RGB":default:n=p;break;case"RGBA":n=p,h=!0;break;case"XYZ":r=p;break;case"ORM":i=p;break;case"EMRGB":a=p;break;case"CCRG":s=p;break;case"CCXYZ":o=p;break;case"SHRGBA":l=p;break;case"SPRGBA":c=p;break;case"TTRG":u=p}})),{diffuseMap:n,diffuseMapHasAlpha:h,normalMap:r,ormMap:i,emrgbMap:a,ccrgMap:s,ccxyzMap:o,shrgbaMap:l,sprgbaMap:c,ttrgMap:u,shading:t.shading}},e.createConstructionData=(t,n)=>{const r=t.materials.map((t=>({specification:t,properties:(0,e.getMaterialProperties)(t)})));return{meshData:t,materialProperties:r,planComponents:(0,e.getPlanComponents)(t,n)}},e.getPlanComponents=(t,e)=>e?Array.from(new Set(t.meshes.map((t=>t.runtimeComponentId)))).map((t=>({id:t,planComponent:e.getComponent(t)}))):[]},613:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Logger=e.LOG_LEVEL=void 0,e.LOG_LEVEL={LOG:0,CALLBACK:1,INFO:2,PROGRESS:3,WARNING:4,ERROR:5};const n=new Map([[e.LOG_LEVEL.LOG,"LOG"],[e.LOG_LEVEL.CALLBACK,"CALLBACK"],[e.LOG_LEVEL.INFO,"INFO"],[e.LOG_LEVEL.PROGRESS,"PROGRESS"],[e.LOG_LEVEL.WARNING,"WARNING"],[e.LOG_LEVEL.ERROR,"ERROR"]]);e.Logger=class{constructor(t){this._logLevel=null!=t?t:e.LOG_LEVEL.WARNING}log(t){this.logMessage(e.LOG_LEVEL.LOG,t)}logCallback(t){this.logMessage(e.LOG_LEVEL.CALLBACK,t)}info(t){this.logMessage(e.LOG_LEVEL.INFO,t)}logProgress(t){this.logMessage(e.LOG_LEVEL.PROGRESS,t)}warn(t){this.logMessage(e.LOG_LEVEL.WARNING,t)}error(t){this.logMessage(e.LOG_LEVEL.ERROR,t)}exception(t){t instanceof Error?this.logMessage(e.LOG_LEVEL.ERROR,t.message):"string"==typeof t?this.logMessage(e.LOG_LEVEL.ERROR,t):this.logMessage(e.LOG_LEVEL.ERROR,`Unexpected error: ${JSON.stringify(t)}`)}logMessage(t,e){var r,i;(null!=t?t:0)>=(null!==(r=this._logLevel)&&void 0!==r?r:0)&&console.log(`${null!==(i=n.get(t))&&void 0!==i?i:""}: ${e}`)}}},905:(t,e,n)=>{"use strict";e.J=void 0;const r=n(560),i=n(571),a=n(149),s=n(772),o=n(312),l=n(613),c=n(273);class u{constructor(t,e){this._catalogItems=[],this._planElements=[],this._planMeshes=[],this._assetRequests=null!=t?t:new c.RapiRequests,this._logger=null!=e?e:new l.Logger(l.LOG_LEVEL.LOG),this._plannerCallbackHandler=new h(this,this._assetRequests,this._logger),this._materials=new s.MaterialCache(this._assetRequests)}get plannerInstance(){return this._plannerInstance}get planInteractionHandler(){return this._planInteractionHandler}get configuratorKernel(){var t;return null===(t=this._planInteractionHandler)||void 0===t?void 0:t.getConfiguratorKernel()}get configurationManager(){return this._configurationManager}get plan(){return this._plan}get catalogItems(){return this._catalogItems}get planElements(){return this._planElements}get planMeshes(){return this._planMeshes}get materials(){return this._materials.materialMap}get planObjectMeshes(){return this._createPlanObjectMeshes()}dispose(){var t,e;null===(t=this._plannerInstance)||void 0===t||t.dispose(),null===(e=this._configurationManager)||void 0===e||e.dispose()}getCatalogItem(t){return this.catalogItems.find((e=>e.item.id===t))}static async newPlanElementManager(t,e,n){const r=new u(t,e);return await r._initPlanner(n),r}async loadPlanFromId(t){var e,n;const r=await this._loadPlanXML(t);this._plan=null===(e=this._planInteractionHandler)||void 0===e?void 0:e.loadPlanXML(r),this.loadCatalogItemsOfPlanElementMaterials(),this._plannerCallbackHandler.finishLoadingCatalogItems(),await(null===(n=this._configurationManager)||void 0===n?void 0:n.finishLoadingConfigurations())}async createGeometry(){var t;await(null===(t=this._configurationManager)||void 0===t?void 0:t.createGeometry()),this._requestPlanModelGeometry(),await this._loadMaterialsOfPlanElements()}addCatalogItem(t){this._catalogItems.push(t)}addPlanElement(t){this._planElements.push(t)}async _initPlanner(t){this._plannerInstance=await r.PlannerCoreInstance.newPlannerCore(this._logger,this._plannerCallbackHandler,void 0,t),this._planInteractionHandler=this._plannerInstance.newPlanInteractionHandler(),this._plannerConfiguratorInstance=new r.PlannerConfiguratorInstance(this._plannerInstance,this._planInteractionHandler),this._configurationManager=await o.ConfigurationManager.newConfigurationManager(this._assetRequests,this._logger,this._plannerConfiguratorInstance,this._materials)}async _loadPlanXML(t){const e=await this._assetRequests.loadPlan(t),n=e;return n.plan?n.plan.planObjects:n.planSnapshot?n.planSnapshot.plan:e}loadCatalogItemsOfPlanElementMaterials(){for(const t of this._planMeshes)if(t.material.getSourceType().value===a.CORE_MATERIAL_SOURCE_TYPE.CATALOGITEM){const e=t.material.getCatalogItemId();e&&this._plannerCallbackHandler.requestCatalogItem(e)}}_requestPlanModelGeometry(){var t,e;if(this._plan)for(const n of this._planElements){const r=n.getType();this._hasGeometry(r)&&(null===(e=null===(t=this._plannerInstance)||void 0===t?void 0:t.planModelViewHelper)||void 0===e||e.requestMesh3d(n))}}_hasGeometry(t){return t.value===a.CORE_PLAN_ELEMENT_TYPE.WALL||t.value===a.CORE_PLAN_ELEMENT_TYPE.FLOOR||t.value===a.CORE_PLAN_ELEMENT_TYPE.CEILING||t.value===a.CORE_PLAN_ELEMENT_TYPE.OBJECT}async _loadMaterialsOfPlanElements(){var t;const e=new Set;for(const n of this._planMeshes){const r=null===(t=n.material)||void 0===t?void 0:t.materialId;r&&e.add(r)}e.size>0&&await this._materials.loadMaterials(Array.from(e))}_createPlanObjectMeshes(){const t=[];for(const e of this._planElements){if(e.getType().value!==a.CORE_PLAN_ELEMENT_TYPE.OBJECT)continue;const n=e,r=this._createPlanObjectMesh(n);r&&t.push(r)}return t}_createPlanObjectMesh(t){var e,n,r,i;const a=t.getConfigurationRuntimeId(),s=t.getMeshCenter(),o=[s.x,s.y,s.z],l=t.rotation,c=[t.size.x,t.size.y,t.size.z];let u,h;t.hasConfiguration()&&a>0&&(u=null===(e=this._configurationManager)||void 0===e?void 0:e.meshes.get(a),h=null===(i=null===(r=null===(n=this._configurationManager)||void 0===n?void 0:n.objectMap.get(a))||void 0===r?void 0:r.configuratorObject)||void 0===i?void 0:i.boxOfGeometry);const d=this.getCatalogItem(t.getCatalogItemId());return{planObject:t,position:o,rotation:l,size:c,boxOfGeometry:h,mesh:u,catalogItem:d}}}e.J=u;class h extends i.PlannerCallbackHandler{constructor(t,e,n){super(),this._requestedCatalogItems=new Map,this.requestCatalogItem=async t=>{if(!this._requestedCatalogItems.has(t)){const e=this._assetRequests.loadItem(t);this._requestedCatalogItems.set(t,e);const n=await e,r=this._planElementManager.plannerInstance;if(r){const t=r.newCatalogItemFromRapiItem(n.item);this._planElementManager.addCatalogItem({item:n.item,catalogItem:t}),r.catalogItemLoaded(t)}}},this._assetRequests=e,this._planElementManager=t,this._logger=n}async finishLoadingCatalogItems(){const t=[];this._requestedCatalogItems.forEach(((e,n)=>{t.push(e)})),await Promise.allSettled(t),this._requestedCatalogItems.clear()}planObjectConfigurationCreated(t,e){var n;const r=e.getOpenConversationId(),i=e.getConfigurationRuntimeId();null===(n=this._planElementManager.configurationManager)||void 0===n||n.objectCreated(r,i)}planCompletelyLoaded(t){this._logger.logProgress("plan completely loaded")}planElementAdded(t,e){this._planElementManager.addPlanElement(e)}beginConstruction(t){}endConstruction(t){}addMesh(t,e,n,r,i,a){const s=t.getCenter();this._planElementManager.planMeshes.push({type:t.getType().value,id:t.getId(),position:[s.x,s.y,s.z],material:e,vertices:Float32Array.from(n),indices:Uint32Array.from(r),uvCoords:Float32Array.from(i),normals:Float32Array.from(a)})}handlerSwitchedPlans(t,e){}planObjectConfigurationLoaded(t,e,n){}}},273:function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.RapiRequests=e.loadPlan=e.requestHeaders=e.RAPI_PATHS=void 0,e.preloadConfiguration=c,e.loadConfiguration=u,e.loadComponent=h,e.loadComponents=d,e.loadItem=p,e.loadMaterials=f,e.loadMesh=m,e.loadMeshData=g,e.loadData=v;const i=r(n(425));var a;!function(t){t.COMPONENTS="components",t.TEXTURES="textures",t.MESHES="meshes",t.MATERIALS="materials",t.CONFIGURATIONS="configurations",t.ITEMS="items",t.TAG="tags",t.PACKAGE="package",t.PRELOAD="preloads/components",t.SHORT_IDS="shortIds",t.CATALOGS="catalogs",t.PLANS="plans",t.ITEM_ADDITIONAL_CONTENTS="itemAdditionalContents",t.TENANT_ME="tenants/me",t.TENANT="tenants",t.SKIN="skins",t.PRICE="prices",t.CATALOG_MESHES="catalogMeshes",t.CONFIGURATORS="configurators",t.USER_ACTIONS="userActions",t.AUTH="auth",t.PLAN_SNAPSHOTS="planSnapshots"}(a||(e.RAPI_PATHS=a={})),e.requestHeaders=t=>({apiKey:"rml-service-functions",language:null!=t?t:"en",token:"anoymous"});const s="https://www.roomle.com/api/v2",o=(t,e)=>e?"/"===e[0]?`${s}/${t}${e}`:`${s}/${t}/${e}`:`${s}/${t}`,l=async(t,e,n)=>{try{const r=await i.default.get(t,{params:e,headers:n});if(200!==r.status)throw new Error(`Error fetching plan: ${r.statusText}`);return r.data}catch(t){const e=i.default.isAxiosError(t)?t.message:t;return console.log("error: ",e),e}};async function c(t,n){const r=o("preloads/components"),i=null!=n?n:"en",a={apiKey:"roomle_portal_v2",language:i,token:"anonym",configurationId:t},s=(0,e.requestHeaders)(i);return await l(r,a,s)}async function u(t,n){const r=o("configurations",t),i=null!=n?n:"en",a={apiKey:"roomle_portal_v2",language:i,token:"anonym"},s=(0,e.requestHeaders)(i);return await l(r,a,s)}async function h(t,n){const r=o("components",t),i=null!=n?n:"en",a={apiKey:"roomle_portal_v2",language:i,token:"anonym"},s=(0,e.requestHeaders)(i);return await l(r,a,s)}async function d(t,n){const r=o("components"),i=null!=n?n:"en",a={apiKey:"roomle_portal_v2",language:i,token:"anonym",ids:t},s=(0,e.requestHeaders)(i);return await l(r,a,s)}async function p(t,n){const r=o("items",t),i=null!=n?n:"en",a={apiKey:"roomle_portal_v2",language:i,token:"anonym"},s=(0,e.requestHeaders)(i);return await l(r,a,s)}async function f(t,n){const r=o("materials"),i=null!=n?n:"en",a={apiKey:"roomle_portal_v2",language:i,token:"anonym",embedTextures:"true",ids:t},s=(0,e.requestHeaders)(i);return await l(r,a,s)}async function m(t,n,r){const i=o("meshes",t),a=null!=r?r:"en",s={apiKey:"roomle_portal_v2",language:a,token:"anonym",format:"crt",targetQuality:n},c=(0,e.requestHeaders)(a);return await l(i,s,c)}async function g(t,n){const r=s+("/"===t[0]?"":"/")+t,i=null!=n?n:"en",a={apiKey:"roomle_portal_v2",language:i,token:"anonym"},o=(0,e.requestHeaders)(i);return await l(r,a,o)}async function v(t){const{data:e,status:n}=await i.default.get(t,{responseType:"arraybuffer"});return e}e.loadPlan=async(t,n)=>{if(!t)return null;const r=t.startsWith("ps_"),i=o(r?"planSnapshots":"plans",t),a=(0,e.requestHeaders)(n),s={apiKey:"roomle_portal_v2",language:null!=n?n:"en",token:"anonym"};return await l(i,s,a)},e.RapiRequests=class{loadPlan(t,n){return(0,e.loadPlan)(t,n)}preloadConfiguration(t,e){return c(t,e)}loadConfiguration(t,e){return u(t,e)}loadComponent(t,e){return h(t,e)}loadComponents(t,e){return d(t,e)}loadItem(t,e){return p(t,e)}loadMaterials(t,e){return f(t,e)}loadMesh(t,e,n){return m(t,e,n)}loadMeshData(t,e){return g(t,e)}loadData(t){return v(t)}}},125:(t,e,n)=>{var r,i=(r="undefined"!=typeof document?document.currentScript?.src:void 0,r||="/index.js",function(t={}){var e,i,a,s,o,l=t,c=new Promise(((t,n)=>{e=t,i=n})),u="object"==typeof window,h="function"==typeof importScripts,d="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,p=Object.assign({},l),f="./this.program",m=(t,e)=>{throw e},g="";if(d){var v=n(918),_=n(702);g="//",a=(t,e)=>(t=j(t)?new URL(t):_.normalize(t),v.readFileSync(t,e?void 0:"utf8")),o=t=>((t=a(t,!0)).buffer||(t=new Uint8Array(t)),t),s=(t,e,n)=>{t=j(t)?new URL(t):_.normalize(t),v.readFile(t,void 0,((t,r)=>{t?n(t):e(r.buffer)}))},!l.thisProgram&&1<process.argv.length&&(f=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),m=(t,e)=>{throw process.exitCode=t,e}}else(u||h)&&(h?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),r&&(g=r),g=g.startsWith("blob:")?"":g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1),a=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},h&&(o=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),s=(t,e,n)=>{fetch(t,{credentials:"same-origin"}).then((t=>t.ok?t.arrayBuffer():Promise.reject(Error(t.status+" : "+t.url)))).then(e,n)});var y,x=l.print||console.log.bind(console),b=l.printErr||console.error.bind(console);Object.assign(l,p),p=null,l.thisProgram&&(f=l.thisProgram),l.quit&&(m=l.quit),l.wasmBinary&&(y=l.wasmBinary);var w,M,T,E,S,A,R,C,P,I=!1;function L(){var t=w.buffer;l.HEAP8=M=new Int8Array(t),l.HEAP16=E=new Int16Array(t),l.HEAPU8=T=new Uint8Array(t),l.HEAPU16=S=new Uint16Array(t),l.HEAP32=A=new Int32Array(t),l.HEAPU32=R=new Uint32Array(t),l.HEAPF32=C=new Float32Array(t),l.HEAPF64=P=new Float64Array(t)}var D=[],O=[],N=[],U=[],F=!1;function B(){var t=l.preRun.shift();D.unshift(t)}var k=0,z=null,H=null;function G(t){throw l.onAbort?.(t),b(t="Aborted("+t+")"),I=!0,t+=". Build with -sASSERTIONS for more info.",F&&De(),t=new WebAssembly.RuntimeError(t),i(t),t}var V,W=t=>t.startsWith("data:application/octet-stream;base64,"),j=t=>t.startsWith("file://");function q(t){if(t==V&&y)return new Uint8Array(y);if(o)return o(t);throw"both async and sync fetching of the wasm failed"}function X(t,e,n){return function(t){return y?Promise.resolve().then((()=>q(t))):new Promise(((e,n)=>{s(t,(t=>e(new Uint8Array(t))),(()=>{try{e(q(t))}catch(t){n(t)}}))}))}(t).then((t=>WebAssembly.instantiate(t,e))).then(n,(t=>{b(`failed to asynchronously prepare wasm: ${t}`),G(t)}))}function Y(t){this.name="ExitStatus",this.message=`Program terminated with exit(${t})`,this.status=t}var $=t=>{for(;0<t.length;)t.shift()(l)},K=l.noExitRuntime||!0,Z={},J=t=>{for(;t.length;){var e=t.pop();t.pop()(e)}};function Q(t){return this.fromWireType(R[t>>2])}var tt,et,nt,rt={},it={},at={},st=(t,e,n)=>{function r(e){if((e=n(e)).length!==t.length)throw new tt("Mismatched type converter count");for(var r=0;r<t.length;++r)ct(t[r],e[r])}t.forEach((function(t){at[t]=e}));var i=Array(e.length),a=[],s=0;e.forEach(((t,e)=>{it.hasOwnProperty(t)?i[e]=it[t]:(a.push(t),rt.hasOwnProperty(t)||(rt[t]=[]),rt[t].push((()=>{i[e]=it[t],++s===a.length&&r(i)})))})),0===a.length&&r(i)},ot=t=>{for(var e="";T[t];)e+=et[T[t++]];return e},lt=t=>{throw new nt(t)};function ct(t,e,n={}){if(!("argPackAdvance"in e))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(t,e,n={}){var r=e.name;if(!t)throw new nt(`type "${r}" must have a positive integer typeid pointer`);if(it.hasOwnProperty(t)){if(n.Ra)return;throw new nt(`Cannot register type '${r}' twice`)}it[t]=e,delete at[t],rt.hasOwnProperty(t)&&(e=rt[t],delete rt[t],e.forEach((t=>t())))}(t,e,n)}var ut,ht=t=>{throw new nt(t.fa.ia.ga.name+" instance already deleted")},dt=!1,pt=()=>{},ft=(t,e,n)=>e===n?t:void 0===n.la||null===(t=ft(t,e,n.la))?null:n.Ka(t),mt={},gt=[],vt=()=>{for(;gt.length;){var t=gt.pop();t.fa.ta=!1,t.delete()}},_t={},yt=(t,e)=>{if(!e.ia||!e.ha)throw new tt("makeClassHandle requires ptr and ptrType");if(!!e.na!=!!e.ja)throw new tt("Both smartPtrType and smartPtr must be specified");return e.count={value:1},xt(Object.create(t,{fa:{value:e,writable:!0}}))},xt=t=>"undefined"==typeof FinalizationRegistry?(xt=t=>t,t):(dt=new FinalizationRegistry((t=>{--(t=t.fa).count.value,0===t.count.value&&(t.ja?t.na.oa(t.ja):t.ia.ga.oa(t.ha))})),pt=t=>{dt.unregister(t)},(xt=t=>{var e=t.fa;return e.ja&&dt.register(t,{fa:e},t),t})(t));function bt(){}var wt=(t,e)=>Object.defineProperty(e,"name",{value:t}),Mt=(t,e,n)=>{if(void 0===t[e].ka){var r=t[e];t[e]=function(...r){if(!t[e].ka.hasOwnProperty(r.length))throw new nt(`Function '${n}' called with an invalid number of arguments (${r.length}) - expects one of (${t[e].ka})!`);return t[e].ka[r.length].apply(this,r)},t[e].ka=[],t[e].ka[r.xa]=r}},Tt=(t,e,n)=>{if(l.hasOwnProperty(t)){if(void 0===n||void 0!==l[t].ka&&void 0!==l[t].ka[n])throw new nt(`Cannot register public name '${t}' twice`);if(Mt(l,t,t),l.hasOwnProperty(n))throw new nt(`Cannot register multiple overloads of a function with the same number of arguments (${n})!`);l[t].ka[n]=e}else l[t]=e,void 0!==n&&(l[t].eb=n)};function Et(t,e,n,r,i,a,s,o){this.name=t,this.constructor=e,this.ua=n,this.oa=r,this.la=i,this.Ma=a,this.wa=s,this.Ka=o,this.Ua=[]}var St=(t,e,n)=>{for(;e!==n;){if(!e.wa)throw new nt(`Expected null or instance of ${n.name}, got an instance of ${e.name}`);t=e.wa(t),e=e.la}return t};function At(t,e){if(null===e){if(this.Ca)throw new nt(`null is not a valid ${this.name}`);return 0}if(!e.fa)throw new nt(`Cannot pass "${Qt(e)}" as a ${this.name}`);if(!e.fa.ha)throw new nt(`Cannot pass deleted object as a pointer of type ${this.name}`);return St(e.fa.ha,e.fa.ia.ga,this.ga)}function Rt(t,e){if(null===e){if(this.Ca)throw new nt(`null is not a valid ${this.name}`);if(this.za){var n=this.Da();return null!==t&&t.push(this.oa,n),n}return 0}if(!e||!e.fa)throw new nt(`Cannot pass "${Qt(e)}" as a ${this.name}`);if(!e.fa.ha)throw new nt(`Cannot pass deleted object as a pointer of type ${this.name}`);if(!this.ya&&e.fa.ia.ya)throw new nt(`Cannot convert argument of type ${e.fa.na?e.fa.na.name:e.fa.ia.name} to parameter type ${this.name}`);if(n=St(e.fa.ha,e.fa.ia.ga,this.ga),this.za){if(void 0===e.fa.ja)throw new nt("Passing raw pointer to smart pointer is illegal");switch(this.Za){case 0:if(e.fa.na!==this)throw new nt(`Cannot convert argument of type ${e.fa.na?e.fa.na.name:e.fa.ia.name} to parameter type ${this.name}`);n=e.fa.ja;break;case 1:n=e.fa.ja;break;case 2:if(e.fa.na===this)n=e.fa.ja;else{var r=e.clone();n=this.Va(n,$t((()=>r.delete()))),null!==t&&t.push(this.oa,n)}break;default:throw new nt("Unsupporting sharing policy")}}return n}function Ct(t,e){if(null===e){if(this.Ca)throw new nt(`null is not a valid ${this.name}`);return 0}if(!e.fa)throw new nt(`Cannot pass "${Qt(e)}" as a ${this.name}`);if(!e.fa.ha)throw new nt(`Cannot pass deleted object as a pointer of type ${this.name}`);if(e.fa.ia.ya)throw new nt(`Cannot convert argument of type ${e.fa.ia.name} to parameter type ${this.name}`);return St(e.fa.ha,e.fa.ia.ga,this.ga)}function Pt(t,e,n,r,i,a,s,o,l,c,u){this.name=t,this.ga=e,this.Ca=n,this.ya=r,this.za=i,this.Ta=a,this.Za=s,this.Ia=o,this.Da=l,this.Va=c,this.oa=u,i||void 0!==e.la?this.toWireType=Rt:(this.toWireType=r?At:Ct,this.ma=null)}var It,Lt,Dt=(t,e,n)=>{if(!l.hasOwnProperty(t))throw new tt("Replacing nonexistent public symbol");void 0!==l[t].ka&&void 0!==n?l[t].ka[n]=e:(l[t]=e,l[t].xa=n)},Ot=(t,e)=>{var n=(t=ot(t)).includes("j")?((t,e)=>(...n)=>((t,e,n=[])=>(t.includes("j")?(t=t.replace(/p/g,"i"),e=(0,l["dynCall_"+t])(e,...n)):e=It.get(e)(...n),e))(t,e,n))(t,e):It.get(e);if("function"!=typeof n)throw new nt(`unknown function pointer with signature ${t}: ${e}`);return n},Nt=t=>{t=Ce(t);var e=ot(t);return Pe(t),e},Ut=(t,e)=>{var n=[],r={};throw e.forEach((function t(e){r[e]||it[e]||(at[e]?at[e].forEach(t):(n.push(e),r[e]=!0))})),new Lt(`${t}: `+n.map(Nt).join([", "]))},Ft=(t,e)=>{for(var n=[],r=0;r<t;r++)n.push(R[e+4*r>>2]);return n};function Bt(t){for(var e=1;e<t.length;++e)if(null!==t[e]&&void 0===t[e].ma)return!0;return!1}function kt(t){var e=Function;if(!(e instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof e} which is not a function`);var n=wt(e.name||"unknownFunctionName",(function(){}));return n.prototype=e.prototype,n=new n,(t=e.apply(n,t))instanceof Object?t:n}function zt(t,e,n,r,i,a){var s=e.length;if(2>s)throw new nt("argTypes array size mismatch! Must at least get return value and 'this' types!");var o=null!==e[1]&&null!==n,l=Bt(e);for(n="void"!==e[0].name,r=[t,lt,r,i,J,e[0],e[1]],i=0;i<s-2;++i)r.push(e[i+2]);if(!l)for(i=o?1:2;i<e.length;++i)null!==e[i].ma&&r.push(e[i].ma);l=Bt(e),i=e.length;var c="",u="";for(s=0;s<i-2;++s)c+=(0!==s?", ":"")+"arg"+s,u+=(0!==s?", ":"")+"arg"+s+"Wired";c=`\n        return function (${c}) {\n        if (arguments.length !== ${i-2}) {\n          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${i-2}');\n        }`,l&&(c+="var destructors = [];\n");var h=l?"destructors":"null",d="humanName throwBindingError invoker fn runDestructors retType classParam".split(" ");for(o&&(c+="var thisWired = classParam['toWireType']("+h+", this);\n"),s=0;s<i-2;++s)c+="var arg"+s+"Wired = argType"+s+"['toWireType']("+h+", arg"+s+");\n",d.push("argType"+s);if(o&&(u="thisWired"+(0<u.length?", ":"")+u),c+=(n||a?"var rv = ":"")+"invoker(fn"+(0<u.length?", ":"")+u+");\n",l)c+="runDestructors(destructors);\n";else for(s=o?1:2;s<e.length;++s)a=1===s?"thisWired":"arg"+(s-2)+"Wired",null!==e[s].ma&&(c+=`${a}_dtor(${a});\n`,d.push(`${a}_dtor`));n&&(c+="var ret = retType['fromWireType'](rv);\nreturn ret;\n");let[p,f]=[d,c+"}\n"];return p.push(f),e=kt(p)(...r),wt(t,e)}var Ht,Gt,Vt,Wt=t=>{const e=(t=t.trim()).indexOf("(");return-1!==e?t.substr(0,e):t},jt=[],qt=[],Xt=t=>{9<t&&0==--qt[t+1]&&(qt[t]=void 0,jt.push(t))},Yt=t=>{if(!t)throw new nt("Cannot use deleted val. handle = "+t);return qt[t]},$t=t=>{switch(t){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:const e=jt.pop()||qt.length;return qt[e]=t,qt[e+1]=1,e}},Kt={name:"emscripten::val",fromWireType:t=>{var e=Yt(t);return Xt(t),e},toWireType:(t,e)=>$t(e),argPackAdvance:8,readValueFromPointer:Q,ma:null},Zt=(t,e,n)=>{switch(e){case 1:return n?function(t){return this.fromWireType(M[t])}:function(t){return this.fromWireType(T[t])};case 2:return n?function(t){return this.fromWireType(E[t>>1])}:function(t){return this.fromWireType(S[t>>1])};case 4:return n?function(t){return this.fromWireType(A[t>>2])}:function(t){return this.fromWireType(R[t>>2])};default:throw new TypeError(`invalid integer width (${e}): ${t}`)}},Jt=(t,e)=>{var n=it[t];if(void 0===n)throw t=`${e} has unknown type ${Nt(t)}`,new nt(t);return n},Qt=t=>{if(null===t)return"null";var e=typeof t;return"object"===e||"array"===e||"function"===e?t.toString():""+t},te=(t,e)=>{switch(e){case 4:return function(t){return this.fromWireType(C[t>>2])};case 8:return function(t){return this.fromWireType(P[t>>3])};default:throw new TypeError(`invalid float width (${e}): ${t}`)}},ee=(t,e,n)=>{switch(e){case 1:return n?t=>M[t]:t=>T[t];case 2:return n?t=>E[t>>1]:t=>S[t>>1];case 4:return n?t=>A[t>>2]:t=>R[t>>2];default:throw new TypeError(`invalid integer width (${e}): ${t}`)}},ne=(t,e,n,r)=>{if(0<r){r=n+r-1;for(var i=0;i<t.length;++i){var a=t.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++i)),127>=a){if(n>=r)break;e[n++]=a}else{if(2047>=a){if(n+1>=r)break;e[n++]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++]=224|a>>12}else{if(n+3>=r)break;e[n++]=240|a>>18,e[n++]=128|a>>12&63}e[n++]=128|a>>6&63}e[n++]=128|63&a}}e[n]=0}},re=t=>{for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e},ie="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,ae=(t,e,n)=>{var r=e+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&ie)return ie.decode(t.subarray(e,n));for(r="";e<n;){var i=t[e++];if(128&i){var a=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|a);else{var s=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|a<<6|s:(7&i)<<18|a<<12|s<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r},se="undefined"!=typeof TextDecoder?new TextDecoder("utf-16le"):void 0,oe=(t,e)=>{for(var n=t>>1,r=n+e/2;!(n>=r)&&S[n];)++n;if(32<(n<<=1)-t&&se)return se.decode(T.subarray(t,n));for(n="",r=0;!(r>=e/2);++r){var i=E[t+2*r>>1];if(0==i)break;n+=String.fromCharCode(i)}return n},le=(t,e,n)=>{if(n??=2147483647,2>n)return 0;var r=e;n=(n-=2)<2*t.length?n/2:t.length;for(var i=0;i<n;++i)E[e>>1]=t.charCodeAt(i),e+=2;return E[e>>1]=0,e-r},ce=t=>2*t.length,ue=(t,e)=>{for(var n=0,r="";!(n>=e/4);){var i=A[t+4*n>>2];if(0==i)break;++n,65536<=i?(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i)):r+=String.fromCharCode(i)}return r},he=(t,e,n)=>{if(n??=2147483647,4>n)return 0;var r=e;n=r+n-4;for(var i=0;i<t.length;++i){var a=t.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++i)),A[e>>2]=a,(e+=4)+4>n)break}return A[e>>2]=0,e-r},de=t=>{for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);55296<=r&&57343>=r&&++n,e+=4}return e},pe=(t,e,n)=>{var r=[];return t=t.toWireType(r,n),r.length&&(R[e>>2]=$t(r)),t},fe=[],me={},ge=t=>{var e=me[t];return void 0===e?ot(t):e},ve=()=>"object"==typeof globalThis?globalThis:Function("return this")(),_e={},ye=()=>{if(!Ht){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:f||"./this.program"};for(t in _e)void 0===_e[t]?delete e[t]:e[t]=_e[t];var n=[];for(t in e)n.push(`${t}=${e[t]}`);Ht=n}return Ht},xe=[null,[],[]],be=t=>0==t%4&&(0!=t%100||0==t%400),we=[31,29,31,30,31,30,31,31,30,31,30,31],Me=[31,28,31,30,31,30,31,31,30,31,30,31];tt=l.InternalError=class extends Error{constructor(t){super(t),this.name="InternalError"}};for(var Te=Array(256),Ee=0;256>Ee;++Ee)Te[Ee]=String.fromCharCode(Ee);et=Te,nt=l.BindingError=class extends Error{constructor(t){super(t),this.name="BindingError"}},Object.assign(bt.prototype,{isAliasOf:function(t){if(!(this instanceof bt&&t instanceof bt))return!1;var e=this.fa.ia.ga,n=this.fa.ha;t.fa=t.fa;var r=t.fa.ia.ga;for(t=t.fa.ha;e.la;)n=e.wa(n),e=e.la;for(;r.la;)t=r.wa(t),r=r.la;return e===r&&n===t},clone:function(){if(this.fa.ha||ht(this),this.fa.va)return this.fa.count.value+=1,this;var t=xt,e=Object,n=e.create,r=Object.getPrototypeOf(this),i=this.fa;return(t=t(n.call(e,r,{fa:{value:{count:i.count,ta:i.ta,va:i.va,ha:i.ha,ia:i.ia,ja:i.ja,na:i.na}}}))).fa.count.value+=1,t.fa.ta=!1,t},delete(){if(this.fa.ha||ht(this),this.fa.ta&&!this.fa.va)throw new nt("Object already scheduled for deletion");pt(this);var t=this.fa;--t.count.value,0===t.count.value&&(t.ja?t.na.oa(t.ja):t.ia.ga.oa(t.ha)),this.fa.va||(this.fa.ja=void 0,this.fa.ha=void 0)},isDeleted:function(){return!this.fa.ha},deleteLater:function(){if(this.fa.ha||ht(this),this.fa.ta&&!this.fa.va)throw new nt("Object already scheduled for deletion");return gt.push(this),1===gt.length&&ut&&ut(vt),this.fa.ta=!0,this}}),l.getInheritedInstanceCount=()=>Object.keys(_t).length,l.getLiveInheritedInstances=()=>{var t,e=[];for(t in _t)_t.hasOwnProperty(t)&&e.push(_t[t]);return e},l.flushPendingDeletes=vt,l.setDelayFunction=t=>{ut=t,gt.length&&ut&&ut(vt)},Object.assign(Pt.prototype,{Na(t){return this.Ia&&(t=this.Ia(t)),t},Ga(t){this.oa?.(t)},argPackAdvance:8,readValueFromPointer:Q,fromWireType:function(t){function e(){return this.za?yt(this.ga.ua,{ia:this.Ta,ha:n,na:this,ja:t}):yt(this.ga.ua,{ia:this,ha:t})}var n=this.Na(t);if(!n)return this.Ga(t),null;var r=((t,e)=>{if(void 0===e)throw new nt("ptr should not be undefined");for(;t.la;)e=t.wa(e),t=t.la;return _t[e]})(this.ga,n);if(void 0!==r)return 0===r.fa.count.value?(r.fa.ha=n,r.fa.ja=t,r.clone()):(r=r.clone(),this.Ga(t),r);if(r=this.ga.Ma(n),!(r=mt[r]))return e.call(this);r=this.ya?r.Ja:r.pointerType;var i=ft(n,this.ga,r.ga);return null===i?e.call(this):this.za?yt(r.ga.ua,{ia:r,ha:i,na:this,ja:t}):yt(r.ga.ua,{ia:r,ha:i})}}),Lt=l.UnboundTypeError=(Gt=Error,(Vt=wt("UnboundTypeError",(function(t){this.name="UnboundTypeError",this.message=t,void 0!==(t=Error(t).stack)&&(this.stack=this.toString()+"\n"+t.replace(/^Error(:[^\n]*)?\n/,""))}))).prototype=Object.create(Gt.prototype),Vt.prototype.constructor=Vt,Vt.prototype.toString=function(){return void 0===this.message?this.name:`${this.name}: ${this.message}`},Vt),qt.push(0,1,void 0,1,null,1,!0,1,!1,1),l.count_emval_handles=()=>qt.length/2-5-jt.length;var Se,Ae={B:()=>{G("")},Q:t=>{var e=Z[t];delete Z[t];var n=e.Da,r=e.oa,i=e.Ha,a=i.map((t=>t.Qa)).concat(i.map((t=>t.Xa)));st([t],a,(t=>{var a={};return i.forEach(((e,n)=>{var r=t[n],s=e.Oa,o=e.Pa,l=t[n+i.length],c=e.Wa,u=e.Ya;a[e.La]={read:t=>r.fromWireType(s(o,t)),write:(t,e)=>{var n=[];c(u,t,l.toWireType(n,e)),J(n)}}})),[{name:e.name,fromWireType:t=>{var e,n={};for(e in a)n[e]=a[e].read(t);return r(t),n},toWireType:(t,e)=>{for(var i in a)if(!(i in e))throw new TypeError(`Missing field: "${i}"`);var s=n();for(i in a)a[i].write(s,e[i]);return null!==t&&t.push(r,s),s},argPackAdvance:8,readValueFromPointer:Q,ma:r}]}))},A:()=>{},L:(t,e,n,r)=>{ct(t,{name:e=ot(e),fromWireType:function(t){return!!t},toWireType:function(t,e){return e?n:r},argPackAdvance:8,readValueFromPointer:function(t){return this.fromWireType(T[t])},ma:null})},d:(t,e,n,r,i,a,s,o,l,c,u,h,d)=>{u=ot(u),a=Ot(i,a),o&&=Ot(s,o),c&&=Ot(l,c),d=Ot(h,d);var p=(t=>{if(void 0===t)return"_unknown";var e=(t=t.replace(/[^a-zA-Z0-9_]/g,"$")).charCodeAt(0);return 48<=e&&57>=e?`_${t}`:t})(u);Tt(p,(function(){Ut(`Cannot construct ${u} due to unbound types`,[r])})),st([t,e,n],r?[r]:[],(e=>{if(e=e[0],r)var n=e.ga,i=n.ua;else i=bt.prototype;e=wt(u,(function(...t){if(Object.getPrototypeOf(this)!==s)throw new nt("Use 'new' to construct "+u);if(void 0===h.qa)throw new nt(u+" has no accessible constructor");var e=h.qa[t.length];if(void 0===e)throw new nt(`Tried to invoke ctor of ${u} with invalid number of parameters (${t.length}) - expected (${Object.keys(h.qa).toString()}) parameters instead!`);return e.apply(this,t)}));var s=Object.create(i,{constructor:{value:e}});e.prototype=s;var l,h=new Et(u,e,s,d,n,a,o,c);return h.la&&((l=h.la).Fa??(l.Fa=[]),h.la.Fa.push(h)),n=new Pt(u,h,!0,!1,!1),l=new Pt(u+"*",h,!1,!1,!1),i=new Pt(u+" const*",h,!1,!0,!1),mt[t]={pointerType:l,Ja:i},Dt(p,e),[n,l,i]}))},c:(t,e,n,r,i,a)=>{var s=Ft(e,n);i=Ot(r,i),st([],[t],(t=>{var n=`constructor ${(t=t[0]).name}`;if(void 0===t.ga.qa&&(t.ga.qa=[]),void 0!==t.ga.qa[e-1])throw new nt(`Cannot register multiple constructors with identical number of parameters (${e-1}) for class '${t.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);return t.ga.qa[e-1]=()=>{Ut(`Cannot construct ${t.name} due to unbound types`,s)},st([],s,(r=>(r.splice(1,0,null),t.ga.qa[e-1]=zt(n,r,null,i,a),[]))),[]}))},a:(t,e,n,r,i,a,s,o,l)=>{var c=Ft(n,r);e=ot(e),e=Wt(e),a=Ot(i,a),st([],[t],(t=>{function r(){Ut(`Cannot call ${i} due to unbound types`,c)}var i=`${(t=t[0]).name}.${e}`;e.startsWith("@@")&&(e=Symbol[e.substring(2)]),o&&t.ga.Ua.push(e);var u=t.ga.ua,h=u[e];return void 0===h||void 0===h.ka&&h.className!==t.name&&h.xa===n-2?(r.xa=n-2,r.className=t.name,u[e]=r):(Mt(u,e,i),u[e].ka[n-2]=r),st([],c,(r=>(r=zt(i,r,t,a,s,l),void 0===u[e].ka?(r.xa=n-2,u[e]=r):u[e].ka[n-2]=r,[]))),[]}))},J:t=>ct(t,Kt),o:(t,e,n,r)=>{function i(){}e=ot(e),i.values={},ct(t,{name:e,constructor:i,fromWireType:function(t){return this.constructor.values[t]},toWireType:(t,e)=>e.value,argPackAdvance:8,readValueFromPointer:Zt(e,n,r),ma:null}),Tt(e,i)},j:(t,e,n)=>{var r=Jt(t,"enum");e=ot(e),t=r.constructor,r=Object.create(r.constructor.prototype,{value:{value:n},constructor:{value:wt(`${r.name}_${e}`,(function(){}))}}),t.values[n]=r,t[e]=r},u:(t,e,n)=>{ct(t,{name:e=ot(e),fromWireType:t=>t,toWireType:(t,e)=>e,argPackAdvance:8,readValueFromPointer:te(e,n),ma:null})},p:(t,e,n,r,i,a,s)=>{var o=Ft(e,n);t=ot(t),t=Wt(t),i=Ot(r,i),Tt(t,(function(){Ut(`Cannot call ${t} due to unbound types`,o)}),e-1),st([],o,(n=>(n=[n[0],null].concat(n.slice(1)),Dt(t,zt(t,n,null,i,a,s),e-1),[])))},m:(t,e,n,r,i)=>{if(e=ot(e),-1===i&&(i=4294967295),i=t=>t,0===r){var a=32-8*n;i=t=>t<<a>>>a}var s=e.includes("unsigned")?function(t,e){return e>>>0}:function(t,e){return e};ct(t,{name:e,fromWireType:i,toWireType:s,argPackAdvance:8,readValueFromPointer:ee(e,n,0!==r),ma:null})},k:(t,e,n)=>{function r(t){return new i(M.buffer,R[t+4>>2],R[t>>2])}var i=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][e];ct(t,{name:n=ot(n),fromWireType:r,argPackAdvance:8,readValueFromPointer:r},{Ra:!0})},i:t=>{ct(t,Kt)},s:(t,e,n,r,i,a,s,o,l,c,u,h)=>{n=ot(n),a=Ot(i,a),o=Ot(s,o),c=Ot(l,c),h=Ot(u,h),st([t],[e],(t=>(t=t[0],[new Pt(n,t.ga,!1,!1,!0,t,r,a,o,c,h)])))},v:(t,e)=>{var n="std::string"===(e=ot(e));ct(t,{name:e,fromWireType:function(t){var e=R[t>>2],r=t+4;if(n)for(var i=r,a=0;a<=e;++a){var s=r+a;if(a==e||0==T[s]){if(i=i?ae(T,i,s-i):"",void 0===o)var o=i;else o+=String.fromCharCode(0),o+=i;i=s+1}}else{for(o=Array(e),a=0;a<e;++a)o[a]=String.fromCharCode(T[r+a]);o=o.join("")}return Pe(t),o},toWireType:function(t,e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var r="string"==typeof e;if(!(r||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Int8Array))throw new nt("Cannot pass non-string to std::string");var i=n&&r?re(e):e.length,a=Ie(4+i+1),s=a+4;if(R[a>>2]=i,n&&r)ne(e,T,s,i+1);else if(r)for(r=0;r<i;++r){var o=e.charCodeAt(r);if(255<o)throw Pe(s),new nt("String has UTF-16 code units that do not fit in 8 bits");T[s+r]=o}else for(r=0;r<i;++r)T[s+r]=e[r];return null!==t&&t.push(Pe,a),a},argPackAdvance:8,readValueFromPointer:Q,ma(t){Pe(t)}})},r:(t,e,n)=>{if(n=ot(n),2===e)var r=oe,i=le,a=ce,s=t=>S[t>>1];else 4===e&&(r=ue,i=he,a=de,s=t=>R[t>>2]);ct(t,{name:n,fromWireType:t=>{for(var n,i=R[t>>2],a=t+4,o=0;o<=i;++o){var l=t+4+o*e;o!=i&&0!=s(l)||(a=r(a,l-a),void 0===n?n=a:(n+=String.fromCharCode(0),n+=a),a=l+e)}return Pe(t),n},toWireType:(t,r)=>{if("string"!=typeof r)throw new nt(`Cannot pass non-string to C++ string type ${n}`);var s=a(r),o=Ie(4+s+e);return R[o>>2]=s/e,i(r,o+4,s+e),null!==t&&t.push(Pe,o),o},argPackAdvance:8,readValueFromPointer:Q,ma(t){Pe(t)}})},f:(t,e,n,r,i,a)=>{Z[t]={name:ot(e),Da:Ot(n,r),oa:Ot(i,a),Ha:[]}},b:(t,e,n,r,i,a,s,o,l,c)=>{Z[t].Ha.push({La:ot(e),Qa:n,Oa:Ot(r,i),Pa:a,Xa:s,Wa:Ot(o,l),Ya:c})},M:(t,e)=>{ct(t,{Sa:!0,name:e=ot(e),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},q:(t,e,n)=>(t=Yt(t),e=Jt(e,"emval::as"),pe(e,n,t)),w:(t,e,n,r)=>(t=fe[t])(null,e=Yt(e),n,r),g:(t,e,n,r,i)=>(t=fe[t])(e=Yt(e),e[n=ge(n)],r,i),S:Xt,K:t=>0===t?$t(ve()):(t=ge(t),$t(ve()[t])),e:(t,e,n)=>{e=((t,e)=>{for(var n=Array(t),r=0;r<t;++r)n[r]=Jt(R[e+4*r>>2],"parameter "+r);return n})(t,e);var r=e.shift();t--;var i="return function (obj, func, destructorsRef, args) {\n",a=0,s=[];0===n&&s.push("obj");for(var o=["retType"],l=[r],c=0;c<t;++c)s.push("arg"+c),o.push("argType"+c),l.push(e[c]),i+=`  var arg${c} = argType${c}.readValueFromPointer(args${a?"+"+a:""});\n`,a+=e[c].argPackAdvance;return i+=`  var rv = ${1===n?"new func":"func.call"}(${s.join(", ")});\n`,r.Sa||(o.push("emval_returnValue"),l.push(pe),i+="  return emval_returnValue(retType, destructorsRef, rv);\n"),o.push(i+"};\n"),t=kt(o)(...l),n=`methodCaller<(${e.map((t=>t.name)).join(", ")}) => ${r.name}>`,(t=>{var e=fe.length;return fe.push(t),e})(wt(n,t))},N:t=>(t=ge(t),$t(l[t])),n:(t,e)=>(t=Yt(t),e=Yt(e),$t(t[e])),t:t=>{9<t&&(qt[t+1]+=1)},O:(t,e)=>(t=Yt(t))instanceof Yt(e),T:()=>$t([]),x:t=>$t(ge(t)),P:()=>$t({}),y:t=>{var e=Yt(t);J(e),Xt(t)},l:(t,e,n)=>{t=Yt(t),e=Yt(e),n=Yt(n),t[e]=n},R:(t,e)=>(t=Yt(t))===Yt(e),h:(t,e)=>(t=(t=Jt(t,"_emval_take_value")).readValueFromPointer(e),$t(t)),D:t=>{var e=T.length;if(2147483648<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var i=Math;r=Math.max(t,r);t:{i=(i.min.call(i,2147483648,r+(65536-r%65536)%65536)-w.buffer.byteLength+65535)/65536;try{w.grow(i),L();var a=1;break t}catch(t){}a=void 0}if(a)return!0}return!1},E:(t,e)=>{var n=0;return ye().forEach(((r,i)=>{var a=e+n;for(i=R[t+4*i>>2]=a,a=0;a<r.length;++a)M[i++]=r.charCodeAt(a);M[i]=0,n+=r.length+1})),0},F:(t,e)=>{var n=ye();R[t>>2]=n.length;var r=0;return n.forEach((t=>r+=t.length+1)),R[e>>2]=r,0},G:()=>52,I:()=>52,z:function(){return 70},H:(t,e,n,r)=>{for(var i=0,a=0;a<n;a++){var s=R[e>>2],o=R[e+4>>2];e+=8;for(var l=0;l<o;l++){var c=T[s+l],u=xe[t];0===c||10===c?((1===t?x:b)(ae(u,0)),u.length=0):u.push(c)}i+=o}return R[r>>2]=i,0},C:(t,e,n,r)=>((t,e,n,r)=>{function i(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function a(t,e){return i(t,e,"0")}function s(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function o(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.ra;for(t=new Date(new Date(t.sa+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(be(t.getFullYear())?we:Me)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=o(new Date(t.getFullYear(),0,4)),n=o(n),0>=s(e,t)?0>=s(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=R[r+40>>2];for(var u in r={bb:A[r>>2],ab:A[r+4>>2],Aa:A[r+8>>2],Ea:A[r+12>>2],Ba:A[r+16>>2],sa:A[r+20>>2],pa:A[r+24>>2],ra:A[r+28>>2],fb:A[r+32>>2],$a:A[r+36>>2],cb:c&&c?ae(T,c):""},n=n?ae(T,n):"",c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(u,"g"),c[u]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(u in c={"%a":t=>h[t.pa].substring(0,3),"%A":t=>h[t.pa],"%b":t=>d[t.Ba].substring(0,3),"%B":t=>d[t.Ba],"%C":t=>a((t.sa+1900)/100|0,2),"%d":t=>a(t.Ea,2),"%e":t=>i(t.Ea,2," "),"%g":t=>l(t).toString().substring(2),"%G":l,"%H":t=>a(t.Aa,2),"%I":t=>(0==(t=t.Aa)?t=12:12<t&&(t-=12),a(t,2)),"%j":t=>{for(var e=0,n=0;n<=t.Ba-1;e+=(be(t.sa+1900)?we:Me)[n++]);return a(t.Ea+e,3)},"%m":t=>a(t.Ba+1,2),"%M":t=>a(t.ab,2),"%n":()=>"\n","%p":t=>0<=t.Aa&&12>t.Aa?"AM":"PM","%S":t=>a(t.bb,2),"%t":()=>"\t","%u":t=>t.pa||7,"%U":t=>a(Math.floor((t.ra+7-t.pa)/7),2),"%V":t=>{var e=Math.floor((t.ra+7-(t.pa+6)%7)/7);if(2>=(t.pa+371-t.ra-2)%7&&e++,e)53==e&&(4==(n=(t.pa+371-t.ra)%7)||3==n&&be(t.sa)||(e=1));else{e=52;var n=(t.pa+7-t.ra-1)%7;(4==n||5==n&&be(t.sa%400-1))&&e++}return a(e,2)},"%w":t=>t.pa,"%W":t=>a(Math.floor((t.ra+7-(t.pa+6)%7)/7),2),"%y":t=>(t.sa+1900).toString().substring(2),"%Y":t=>t.sa+1900,"%z":t=>{var e=0<=(t=t.$a);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":t=>t.cb,"%%":()=>"%"},n=n.replace(/%%/g,"\0\0"),c)n.includes(u)&&(n=n.replace(new RegExp(u,"g"),c[u](r)));return u=function(t){var e=Array(re(t)+1);return ne(t,e,0,e.length),e}(n=n.replace(/\0\0/g,"%")),u.length>e?0:(M.set(u,t),u.length-1)})(t,e,n,r)},Re=function(){function t(t){return Re=t.exports,w=Re.U,L(),It=Re._,O.unshift(Re.V),k--,l.monitorRunDependencies?.(k),0==k&&(null!==z&&(clearInterval(z),z=null),H&&(t=H,H=null,t())),Re}var e={a:Ae};if(k++,l.monitorRunDependencies?.(k),l.instantiateWasm)try{return l.instantiateWasm(e,t)}catch(t){b(`Module.instantiateWasm callback failed with error: ${t}`),i(t)}return V||=W("ConfiguratorKernel.wasm")?"ConfiguratorKernel.wasm":l.locateFile?l.locateFile("ConfiguratorKernel.wasm",g):g+"ConfiguratorKernel.wasm",function(t,e){var n=V;return y||"function"!=typeof WebAssembly.instantiateStreaming||W(n)||d||"function"!=typeof fetch?X(n,t,e):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,t).then(e,(function(r){return b(`wasm streaming compile failed: ${r}`),b("falling back to ArrayBuffer instantiation"),X(n,t,e)}))))}(e,(function(e){t(e.instance)})).catch(i),{}}(),Ce=t=>(Ce=Re.W)(t),Pe=t=>(Pe=Re.X)(t),Ie=t=>(Ie=Re.Y)(t),Le=l._main=(t,e)=>(Le=l._main=Re.Z)(t,e),De=()=>(De=Re.$)();function Oe(){function t(){if(!Se&&(Se=!0,l.calledRun=!0,!I)){if(F=!0,$(O),$(N),e(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),Ne){var t=Le;try{var n=t(0,0);K||(l.onExit?.(n),I=!0),m(n,new Y(n))}catch(t){t instanceof Y||"unwind"==t||m(1,t)}}if(l.postRun)for("function"==typeof l.postRun&&(l.postRun=[l.postRun]);l.postRun.length;)t=l.postRun.shift(),U.unshift(t);$(U)}}if(!(0<k)){if(l.preRun)for("function"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)B();$(D),0<k||(l.setStatus?(l.setStatus("Running..."),setTimeout((function(){setTimeout((function(){l.setStatus("")}),1),t()}),1)):t())}}if(l.dynCall_viijii=(t,e,n,r,i,a,s)=>(l.dynCall_viijii=Re.aa)(t,e,n,r,i,a,s),l.dynCall_jiji=(t,e,n,r,i)=>(l.dynCall_jiji=Re.ba)(t,e,n,r,i),l.dynCall_iiiiij=(t,e,n,r,i,a,s)=>(l.dynCall_iiiiij=Re.ca)(t,e,n,r,i,a,s),l.dynCall_iiiiijj=(t,e,n,r,i,a,s,o,c)=>(l.dynCall_iiiiijj=Re.da)(t,e,n,r,i,a,s,o,c),l.dynCall_iiiiiijj=(t,e,n,r,i,a,s,o,c,u)=>(l.dynCall_iiiiiijj=Re.ea)(t,e,n,r,i,a,s,o,c,u),H=function t(){Se||Oe(),Se||(H=t)},l.preInit)for("function"==typeof l.preInit&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();var Ne=!0;return l.noInitialRun&&(Ne=!1),Oe(),c});t.exports=i},930:(t,e,n)=>{var r,i=(r="undefined"!=typeof document?document.currentScript?.src:void 0,r||="/index.js",function(t={}){var e,i,a,s,o,l=t,c=new Promise(((t,n)=>{e=t,i=n})),u="object"==typeof window,h="function"==typeof importScripts,d="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,p=Object.assign({},l),f="./this.program",m=(t,e)=>{throw e},g="";if(d){var v=n(918),_=n(702);g="//",a=(t,e)=>(t=j(t)?new URL(t):_.normalize(t),v.readFileSync(t,e?void 0:"utf8")),o=t=>((t=a(t,!0)).buffer||(t=new Uint8Array(t)),t),s=(t,e,n)=>{t=j(t)?new URL(t):_.normalize(t),v.readFile(t,void 0,((t,r)=>{t?n(t):e(r.buffer)}))},!l.thisProgram&&1<process.argv.length&&(f=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),m=(t,e)=>{throw process.exitCode=t,e}}else(u||h)&&(h?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),r&&(g=r),g=g.startsWith("blob:")?"":g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1),a=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},h&&(o=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),s=(t,e,n)=>{fetch(t,{credentials:"same-origin"}).then((t=>t.ok?t.arrayBuffer():Promise.reject(Error(t.status+" : "+t.url)))).then(e,n)});var y,x=l.print||console.log.bind(console),b=l.printErr||console.error.bind(console);Object.assign(l,p),p=null,l.thisProgram&&(f=l.thisProgram),l.quit&&(m=l.quit),l.wasmBinary&&(y=l.wasmBinary);var w,M,T,E,S,A,R,C,P,I=!1;function L(){var t=w.buffer;l.HEAP8=M=new Int8Array(t),l.HEAP16=E=new Int16Array(t),l.HEAPU8=T=new Uint8Array(t),l.HEAPU16=S=new Uint16Array(t),l.HEAP32=A=new Int32Array(t),l.HEAPU32=R=new Uint32Array(t),l.HEAPF32=C=new Float32Array(t),l.HEAPF64=P=new Float64Array(t)}var D=[],O=[],N=[],U=[],F=!1;function B(){var t=l.preRun.shift();D.unshift(t)}var k=0,z=null,H=null;function G(t){throw l.onAbort?.(t),b(t="Aborted("+t+")"),I=!0,t+=". Build with -sASSERTIONS for more info.",F&&Oe(),t=new WebAssembly.RuntimeError(t),i(t),t}var V,W=t=>t.startsWith("data:application/octet-stream;base64,"),j=t=>t.startsWith("file://");function q(t){if(t==V&&y)return new Uint8Array(y);if(o)return o(t);throw"both async and sync fetching of the wasm failed"}function X(t,e,n){return function(t){return y?Promise.resolve().then((()=>q(t))):new Promise(((e,n)=>{s(t,(t=>e(new Uint8Array(t))),(()=>{try{e(q(t))}catch(t){n(t)}}))}))}(t).then((t=>WebAssembly.instantiate(t,e))).then(n,(t=>{b(`failed to asynchronously prepare wasm: ${t}`),G(t)}))}function Y(t){this.name="ExitStatus",this.message=`Program terminated with exit(${t})`,this.status=t}var $=t=>{for(;0<t.length;)t.shift()(l)},K=l.noExitRuntime||!0,Z={},J=t=>{for(;t.length;){var e=t.pop();t.pop()(e)}};function Q(t){return this.fromWireType(R[t>>2])}var tt,et,nt,rt={},it={},at={},st=(t,e,n)=>{function r(e){if((e=n(e)).length!==t.length)throw new tt("Mismatched type converter count");for(var r=0;r<t.length;++r)ct(t[r],e[r])}t.forEach((function(t){at[t]=e}));var i=Array(e.length),a=[],s=0;e.forEach(((t,e)=>{it.hasOwnProperty(t)?i[e]=it[t]:(a.push(t),rt.hasOwnProperty(t)||(rt[t]=[]),rt[t].push((()=>{i[e]=it[t],++s===a.length&&r(i)})))})),0===a.length&&r(i)},ot=t=>{for(var e="";T[t];)e+=et[T[t++]];return e},lt=t=>{throw new nt(t)};function ct(t,e,n={}){if(!("argPackAdvance"in e))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(t,e,n={}){var r=e.name;if(!t)throw new nt(`type "${r}" must have a positive integer typeid pointer`);if(it.hasOwnProperty(t)){if(n.Ua)return;throw new nt(`Cannot register type '${r}' twice`)}it[t]=e,delete at[t],rt.hasOwnProperty(t)&&(e=rt[t],delete rt[t],e.forEach((t=>t())))}(t,e,n)}var ut,ht=t=>{throw new nt(t.ia.la.ja.name+" instance already deleted")},dt=!1,pt=()=>{},ft=(t,e,n)=>e===n?t:void 0===n.oa||null===(t=ft(t,e,n.oa))?null:n.Na(t),mt={},gt=[],vt=()=>{for(;gt.length;){var t=gt.pop();t.ia.ya=!1,t.delete()}},_t={},yt=(t,e)=>{if(!e.la||!e.ka)throw new tt("makeClassHandle requires ptr and ptrType");if(!!e.qa!=!!e.na)throw new tt("Both smartPtrType and smartPtr must be specified");return e.count={value:1},xt(Object.create(t,{ia:{value:e,writable:!0}}))},xt=t=>"undefined"==typeof FinalizationRegistry?(xt=t=>t,t):(dt=new FinalizationRegistry((t=>{--(t=t.ia).count.value,0===t.count.value&&(t.na?t.qa.ra(t.na):t.la.ja.ra(t.ka))})),pt=t=>{dt.unregister(t)},(xt=t=>{var e=t.ia;return e.na&&dt.register(t,{ia:e},t),t})(t));function bt(){}var wt=(t,e)=>Object.defineProperty(e,"name",{value:t}),Mt=(t,e,n)=>{if(void 0===t[e].ma){var r=t[e];t[e]=function(...r){if(!t[e].ma.hasOwnProperty(r.length))throw new nt(`Function '${n}' called with an invalid number of arguments (${r.length}) - expects one of (${t[e].ma})!`);return t[e].ma[r.length].apply(this,r)},t[e].ma=[],t[e].ma[r.xa]=r}},Tt=(t,e,n)=>{if(l.hasOwnProperty(t)){if(void 0===n||void 0!==l[t].ma&&void 0!==l[t].ma[n])throw new nt(`Cannot register public name '${t}' twice`);if(Mt(l,t,t),l.hasOwnProperty(n))throw new nt(`Cannot register multiple overloads of a function with the same number of arguments (${n})!`);l[t].ma[n]=e}else l[t]=e,void 0!==n&&(l[t].hb=n)};function Et(t,e,n,r,i,a,s,o){this.name=t,this.constructor=e,this.ta=n,this.ra=r,this.oa=i,this.Pa=a,this.Aa=s,this.Na=o,this.Xa=[]}var St=(t,e,n)=>{for(;e!==n;){if(!e.Aa)throw new nt(`Expected null or instance of ${n.name}, got an instance of ${e.name}`);t=e.Aa(t),e=e.oa}return t};function At(t,e){if(null===e){if(this.Ga)throw new nt(`null is not a valid ${this.name}`);return 0}if(!e.ia)throw new nt(`Cannot pass "${te(e)}" as a ${this.name}`);if(!e.ia.ka)throw new nt(`Cannot pass deleted object as a pointer of type ${this.name}`);return St(e.ia.ka,e.ia.la.ja,this.ja)}function Rt(t,e){if(null===e){if(this.Ga)throw new nt(`null is not a valid ${this.name}`);if(this.Da){var n=this.Ha();return null!==t&&t.push(this.ra,n),n}return 0}if(!e||!e.ia)throw new nt(`Cannot pass "${te(e)}" as a ${this.name}`);if(!e.ia.ka)throw new nt(`Cannot pass deleted object as a pointer of type ${this.name}`);if(!this.Ca&&e.ia.la.Ca)throw new nt(`Cannot convert argument of type ${e.ia.qa?e.ia.qa.name:e.ia.la.name} to parameter type ${this.name}`);if(n=St(e.ia.ka,e.ia.la.ja,this.ja),this.Da){if(void 0===e.ia.na)throw new nt("Passing raw pointer to smart pointer is illegal");switch(this.bb){case 0:if(e.ia.qa!==this)throw new nt(`Cannot convert argument of type ${e.ia.qa?e.ia.qa.name:e.ia.la.name} to parameter type ${this.name}`);n=e.ia.na;break;case 1:n=e.ia.na;break;case 2:if(e.ia.qa===this)n=e.ia.na;else{var r=e.clone();n=this.Ya(n,Kt((()=>r.delete()))),null!==t&&t.push(this.ra,n)}break;default:throw new nt("Unsupporting sharing policy")}}return n}function Ct(t,e){if(null===e){if(this.Ga)throw new nt(`null is not a valid ${this.name}`);return 0}if(!e.ia)throw new nt(`Cannot pass "${te(e)}" as a ${this.name}`);if(!e.ia.ka)throw new nt(`Cannot pass deleted object as a pointer of type ${this.name}`);if(e.ia.la.Ca)throw new nt(`Cannot convert argument of type ${e.ia.la.name} to parameter type ${this.name}`);return St(e.ia.ka,e.ia.la.ja,this.ja)}function Pt(t,e,n,r,i,a,s,o,l,c,u){this.name=t,this.ja=e,this.Ga=n,this.Ca=r,this.Da=i,this.Wa=a,this.bb=s,this.La=o,this.Ha=l,this.Ya=c,this.ra=u,i||void 0!==e.oa?this.toWireType=Rt:(this.toWireType=r?At:Ct,this.pa=null)}var It,Lt,Dt=(t,e,n)=>{if(!l.hasOwnProperty(t))throw new tt("Replacing nonexistent public symbol");void 0!==l[t].ma&&void 0!==n?l[t].ma[n]=e:(l[t]=e,l[t].xa=n)},Ot=(t,e)=>{var n=(t=ot(t)).includes("j")?((t,e)=>(...n)=>((t,e,n=[])=>(t.includes("j")?(t=t.replace(/p/g,"i"),e=(0,l["dynCall_"+t])(e,...n)):e=It.get(e)(...n),e))(t,e,n))(t,e):It.get(e);if("function"!=typeof n)throw new nt(`unknown function pointer with signature ${t}: ${e}`);return n},Nt=t=>{t=Pe(t);var e=ot(t);return Ie(t),e},Ut=(t,e)=>{var n=[],r={};throw e.forEach((function t(e){r[e]||it[e]||(at[e]?at[e].forEach(t):(n.push(e),r[e]=!0))})),new Lt(`${t}: `+n.map(Nt).join([", "]))};function Ft(t){for(var e=1;e<t.length;++e)if(null!==t[e]&&void 0===t[e].pa)return!0;return!1}function Bt(t){var e=Function;if(!(e instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof e} which is not a function`);var n=wt(e.name||"unknownFunctionName",(function(){}));return n.prototype=e.prototype,n=new n,(t=e.apply(n,t))instanceof Object?t:n}function kt(t,e,n,r,i,a){var s=e.length;if(2>s)throw new nt("argTypes array size mismatch! Must at least get return value and 'this' types!");var o=null!==e[1]&&null!==n,l=Ft(e);for(n="void"!==e[0].name,r=[t,lt,r,i,J,e[0],e[1]],i=0;i<s-2;++i)r.push(e[i+2]);if(!l)for(i=o?1:2;i<e.length;++i)null!==e[i].pa&&r.push(e[i].pa);l=Ft(e),i=e.length;var c="",u="";for(s=0;s<i-2;++s)c+=(0!==s?", ":"")+"arg"+s,u+=(0!==s?", ":"")+"arg"+s+"Wired";c=`\n        return function (${c}) {\n        if (arguments.length !== ${i-2}) {\n          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${i-2}');\n        }`,l&&(c+="var destructors = [];\n");var h=l?"destructors":"null",d="humanName throwBindingError invoker fn runDestructors retType classParam".split(" ");for(o&&(c+="var thisWired = classParam['toWireType']("+h+", this);\n"),s=0;s<i-2;++s)c+="var arg"+s+"Wired = argType"+s+"['toWireType']("+h+", arg"+s+");\n",d.push("argType"+s);if(o&&(u="thisWired"+(0<u.length?", ":"")+u),c+=(n||a?"var rv = ":"")+"invoker(fn"+(0<u.length?", ":"")+u+");\n",l)c+="runDestructors(destructors);\n";else for(s=o?1:2;s<e.length;++s)a=1===s?"thisWired":"arg"+(s-2)+"Wired",null!==e[s].pa&&(c+=`${a}_dtor(${a});\n`,d.push(`${a}_dtor`));n&&(c+="var ret = retType['fromWireType'](rv);\nreturn ret;\n");let[p,f]=[d,c+"}\n"];return p.push(f),e=Bt(p)(...r),wt(t,e)}var zt,Ht,Gt,Vt=(t,e)=>{for(var n=[],r=0;r<t;r++)n.push(R[e+4*r>>2]);return n},Wt=t=>{const e=(t=t.trim()).indexOf("(");return-1!==e?t.substr(0,e):t},jt=(t,e,n)=>{if(!(t instanceof Object))throw new nt(`${n} with invalid "this": ${t}`);if(!(t instanceof e.ja.constructor))throw new nt(`${n} incompatible with "this" of type ${t.constructor.name}`);if(!t.ia.ka)throw new nt(`cannot call emscripten binding method ${n} on deleted object`);return St(t.ia.ka,t.ia.la.ja,e.ja)},qt=[],Xt=[],Yt=t=>{9<t&&0==--Xt[t+1]&&(Xt[t]=void 0,qt.push(t))},$t=t=>{if(!t)throw new nt("Cannot use deleted val. handle = "+t);return Xt[t]},Kt=t=>{switch(t){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:const e=qt.pop()||Xt.length;return Xt[e]=t,Xt[e+1]=1,e}},Zt={name:"emscripten::val",fromWireType:t=>{var e=$t(t);return Yt(t),e},toWireType:(t,e)=>Kt(e),argPackAdvance:8,readValueFromPointer:Q,pa:null},Jt=(t,e,n)=>{switch(e){case 1:return n?function(t){return this.fromWireType(M[t])}:function(t){return this.fromWireType(T[t])};case 2:return n?function(t){return this.fromWireType(E[t>>1])}:function(t){return this.fromWireType(S[t>>1])};case 4:return n?function(t){return this.fromWireType(A[t>>2])}:function(t){return this.fromWireType(R[t>>2])};default:throw new TypeError(`invalid integer width (${e}): ${t}`)}},Qt=(t,e)=>{var n=it[t];if(void 0===n)throw t=`${e} has unknown type ${Nt(t)}`,new nt(t);return n},te=t=>{if(null===t)return"null";var e=typeof t;return"object"===e||"array"===e||"function"===e?t.toString():""+t},ee=(t,e)=>{switch(e){case 4:return function(t){return this.fromWireType(C[t>>2])};case 8:return function(t){return this.fromWireType(P[t>>3])};default:throw new TypeError(`invalid float width (${e}): ${t}`)}},ne=(t,e,n)=>{switch(e){case 1:return n?t=>M[t]:t=>T[t];case 2:return n?t=>E[t>>1]:t=>S[t>>1];case 4:return n?t=>A[t>>2]:t=>R[t>>2];default:throw new TypeError(`invalid integer width (${e}): ${t}`)}},re=(t,e,n,r)=>{if(0<r){r=n+r-1;for(var i=0;i<t.length;++i){var a=t.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++i)),127>=a){if(n>=r)break;e[n++]=a}else{if(2047>=a){if(n+1>=r)break;e[n++]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++]=224|a>>12}else{if(n+3>=r)break;e[n++]=240|a>>18,e[n++]=128|a>>12&63}e[n++]=128|a>>6&63}e[n++]=128|63&a}}e[n]=0}},ie=t=>{for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e},ae="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,se=(t,e,n)=>{var r=e+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&ae)return ae.decode(t.subarray(e,n));for(r="";e<n;){var i=t[e++];if(128&i){var a=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|a);else{var s=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|a<<6|s:(7&i)<<18|a<<12|s<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r},oe="undefined"!=typeof TextDecoder?new TextDecoder("utf-16le"):void 0,le=(t,e)=>{for(var n=t>>1,r=n+e/2;!(n>=r)&&S[n];)++n;if(32<(n<<=1)-t&&oe)return oe.decode(T.subarray(t,n));for(n="",r=0;!(r>=e/2);++r){var i=E[t+2*r>>1];if(0==i)break;n+=String.fromCharCode(i)}return n},ce=(t,e,n)=>{if(n??=2147483647,2>n)return 0;var r=e;n=(n-=2)<2*t.length?n/2:t.length;for(var i=0;i<n;++i)E[e>>1]=t.charCodeAt(i),e+=2;return E[e>>1]=0,e-r},ue=t=>2*t.length,he=(t,e)=>{for(var n=0,r="";!(n>=e/4);){var i=A[t+4*n>>2];if(0==i)break;++n,65536<=i?(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i)):r+=String.fromCharCode(i)}return r},de=(t,e,n)=>{if(n??=2147483647,4>n)return 0;var r=e;n=r+n-4;for(var i=0;i<t.length;++i){var a=t.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++i)),A[e>>2]=a,(e+=4)+4>n)break}return A[e>>2]=0,e-r},pe=t=>{for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);55296<=r&&57343>=r&&++n,e+=4}return e},fe=(t,e,n)=>{var r=[];return t=t.toWireType(r,n),r.length&&(R[e>>2]=Kt(r)),t},me=[],ge={},ve=t=>{var e=ge[t];return void 0===e?ot(t):e},_e=()=>"object"==typeof globalThis?globalThis:Function("return this")(),ye={},xe=()=>{if(!zt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:f||"./this.program"};for(t in ye)void 0===ye[t]?delete e[t]:e[t]=ye[t];var n=[];for(t in e)n.push(`${t}=${e[t]}`);zt=n}return zt},be=[null,[],[]],we=t=>0==t%4&&(0!=t%100||0==t%400),Me=[31,29,31,30,31,30,31,31,30,31,30,31],Te=[31,28,31,30,31,30,31,31,30,31,30,31];tt=l.InternalError=class extends Error{constructor(t){super(t),this.name="InternalError"}};for(var Ee=Array(256),Se=0;256>Se;++Se)Ee[Se]=String.fromCharCode(Se);et=Ee,nt=l.BindingError=class extends Error{constructor(t){super(t),this.name="BindingError"}},Object.assign(bt.prototype,{isAliasOf:function(t){if(!(this instanceof bt&&t instanceof bt))return!1;var e=this.ia.la.ja,n=this.ia.ka;t.ia=t.ia;var r=t.ia.la.ja;for(t=t.ia.ka;e.oa;)n=e.Aa(n),e=e.oa;for(;r.oa;)t=r.Aa(t),r=r.oa;return e===r&&n===t},clone:function(){if(this.ia.ka||ht(this),this.ia.za)return this.ia.count.value+=1,this;var t=xt,e=Object,n=e.create,r=Object.getPrototypeOf(this),i=this.ia;return(t=t(n.call(e,r,{ia:{value:{count:i.count,ya:i.ya,za:i.za,ka:i.ka,la:i.la,na:i.na,qa:i.qa}}}))).ia.count.value+=1,t.ia.ya=!1,t},delete(){if(this.ia.ka||ht(this),this.ia.ya&&!this.ia.za)throw new nt("Object already scheduled for deletion");pt(this);var t=this.ia;--t.count.value,0===t.count.value&&(t.na?t.qa.ra(t.na):t.la.ja.ra(t.ka)),this.ia.za||(this.ia.na=void 0,this.ia.ka=void 0)},isDeleted:function(){return!this.ia.ka},deleteLater:function(){if(this.ia.ka||ht(this),this.ia.ya&&!this.ia.za)throw new nt("Object already scheduled for deletion");return gt.push(this),1===gt.length&&ut&&ut(vt),this.ia.ya=!0,this}}),l.getInheritedInstanceCount=()=>Object.keys(_t).length,l.getLiveInheritedInstances=()=>{var t,e=[];for(t in _t)_t.hasOwnProperty(t)&&e.push(_t[t]);return e},l.flushPendingDeletes=vt,l.setDelayFunction=t=>{ut=t,gt.length&&ut&&ut(vt)},Object.assign(Pt.prototype,{Qa(t){return this.La&&(t=this.La(t)),t},Ja(t){this.ra?.(t)},argPackAdvance:8,readValueFromPointer:Q,fromWireType:function(t){function e(){return this.Da?yt(this.ja.ta,{la:this.Wa,ka:n,qa:this,na:t}):yt(this.ja.ta,{la:this,ka:t})}var n=this.Qa(t);if(!n)return this.Ja(t),null;var r=((t,e)=>{if(void 0===e)throw new nt("ptr should not be undefined");for(;t.oa;)e=t.Aa(e),t=t.oa;return _t[e]})(this.ja,n);if(void 0!==r)return 0===r.ia.count.value?(r.ia.ka=n,r.ia.na=t,r.clone()):(r=r.clone(),this.Ja(t),r);if(r=this.ja.Pa(n),!(r=mt[r]))return e.call(this);r=this.Ca?r.Ma:r.pointerType;var i=ft(n,this.ja,r.ja);return null===i?e.call(this):this.Da?yt(r.ja.ta,{la:r,ka:i,qa:this,na:t}):yt(r.ja.ta,{la:r,ka:i})}}),Lt=l.UnboundTypeError=(Ht=Error,(Gt=wt("UnboundTypeError",(function(t){this.name="UnboundTypeError",this.message=t,void 0!==(t=Error(t).stack)&&(this.stack=this.toString()+"\n"+t.replace(/^Error(:[^\n]*)?\n/,""))}))).prototype=Object.create(Ht.prototype),Gt.prototype.constructor=Gt,Gt.prototype.toString=function(){return void 0===this.message?this.name:`${this.name}: ${this.message}`},Gt),Xt.push(0,1,void 0,1,null,1,!0,1,!1,1),l.count_emval_handles=()=>Xt.length/2-5-qt.length;var Ae,Re={D:()=>{G("")},T:t=>{var e=Z[t];delete Z[t];var n=e.Ha,r=e.ra,i=e.Ka,a=i.map((t=>t.Ta)).concat(i.map((t=>t.$a)));st([t],a,(t=>{var a={};return i.forEach(((e,n)=>{var r=t[n],s=e.Ra,o=e.Sa,l=t[n+i.length],c=e.Za,u=e.ab;a[e.Oa]={read:t=>r.fromWireType(s(o,t)),write:(t,e)=>{var n=[];c(u,t,l.toWireType(n,e)),J(n)}}})),[{name:e.name,fromWireType:t=>{var e,n={};for(e in a)n[e]=a[e].read(t);return r(t),n},toWireType:(t,e)=>{for(var i in a)if(!(i in e))throw new TypeError(`Missing field: "${i}"`);var s=n();for(i in a)a[i].write(s,e[i]);return null!==t&&t.push(r,s),s},argPackAdvance:8,readValueFromPointer:Q,pa:r}]}))},C:()=>{},O:(t,e,n,r)=>{ct(t,{name:e=ot(e),fromWireType:function(t){return!!t},toWireType:function(t,e){return e?n:r},argPackAdvance:8,readValueFromPointer:function(t){return this.fromWireType(T[t])},pa:null})},d:(t,e,n,r,i,a,s,o,l,c,u,h,d)=>{u=ot(u),a=Ot(i,a),o&&=Ot(s,o),c&&=Ot(l,c),d=Ot(h,d);var p=(t=>{if(void 0===t)return"_unknown";var e=(t=t.replace(/[^a-zA-Z0-9_]/g,"$")).charCodeAt(0);return 48<=e&&57>=e?`_${t}`:t})(u);Tt(p,(function(){Ut(`Cannot construct ${u} due to unbound types`,[r])})),st([t,e,n],r?[r]:[],(e=>{if(e=e[0],r)var n=e.ja,i=n.ta;else i=bt.prototype;e=wt(u,(function(...t){if(Object.getPrototypeOf(this)!==s)throw new nt("Use 'new' to construct "+u);if(void 0===h.ua)throw new nt(u+" has no accessible constructor");var e=h.ua[t.length];if(void 0===e)throw new nt(`Tried to invoke ctor of ${u} with invalid number of parameters (${t.length}) - expected (${Object.keys(h.ua).toString()}) parameters instead!`);return e.apply(this,t)}));var s=Object.create(i,{constructor:{value:e}});e.prototype=s;var l,h=new Et(u,e,s,d,n,a,o,c);return h.oa&&((l=h.oa).Ba??(l.Ba=[]),h.oa.Ba.push(h)),n=new Pt(u,h,!0,!1,!1),l=new Pt(u+"*",h,!1,!1,!1),i=new Pt(u+" const*",h,!1,!0,!1),mt[t]={pointerType:l,Ma:i},Dt(p,e),[n,l,i]}))},n:(t,e,n,r,i,a,s,o)=>{var l=Vt(n,r);e=ot(e),e=Wt(e),a=Ot(i,a),st([],[t],(t=>{function r(){Ut(`Cannot call ${i} due to unbound types`,l)}var i=`${(t=t[0]).name}.${e}`;e.startsWith("@@")&&(e=Symbol[e.substring(2)]);var c=t.ja.constructor;return void 0===c[e]?(r.xa=n-1,c[e]=r):(Mt(c,e,i),c[e].ma[n-1]=r),st([],l,(r=>{if(r=[r[0],null].concat(r.slice(1)),r=kt(i,r,null,a,s,o),void 0===c[e].ma?(r.xa=n-1,c[e]=r):c[e].ma[n-1]=r,t.ja.Ba)for(const n of t.ja.Ba)n.constructor.hasOwnProperty(e)||(n.constructor[e]=r);return[]})),[]}))},L:(t,e,n,r,i,a,s,o)=>{e=ot(e),a=Ot(i,a),st([],[t],(t=>{var i=`${(t=t[0]).name}.${e}`,l={get(){Ut(`Cannot access ${i} due to unbound types`,[n])},enumerable:!0,configurable:!0};return l.set=o?()=>{Ut(`Cannot access ${i} due to unbound types`,[n])}:()=>{throw new nt(`${i} is a read-only property`)},Object.defineProperty(t.ja.constructor,e,l),st([],[n],(n=>{n=n[0];var i={get:()=>n.fromWireType(a(r)),enumerable:!0};return o&&(o=Ot(s,o),i.set=t=>{var e=[];o(r,n.toWireType(e,t)),J(e)}),Object.defineProperty(t.ja.constructor,e,i),[]})),[]}))},f:(t,e,n,r,i,a)=>{var s=Vt(e,n);i=Ot(r,i),st([],[t],(t=>{var n=`constructor ${(t=t[0]).name}`;if(void 0===t.ja.ua&&(t.ja.ua=[]),void 0!==t.ja.ua[e-1])throw new nt(`Cannot register multiple constructors with identical number of parameters (${e-1}) for class '${t.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);return t.ja.ua[e-1]=()=>{Ut(`Cannot construct ${t.name} due to unbound types`,s)},st([],s,(r=>(r.splice(1,0,null),t.ja.ua[e-1]=kt(n,r,null,i,a),[]))),[]}))},a:(t,e,n,r,i,a,s,o,l)=>{var c=Vt(n,r);e=ot(e),e=Wt(e),a=Ot(i,a),st([],[t],(t=>{function r(){Ut(`Cannot call ${i} due to unbound types`,c)}var i=`${(t=t[0]).name}.${e}`;e.startsWith("@@")&&(e=Symbol[e.substring(2)]),o&&t.ja.Xa.push(e);var u=t.ja.ta,h=u[e];return void 0===h||void 0===h.ma&&h.className!==t.name&&h.xa===n-2?(r.xa=n-2,r.className=t.name,u[e]=r):(Mt(u,e,i),u[e].ma[n-2]=r),st([],c,(r=>(r=kt(i,r,t,a,s,l),void 0===u[e].ma?(r.xa=n-2,u[e]=r):u[e].ma[n-2]=r,[]))),[]}))},e:(t,e,n,r,i,a,s,o,l,c)=>{e=ot(e),i=Ot(r,i),st([],[t],(t=>{var r=`${(t=t[0]).name}.${e}`,u={get(){Ut(`Cannot access ${r} due to unbound types`,[n,s])},enumerable:!0,configurable:!0};return u.set=l?()=>Ut(`Cannot access ${r} due to unbound types`,[n,s]):()=>{throw new nt(r+" is a read-only property")},Object.defineProperty(t.ja.ta,e,u),st([],l?[n,s]:[n],(n=>{var s=n[0],u={get(){var e=jt(this,t,r+" getter");return s.fromWireType(i(a,e))},enumerable:!0};if(l){l=Ot(o,l);var h=n[1];u.set=function(e){var n=jt(this,t,r+" setter"),i=[];l(c,n,h.toWireType(i,e)),J(i)}}return Object.defineProperty(t.ja.ta,e,u),[]})),[]}))},M:t=>ct(t,Zt),m:(t,e,n,r)=>{function i(){}e=ot(e),i.values={},ct(t,{name:e,constructor:i,fromWireType:function(t){return this.constructor.values[t]},toWireType:(t,e)=>e.value,argPackAdvance:8,readValueFromPointer:Jt(e,n,r),pa:null}),Tt(e,i)},c:(t,e,n)=>{var r=Qt(t,"enum");e=ot(e),t=r.constructor,r=Object.create(r.constructor.prototype,{value:{value:n},constructor:{value:wt(`${r.name}_${e}`,(function(){}))}}),t.values[n]=r,t[e]=r},w:(t,e,n)=>{ct(t,{name:e=ot(e),fromWireType:t=>t,toWireType:(t,e)=>e,argPackAdvance:8,readValueFromPointer:ee(e,n),pa:null})},q:(t,e,n,r,i,a,s)=>{var o=Vt(e,n);t=ot(t),t=Wt(t),i=Ot(r,i),Tt(t,(function(){Ut(`Cannot call ${t} due to unbound types`,o)}),e-1),st([],o,(n=>(n=[n[0],null].concat(n.slice(1)),Dt(t,kt(t,n,null,i,a,s),e-1),[])))},s:(t,e,n,r,i)=>{if(e=ot(e),-1===i&&(i=4294967295),i=t=>t,0===r){var a=32-8*n;i=t=>t<<a>>>a}var s=e.includes("unsigned")?function(t,e){return e>>>0}:function(t,e){return e};ct(t,{name:e,fromWireType:i,toWireType:s,argPackAdvance:8,readValueFromPointer:ne(e,n,0!==r),pa:null})},o:(t,e,n)=>{function r(t){return new i(M.buffer,R[t+4>>2],R[t>>2])}var i=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][e];ct(t,{name:n=ot(n),fromWireType:r,argPackAdvance:8,readValueFromPointer:r},{Ua:!0})},k:t=>{ct(t,Zt)},l:(t,e,n,r,i,a,s,o,l,c,u,h)=>{n=ot(n),a=Ot(i,a),o=Ot(s,o),c=Ot(l,c),h=Ot(u,h),st([t],[e],(t=>(t=t[0],[new Pt(n,t.ja,!1,!1,!0,t,r,a,o,c,h)])))},x:(t,e)=>{var n="std::string"===(e=ot(e));ct(t,{name:e,fromWireType:function(t){var e=R[t>>2],r=t+4;if(n)for(var i=r,a=0;a<=e;++a){var s=r+a;if(a==e||0==T[s]){if(i=i?se(T,i,s-i):"",void 0===o)var o=i;else o+=String.fromCharCode(0),o+=i;i=s+1}}else{for(o=Array(e),a=0;a<e;++a)o[a]=String.fromCharCode(T[r+a]);o=o.join("")}return Ie(t),o},toWireType:function(t,e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var r="string"==typeof e;if(!(r||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Int8Array))throw new nt("Cannot pass non-string to std::string");var i=n&&r?ie(e):e.length,a=Le(4+i+1),s=a+4;if(R[a>>2]=i,n&&r)re(e,T,s,i+1);else if(r)for(r=0;r<i;++r){var o=e.charCodeAt(r);if(255<o)throw Ie(s),new nt("String has UTF-16 code units that do not fit in 8 bits");T[s+r]=o}else for(r=0;r<i;++r)T[s+r]=e[r];return null!==t&&t.push(Ie,a),a},argPackAdvance:8,readValueFromPointer:Q,pa(t){Ie(t)}})},u:(t,e,n)=>{if(n=ot(n),2===e)var r=le,i=ce,a=ue,s=t=>S[t>>1];else 4===e&&(r=he,i=de,a=pe,s=t=>R[t>>2]);ct(t,{name:n,fromWireType:t=>{for(var n,i=R[t>>2],a=t+4,o=0;o<=i;++o){var l=t+4+o*e;o!=i&&0!=s(l)||(a=r(a,l-a),void 0===n?n=a:(n+=String.fromCharCode(0),n+=a),a=l+e)}return Ie(t),n},toWireType:(t,r)=>{if("string"!=typeof r)throw new nt(`Cannot pass non-string to C++ string type ${n}`);var s=a(r),o=Le(4+s+e);return R[o>>2]=s/e,i(r,o+4,s+e),null!==t&&t.push(Ie,o),o},argPackAdvance:8,readValueFromPointer:Q,pa(t){Ie(t)}})},i:(t,e,n,r,i,a)=>{Z[t]={name:ot(e),Ha:Ot(n,r),ra:Ot(i,a),Ka:[]}},b:(t,e,n,r,i,a,s,o,l,c)=>{Z[t].Ka.push({Oa:ot(e),Ta:n,Ra:Ot(r,i),Sa:a,$a:s,Za:Ot(o,l),ab:c})},P:(t,e)=>{ct(t,{Va:!0,name:e=ot(e),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},t:(t,e,n)=>(t=$t(t),e=Qt(e,"emval::as"),fe(e,n,t)),y:(t,e,n,r)=>(t=me[t])(null,e=$t(e),n,r),h:(t,e,n,r,i)=>(t=me[t])(e=$t(e),e[n=ve(n)],r,i),V:Yt,N:t=>0===t?Kt(_e()):(t=ve(t),Kt(_e()[t])),g:(t,e,n)=>{e=((t,e)=>{for(var n=Array(t),r=0;r<t;++r)n[r]=Qt(R[e+4*r>>2],"parameter "+r);return n})(t,e);var r=e.shift();t--;var i="return function (obj, func, destructorsRef, args) {\n",a=0,s=[];0===n&&s.push("obj");for(var o=["retType"],l=[r],c=0;c<t;++c)s.push("arg"+c),o.push("argType"+c),l.push(e[c]),i+=`  var arg${c} = argType${c}.readValueFromPointer(args${a?"+"+a:""});\n`,a+=e[c].argPackAdvance;return i+=`  var rv = ${1===n?"new func":"func.call"}(${s.join(", ")});\n`,r.Va||(o.push("emval_returnValue"),l.push(fe),i+="  return emval_returnValue(retType, destructorsRef, rv);\n"),o.push(i+"};\n"),t=Bt(o)(...l),n=`methodCaller<(${e.map((t=>t.name)).join(", ")}) => ${r.name}>`,(t=>{var e=me.length;return me.push(t),e})(wt(n,t))},Q:t=>(t=ve(t),Kt(l[t])),r:(t,e)=>(t=$t(t),e=$t(e),Kt(t[e])),v:t=>{9<t&&(Xt[t+1]+=1)},R:(t,e)=>(t=$t(t))instanceof $t(e),W:()=>Kt([]),z:t=>Kt(ve(t)),S:()=>Kt({}),A:t=>{var e=$t(t);J(e),Yt(t)},p:(t,e,n)=>{t=$t(t),e=$t(e),n=$t(n),t[e]=n},U:(t,e)=>(t=$t(t))===$t(e),j:(t,e)=>(t=(t=Qt(t,"_emval_take_value")).readValueFromPointer(e),Kt(t)),F:t=>{var e=T.length;if(2147483648<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var i=Math;r=Math.max(t,r);t:{i=(i.min.call(i,2147483648,r+(65536-r%65536)%65536)-w.buffer.byteLength+65535)/65536;try{w.grow(i),L();var a=1;break t}catch(t){}a=void 0}if(a)return!0}return!1},G:(t,e)=>{var n=0;return xe().forEach(((r,i)=>{var a=e+n;for(i=R[t+4*i>>2]=a,a=0;a<r.length;++a)M[i++]=r.charCodeAt(a);M[i]=0,n+=r.length+1})),0},H:(t,e)=>{var n=xe();R[t>>2]=n.length;var r=0;return n.forEach((t=>r+=t.length+1)),R[e>>2]=r,0},I:()=>52,K:()=>52,B:function(){return 70},J:(t,e,n,r)=>{for(var i=0,a=0;a<n;a++){var s=R[e>>2],o=R[e+4>>2];e+=8;for(var l=0;l<o;l++){var c=T[s+l],u=be[t];0===c||10===c?((1===t?x:b)(se(u,0)),u.length=0):u.push(c)}i+=o}return R[r>>2]=i,0},E:(t,e,n,r)=>((t,e,n,r)=>{function i(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function a(t,e){return i(t,e,"0")}function s(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function o(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.va;for(t=new Date(new Date(t.wa+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(we(t.getFullYear())?Me:Te)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=o(new Date(t.getFullYear(),0,4)),n=o(n),0>=s(e,t)?0>=s(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=R[r+40>>2];for(var u in r={fb:A[r>>2],eb:A[r+4>>2],Ea:A[r+8>>2],Ia:A[r+12>>2],Fa:A[r+16>>2],wa:A[r+20>>2],sa:A[r+24>>2],va:A[r+28>>2],ib:A[r+32>>2],cb:A[r+36>>2],gb:c&&c?se(T,c):""},n=n?se(T,n):"",c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(u,"g"),c[u]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(u in c={"%a":t=>h[t.sa].substring(0,3),"%A":t=>h[t.sa],"%b":t=>d[t.Fa].substring(0,3),"%B":t=>d[t.Fa],"%C":t=>a((t.wa+1900)/100|0,2),"%d":t=>a(t.Ia,2),"%e":t=>i(t.Ia,2," "),"%g":t=>l(t).toString().substring(2),"%G":l,"%H":t=>a(t.Ea,2),"%I":t=>(0==(t=t.Ea)?t=12:12<t&&(t-=12),a(t,2)),"%j":t=>{for(var e=0,n=0;n<=t.Fa-1;e+=(we(t.wa+1900)?Me:Te)[n++]);return a(t.Ia+e,3)},"%m":t=>a(t.Fa+1,2),"%M":t=>a(t.eb,2),"%n":()=>"\n","%p":t=>0<=t.Ea&&12>t.Ea?"AM":"PM","%S":t=>a(t.fb,2),"%t":()=>"\t","%u":t=>t.sa||7,"%U":t=>a(Math.floor((t.va+7-t.sa)/7),2),"%V":t=>{var e=Math.floor((t.va+7-(t.sa+6)%7)/7);if(2>=(t.sa+371-t.va-2)%7&&e++,e)53==e&&(4==(n=(t.sa+371-t.va)%7)||3==n&&we(t.wa)||(e=1));else{e=52;var n=(t.sa+7-t.va-1)%7;(4==n||5==n&&we(t.wa%400-1))&&e++}return a(e,2)},"%w":t=>t.sa,"%W":t=>a(Math.floor((t.va+7-(t.sa+6)%7)/7),2),"%y":t=>(t.wa+1900).toString().substring(2),"%Y":t=>t.wa+1900,"%z":t=>{var e=0<=(t=t.cb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":t=>t.gb,"%%":()=>"%"},n=n.replace(/%%/g,"\0\0"),c)n.includes(u)&&(n=n.replace(new RegExp(u,"g"),c[u](r)));return u=function(t){var e=Array(ie(t)+1);return re(t,e,0,e.length),e}(n=n.replace(/\0\0/g,"%")),u.length>e?0:(M.set(u,t),u.length-1)})(t,e,n,r)},Ce=function(){function t(t){return Ce=t.exports,w=Ce.X,L(),It=Ce.ba,O.unshift(Ce.Y),k--,l.monitorRunDependencies?.(k),0==k&&(null!==z&&(clearInterval(z),z=null),H&&(t=H,H=null,t())),Ce}var e={a:Re};if(k++,l.monitorRunDependencies?.(k),l.instantiateWasm)try{return l.instantiateWasm(e,t)}catch(t){b(`Module.instantiateWasm callback failed with error: ${t}`),i(t)}return V||=W("RoomleCore.wasm")?"RoomleCore.wasm":l.locateFile?l.locateFile("RoomleCore.wasm",g):g+"RoomleCore.wasm",function(t,e){var n=V;return y||"function"!=typeof WebAssembly.instantiateStreaming||W(n)||d||"function"!=typeof fetch?X(n,t,e):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,t).then(e,(function(r){return b(`wasm streaming compile failed: ${r}`),b("falling back to ArrayBuffer instantiation"),X(n,t,e)}))))}(e,(function(e){t(e.instance)})).catch(i),{}}(),Pe=t=>(Pe=Ce.Z)(t),Ie=t=>(Ie=Ce._)(t),Le=t=>(Le=Ce.$)(t),De=l._main=(t,e)=>(De=l._main=Ce.aa)(t,e),Oe=()=>(Oe=Ce.ca)();function Ne(){function t(){if(!Ae&&(Ae=!0,l.calledRun=!0,!I)){if(F=!0,$(O),$(N),e(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),Ue){var t=De;try{var n=t(0,0);K||(l.onExit?.(n),I=!0),m(n,new Y(n))}catch(t){t instanceof Y||"unwind"==t||m(1,t)}}if(l.postRun)for("function"==typeof l.postRun&&(l.postRun=[l.postRun]);l.postRun.length;)t=l.postRun.shift(),U.unshift(t);$(U)}}if(!(0<k)){if(l.preRun)for("function"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)B();$(D),0<k||(l.setStatus?(l.setStatus("Running..."),setTimeout((function(){setTimeout((function(){l.setStatus("")}),1),t()}),1)):t())}}if(l.dynCall_viijii=(t,e,n,r,i,a,s)=>(l.dynCall_viijii=Ce.da)(t,e,n,r,i,a,s),l.dynCall_jiji=(t,e,n,r,i)=>(l.dynCall_jiji=Ce.ea)(t,e,n,r,i),l.dynCall_iiiiij=(t,e,n,r,i,a,s)=>(l.dynCall_iiiiij=Ce.fa)(t,e,n,r,i,a,s),l.dynCall_iiiiijj=(t,e,n,r,i,a,s,o,c)=>(l.dynCall_iiiiijj=Ce.ga)(t,e,n,r,i,a,s,o,c),l.dynCall_iiiiiijj=(t,e,n,r,i,a,s,o,c,u)=>(l.dynCall_iiiiiijj=Ce.ha)(t,e,n,r,i,a,s,o,c,u),H=function t(){Ae||Ne(),Ae||(H=t)},l.preInit)for("function"==typeof l.preInit&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();var Ue=!0;return l.noInitialRun&&(Ue=!1),Ne(),c});t.exports=i},918:()=>{},702:()=>{},425:(t,e,n)=>{"use strict";function r(t,e){return function(){return t.apply(e,arguments)}}const{toString:i}=Object.prototype,{getPrototypeOf:a}=Object,s=(o=Object.create(null),t=>{const e=i.call(t);return o[e]||(o[e]=e.slice(8,-1).toLowerCase())});var o;const l=t=>(t=t.toLowerCase(),e=>s(e)===t),c=t=>e=>typeof e===t,{isArray:u}=Array,h=c("undefined"),d=l("ArrayBuffer"),p=c("string"),f=c("function"),m=c("number"),g=t=>null!==t&&"object"==typeof t,v=t=>{if("object"!==s(t))return!1;const e=a(t);return!(null!==e&&e!==Object.prototype&&null!==Object.getPrototypeOf(e)||Symbol.toStringTag in t||Symbol.iterator in t)},_=l("Date"),y=l("File"),x=l("Blob"),b=l("FileList"),w=l("URLSearchParams"),[M,T,E,S]=["ReadableStream","Request","Response","Headers"].map(l);function A(t,e,{allOwnKeys:n=!1}={}){if(null==t)return;let r,i;if("object"!=typeof t&&(t=[t]),u(t))for(r=0,i=t.length;r<i;r++)e.call(null,t[r],r,t);else{const i=n?Object.getOwnPropertyNames(t):Object.keys(t),a=i.length;let s;for(r=0;r<a;r++)s=i[r],e.call(null,t[s],s,t)}}function R(t,e){e=e.toLowerCase();const n=Object.keys(t);let r,i=n.length;for(;i-- >0;)if(r=n[i],e===r.toLowerCase())return r;return null}const C="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:n.g,P=t=>!h(t)&&t!==C,I=(L="undefined"!=typeof Uint8Array&&a(Uint8Array),t=>L&&t instanceof L);var L;const D=l("HTMLFormElement"),O=(({hasOwnProperty:t})=>(e,n)=>t.call(e,n))(Object.prototype),N=l("RegExp"),U=(t,e)=>{const n=Object.getOwnPropertyDescriptors(t),r={};A(n,((n,i)=>{let a;!1!==(a=e(n,i,t))&&(r[i]=a||n)})),Object.defineProperties(t,r)},F="abcdefghijklmnopqrstuvwxyz",B="0123456789",k={DIGIT:B,ALPHA:F,ALPHA_DIGIT:F+F.toUpperCase()+B},z=l("AsyncFunction"),H=(G="function"==typeof setImmediate,V=f(C.postMessage),G?setImmediate:V?(W=`axios@${Math.random()}`,j=[],C.addEventListener("message",(({source:t,data:e})=>{t===C&&e===W&&j.length&&j.shift()()}),!1),t=>{j.push(t),C.postMessage(W,"*")}):t=>setTimeout(t));var G,V,W,j;const q="undefined"!=typeof queueMicrotask?queueMicrotask.bind(C):"undefined"!=typeof process&&process.nextTick||H;var X={isArray:u,isArrayBuffer:d,isBuffer:function(t){return null!==t&&!h(t)&&null!==t.constructor&&!h(t.constructor)&&f(t.constructor.isBuffer)&&t.constructor.isBuffer(t)},isFormData:t=>{let e;return t&&("function"==typeof FormData&&t instanceof FormData||f(t.append)&&("formdata"===(e=s(t))||"object"===e&&f(t.toString)&&"[object FormData]"===t.toString()))},isArrayBufferView:function(t){let e;return e="undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(t):t&&t.buffer&&d(t.buffer),e},isString:p,isNumber:m,isBoolean:t=>!0===t||!1===t,isObject:g,isPlainObject:v,isReadableStream:M,isRequest:T,isResponse:E,isHeaders:S,isUndefined:h,isDate:_,isFile:y,isBlob:x,isRegExp:N,isFunction:f,isStream:t=>g(t)&&f(t.pipe),isURLSearchParams:w,isTypedArray:I,isFileList:b,forEach:A,merge:function t(){const{caseless:e}=P(this)&&this||{},n={},r=(r,i)=>{const a=e&&R(n,i)||i;v(n[a])&&v(r)?n[a]=t(n[a],r):v(r)?n[a]=t({},r):u(r)?n[a]=r.slice():n[a]=r};for(let t=0,e=arguments.length;t<e;t++)arguments[t]&&A(arguments[t],r);return n},extend:(t,e,n,{allOwnKeys:i}={})=>(A(e,((e,i)=>{n&&f(e)?t[i]=r(e,n):t[i]=e}),{allOwnKeys:i}),t),trim:t=>t.trim?t.trim():t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:t=>(65279===t.charCodeAt(0)&&(t=t.slice(1)),t),inherits:(t,e,n,r)=>{t.prototype=Object.create(e.prototype,r),t.prototype.constructor=t,Object.defineProperty(t,"super",{value:e.prototype}),n&&Object.assign(t.prototype,n)},toFlatObject:(t,e,n,r)=>{let i,s,o;const l={};if(e=e||{},null==t)return e;do{for(i=Object.getOwnPropertyNames(t),s=i.length;s-- >0;)o=i[s],r&&!r(o,t,e)||l[o]||(e[o]=t[o],l[o]=!0);t=!1!==n&&a(t)}while(t&&(!n||n(t,e))&&t!==Object.prototype);return e},kindOf:s,kindOfTest:l,endsWith:(t,e,n)=>{t=String(t),(void 0===n||n>t.length)&&(n=t.length),n-=e.length;const r=t.indexOf(e,n);return-1!==r&&r===n},toArray:t=>{if(!t)return null;if(u(t))return t;let e=t.length;if(!m(e))return null;const n=new Array(e);for(;e-- >0;)n[e]=t[e];return n},forEachEntry:(t,e)=>{const n=(t&&t[Symbol.iterator]).call(t);let r;for(;(r=n.next())&&!r.done;){const n=r.value;e.call(t,n[0],n[1])}},matchAll:(t,e)=>{let n;const r=[];for(;null!==(n=t.exec(e));)r.push(n);return r},isHTMLForm:D,hasOwnProperty:O,hasOwnProp:O,reduceDescriptors:U,freezeMethods:t=>{U(t,((e,n)=>{if(f(t)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=t[n];f(r)&&(e.enumerable=!1,"writable"in e?e.writable=!1:e.set||(e.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:(t,e)=>{const n={},r=t=>{t.forEach((t=>{n[t]=!0}))};return u(t)?r(t):r(String(t).split(e)),n},toCamelCase:t=>t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(t,e,n){return e.toUpperCase()+n})),noop:()=>{},toFiniteNumber:(t,e)=>null!=t&&Number.isFinite(t=+t)?t:e,findKey:R,global:C,isContextDefined:P,ALPHABET:k,generateString:(t=16,e=k.ALPHA_DIGIT)=>{let n="";const{length:r}=e;for(;t--;)n+=e[Math.random()*r|0];return n},isSpecCompliantForm:function(t){return!!(t&&f(t.append)&&"FormData"===t[Symbol.toStringTag]&&t[Symbol.iterator])},toJSONObject:t=>{const e=new Array(10),n=(t,r)=>{if(g(t)){if(e.indexOf(t)>=0)return;if(!("toJSON"in t)){e[r]=t;const i=u(t)?[]:{};return A(t,((t,e)=>{const a=n(t,r+1);!h(a)&&(i[e]=a)})),e[r]=void 0,i}}return t};return n(t,0)},isAsyncFn:z,isThenable:t=>t&&(g(t)||f(t))&&f(t.then)&&f(t.catch),setImmediate:H,asap:q};function Y(t,e,n,r,i){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=t,this.name="AxiosError",e&&(this.code=e),n&&(this.config=n),r&&(this.request=r),i&&(this.response=i,this.status=i.status?i.status:null)}X.inherits(Y,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:X.toJSONObject(this.config),code:this.code,status:this.status}}});const $=Y.prototype,K={};function Z(t){return X.isPlainObject(t)||X.isArray(t)}function J(t){return X.endsWith(t,"[]")?t.slice(0,-2):t}function Q(t,e,n){return t?t.concat(e).map((function(t,e){return t=J(t),!n&&e?"["+t+"]":t})).join(n?".":""):e}["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((t=>{K[t]={value:t}})),Object.defineProperties(Y,K),Object.defineProperty($,"isAxiosError",{value:!0}),Y.from=(t,e,n,r,i,a)=>{const s=Object.create($);return X.toFlatObject(t,s,(function(t){return t!==Error.prototype}),(t=>"isAxiosError"!==t)),Y.call(s,t.message,e,n,r,i),s.cause=t,s.name=t.name,a&&Object.assign(s,a),s};const tt=X.toFlatObject(X,{},null,(function(t){return/^is[A-Z]/.test(t)}));function et(t,e,n){if(!X.isObject(t))throw new TypeError("target must be an object");e=e||new FormData;const r=(n=X.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(t,e){return!X.isUndefined(e[t])}))).metaTokens,i=n.visitor||c,a=n.dots,s=n.indexes,o=(n.Blob||"undefined"!=typeof Blob&&Blob)&&X.isSpecCompliantForm(e);if(!X.isFunction(i))throw new TypeError("visitor must be a function");function l(t){if(null===t)return"";if(X.isDate(t))return t.toISOString();if(!o&&X.isBlob(t))throw new Y("Blob is not supported. Use a Buffer instead.");return X.isArrayBuffer(t)||X.isTypedArray(t)?o&&"function"==typeof Blob?new Blob([t]):Buffer.from(t):t}function c(t,n,i){let o=t;if(t&&!i&&"object"==typeof t)if(X.endsWith(n,"{}"))n=r?n:n.slice(0,-2),t=JSON.stringify(t);else if(X.isArray(t)&&function(t){return X.isArray(t)&&!t.some(Z)}(t)||(X.isFileList(t)||X.endsWith(n,"[]"))&&(o=X.toArray(t)))return n=J(n),o.forEach((function(t,r){!X.isUndefined(t)&&null!==t&&e.append(!0===s?Q([n],r,a):null===s?n:n+"[]",l(t))})),!1;return!!Z(t)||(e.append(Q(i,n,a),l(t)),!1)}const u=[],h=Object.assign(tt,{defaultVisitor:c,convertValue:l,isVisitable:Z});if(!X.isObject(t))throw new TypeError("data must be an object");return function t(n,r){if(!X.isUndefined(n)){if(-1!==u.indexOf(n))throw Error("Circular reference detected in "+r.join("."));u.push(n),X.forEach(n,(function(n,a){!0===(!(X.isUndefined(n)||null===n)&&i.call(e,n,X.isString(a)?a.trim():a,r,h))&&t(n,r?r.concat(a):[a])})),u.pop()}}(t),e}function nt(t){const e={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g,(function(t){return e[t]}))}function rt(t,e){this._pairs=[],t&&et(t,this,e)}const it=rt.prototype;function at(t){return encodeURIComponent(t).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function st(t,e,n){if(!e)return t;const r=n&&n.encode||at,i=n&&n.serialize;let a;if(a=i?i(e,n):X.isURLSearchParams(e)?e.toString():new rt(e,n).toString(r),a){const e=t.indexOf("#");-1!==e&&(t=t.slice(0,e)),t+=(-1===t.indexOf("?")?"?":"&")+a}return t}it.append=function(t,e){this._pairs.push([t,e])},it.toString=function(t){const e=t?function(e){return t.call(this,e,nt)}:nt;return this._pairs.map((function(t){return e(t[0])+"="+e(t[1])}),"").join("&")};var ot=class{constructor(){this.handlers=[]}use(t,e,n){return this.handlers.push({fulfilled:t,rejected:e,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(t){this.handlers[t]&&(this.handlers[t]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(t){X.forEach(this.handlers,(function(e){null!==e&&t(e)}))}},lt={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},ct={isBrowser:!0,classes:{URLSearchParams:"undefined"!=typeof URLSearchParams?URLSearchParams:rt,FormData:"undefined"!=typeof FormData?FormData:null,Blob:"undefined"!=typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]};const ut="undefined"!=typeof window&&"undefined"!=typeof document,ht="object"==typeof navigator&&navigator||void 0,dt=ut&&(!ht||["ReactNative","NativeScript","NS"].indexOf(ht.product)<0),pt="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"==typeof self.importScripts,ft=ut&&window.location.href||"http://localhost";var mt={...Object.freeze({__proto__:null,hasBrowserEnv:ut,hasStandardBrowserWebWorkerEnv:pt,hasStandardBrowserEnv:dt,navigator:ht,origin:ft}),...ct};function gt(t){function e(t,n,r,i){let a=t[i++];if("__proto__"===a)return!0;const s=Number.isFinite(+a),o=i>=t.length;return a=!a&&X.isArray(r)?r.length:a,o?(X.hasOwnProp(r,a)?r[a]=[r[a],n]:r[a]=n,!s):(r[a]&&X.isObject(r[a])||(r[a]=[]),e(t,n,r[a],i)&&X.isArray(r[a])&&(r[a]=function(t){const e={},n=Object.keys(t);let r;const i=n.length;let a;for(r=0;r<i;r++)a=n[r],e[a]=t[a];return e}(r[a])),!s)}if(X.isFormData(t)&&X.isFunction(t.entries)){const n={};return X.forEachEntry(t,((t,r)=>{e(function(t){return X.matchAll(/\w+|\[(\w*)]/g,t).map((t=>"[]"===t[0]?"":t[1]||t[0]))}(t),r,n,0)})),n}return null}const vt={transitional:lt,adapter:["xhr","http","fetch"],transformRequest:[function(t,e){const n=e.getContentType()||"",r=n.indexOf("application/json")>-1,i=X.isObject(t);if(i&&X.isHTMLForm(t)&&(t=new FormData(t)),X.isFormData(t))return r?JSON.stringify(gt(t)):t;if(X.isArrayBuffer(t)||X.isBuffer(t)||X.isStream(t)||X.isFile(t)||X.isBlob(t)||X.isReadableStream(t))return t;if(X.isArrayBufferView(t))return t.buffer;if(X.isURLSearchParams(t))return e.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),t.toString();let a;if(i){if(n.indexOf("application/x-www-form-urlencoded")>-1)return function(t,e){return et(t,new mt.classes.URLSearchParams,Object.assign({visitor:function(t,e,n,r){return mt.isNode&&X.isBuffer(t)?(this.append(e,t.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},e))}(t,this.formSerializer).toString();if((a=X.isFileList(t))||n.indexOf("multipart/form-data")>-1){const e=this.env&&this.env.FormData;return et(a?{"files[]":t}:t,e&&new e,this.formSerializer)}}return i||r?(e.setContentType("application/json",!1),function(t){if(X.isString(t))try{return(0,JSON.parse)(t),X.trim(t)}catch(t){if("SyntaxError"!==t.name)throw t}return(0,JSON.stringify)(t)}(t)):t}],transformResponse:[function(t){const e=this.transitional||vt.transitional,n=e&&e.forcedJSONParsing,r="json"===this.responseType;if(X.isResponse(t)||X.isReadableStream(t))return t;if(t&&X.isString(t)&&(n&&!this.responseType||r)){const n=!(e&&e.silentJSONParsing)&&r;try{return JSON.parse(t)}catch(t){if(n){if("SyntaxError"===t.name)throw Y.from(t,Y.ERR_BAD_RESPONSE,this,null,this.response);throw t}}}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:mt.classes.FormData,Blob:mt.classes.Blob},validateStatus:function(t){return t>=200&&t<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};X.forEach(["delete","get","head","post","put","patch"],(t=>{vt.headers[t]={}}));var _t=vt;const yt=X.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),xt=Symbol("internals");function bt(t){return t&&String(t).trim().toLowerCase()}function wt(t){return!1===t||null==t?t:X.isArray(t)?t.map(wt):String(t)}function Mt(t,e,n,r,i){return X.isFunction(r)?r.call(this,e,n):(i&&(e=n),X.isString(e)?X.isString(r)?-1!==e.indexOf(r):X.isRegExp(r)?r.test(e):void 0:void 0)}class Tt{constructor(t){t&&this.set(t)}set(t,e,n){const r=this;function i(t,e,n){const i=bt(e);if(!i)throw new Error("header name must be a non-empty string");const a=X.findKey(r,i);(!a||void 0===r[a]||!0===n||void 0===n&&!1!==r[a])&&(r[a||e]=wt(t))}const a=(t,e)=>X.forEach(t,((t,n)=>i(t,n,e)));if(X.isPlainObject(t)||t instanceof this.constructor)a(t,e);else if(X.isString(t)&&(t=t.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()))a((t=>{const e={};let n,r,i;return t&&t.split("\n").forEach((function(t){i=t.indexOf(":"),n=t.substring(0,i).trim().toLowerCase(),r=t.substring(i+1).trim(),!n||e[n]&&yt[n]||("set-cookie"===n?e[n]?e[n].push(r):e[n]=[r]:e[n]=e[n]?e[n]+", "+r:r)})),e})(t),e);else if(X.isHeaders(t))for(const[e,r]of t.entries())i(r,e,n);else null!=t&&i(e,t,n);return this}get(t,e){if(t=bt(t)){const n=X.findKey(this,t);if(n){const t=this[n];if(!e)return t;if(!0===e)return function(t){const e=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(t);)e[r[1]]=r[2];return e}(t);if(X.isFunction(e))return e.call(this,t,n);if(X.isRegExp(e))return e.exec(t);throw new TypeError("parser must be boolean|regexp|function")}}}has(t,e){if(t=bt(t)){const n=X.findKey(this,t);return!(!n||void 0===this[n]||e&&!Mt(0,this[n],n,e))}return!1}delete(t,e){const n=this;let r=!1;function i(t){if(t=bt(t)){const i=X.findKey(n,t);!i||e&&!Mt(0,n[i],i,e)||(delete n[i],r=!0)}}return X.isArray(t)?t.forEach(i):i(t),r}clear(t){const e=Object.keys(this);let n=e.length,r=!1;for(;n--;){const i=e[n];t&&!Mt(0,this[i],i,t,!0)||(delete this[i],r=!0)}return r}normalize(t){const e=this,n={};return X.forEach(this,((r,i)=>{const a=X.findKey(n,i);if(a)return e[a]=wt(r),void delete e[i];const s=t?function(t){return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((t,e,n)=>e.toUpperCase()+n))}(i):String(i).trim();s!==i&&delete e[i],e[s]=wt(r),n[s]=!0})),this}concat(...t){return this.constructor.concat(this,...t)}toJSON(t){const e=Object.create(null);return X.forEach(this,((n,r)=>{null!=n&&!1!==n&&(e[r]=t&&X.isArray(n)?n.join(", "):n)})),e}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((([t,e])=>t+": "+e)).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(t){return t instanceof this?t:new this(t)}static concat(t,...e){const n=new this(t);return e.forEach((t=>n.set(t))),n}static accessor(t){const e=(this[xt]=this[xt]={accessors:{}}).accessors,n=this.prototype;function r(t){const r=bt(t);e[r]||(function(t,e){const n=X.toCamelCase(" "+e);["get","set","has"].forEach((r=>{Object.defineProperty(t,r+n,{value:function(t,n,i){return this[r].call(this,e,t,n,i)},configurable:!0})}))}(n,t),e[r]=!0)}return X.isArray(t)?t.forEach(r):r(t),this}}Tt.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),X.reduceDescriptors(Tt.prototype,(({value:t},e)=>{let n=e[0].toUpperCase()+e.slice(1);return{get:()=>t,set(t){this[n]=t}}})),X.freezeMethods(Tt);var Et=Tt;function St(t,e){const n=this||_t,r=e||n,i=Et.from(r.headers);let a=r.data;return X.forEach(t,(function(t){a=t.call(n,a,i.normalize(),e?e.status:void 0)})),i.normalize(),a}function At(t){return!(!t||!t.__CANCEL__)}function Rt(t,e,n){Y.call(this,null==t?"canceled":t,Y.ERR_CANCELED,e,n),this.name="CanceledError"}function Ct(t,e,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?e(new Y("Request failed with status code "+n.status,[Y.ERR_BAD_REQUEST,Y.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):t(n)}X.inherits(Rt,Y,{__CANCEL__:!0});const Pt=(t,e,n=3)=>{let r=0;const i=function(t,e){t=t||10;const n=new Array(t),r=new Array(t);let i,a=0,s=0;return e=void 0!==e?e:1e3,function(o){const l=Date.now(),c=r[s];i||(i=l),n[a]=o,r[a]=l;let u=s,h=0;for(;u!==a;)h+=n[u++],u%=t;if(a=(a+1)%t,a===s&&(s=(s+1)%t),l-i<e)return;const d=c&&l-c;return d?Math.round(1e3*h/d):void 0}}(50,250);return function(t,e){let n,r,i=0,a=1e3/e;const s=(e,a=Date.now())=>{i=a,n=null,r&&(clearTimeout(r),r=null),t.apply(null,e)};return[(...t)=>{const e=Date.now(),o=e-i;o>=a?s(t,e):(n=t,r||(r=setTimeout((()=>{r=null,s(n)}),a-o)))},()=>n&&s(n)]}((n=>{const a=n.loaded,s=n.lengthComputable?n.total:void 0,o=a-r,l=i(o);r=a,t({loaded:a,total:s,progress:s?a/s:void 0,bytes:o,rate:l||void 0,estimated:l&&s&&a<=s?(s-a)/l:void 0,event:n,lengthComputable:null!=s,[e?"download":"upload"]:!0})}),n)},It=(t,e)=>{const n=null!=t;return[r=>e[0]({lengthComputable:n,total:t,loaded:r}),e[1]]},Lt=t=>(...e)=>X.asap((()=>t(...e)));var Dt=mt.hasStandardBrowserEnv?function(){const t=mt.navigator&&/(msie|trident)/i.test(mt.navigator.userAgent),e=document.createElement("a");let n;function r(n){let r=n;return t&&(e.setAttribute("href",r),r=e.href),e.setAttribute("href",r),{href:e.href,protocol:e.protocol?e.protocol.replace(/:$/,""):"",host:e.host,search:e.search?e.search.replace(/^\?/,""):"",hash:e.hash?e.hash.replace(/^#/,""):"",hostname:e.hostname,port:e.port,pathname:"/"===e.pathname.charAt(0)?e.pathname:"/"+e.pathname}}return n=r(window.location.href),function(t){const e=X.isString(t)?r(t):t;return e.protocol===n.protocol&&e.host===n.host}}():function(){return!0},Ot=mt.hasStandardBrowserEnv?{write(t,e,n,r,i,a){const s=[t+"="+encodeURIComponent(e)];X.isNumber(n)&&s.push("expires="+new Date(n).toGMTString()),X.isString(r)&&s.push("path="+r),X.isString(i)&&s.push("domain="+i),!0===a&&s.push("secure"),document.cookie=s.join("; ")},read(t){const e=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove(t){this.write(t,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function Nt(t,e){return t&&!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)?function(t,e){return e?t.replace(/\/?\/$/,"")+"/"+e.replace(/^\/+/,""):t}(t,e):e}const Ut=t=>t instanceof Et?{...t}:t;function Ft(t,e){e=e||{};const n={};function r(t,e,n){return X.isPlainObject(t)&&X.isPlainObject(e)?X.merge.call({caseless:n},t,e):X.isPlainObject(e)?X.merge({},e):X.isArray(e)?e.slice():e}function i(t,e,n){return X.isUndefined(e)?X.isUndefined(t)?void 0:r(void 0,t,n):r(t,e,n)}function a(t,e){if(!X.isUndefined(e))return r(void 0,e)}function s(t,e){return X.isUndefined(e)?X.isUndefined(t)?void 0:r(void 0,t):r(void 0,e)}function o(n,i,a){return a in e?r(n,i):a in t?r(void 0,n):void 0}const l={url:a,method:a,data:a,baseURL:s,transformRequest:s,transformResponse:s,paramsSerializer:s,timeout:s,timeoutMessage:s,withCredentials:s,withXSRFToken:s,adapter:s,responseType:s,xsrfCookieName:s,xsrfHeaderName:s,onUploadProgress:s,onDownloadProgress:s,decompress:s,maxContentLength:s,maxBodyLength:s,beforeRedirect:s,transport:s,httpAgent:s,httpsAgent:s,cancelToken:s,socketPath:s,responseEncoding:s,validateStatus:o,headers:(t,e)=>i(Ut(t),Ut(e),!0)};return X.forEach(Object.keys(Object.assign({},t,e)),(function(r){const a=l[r]||i,s=a(t[r],e[r],r);X.isUndefined(s)&&a!==o||(n[r]=s)})),n}var Bt=t=>{const e=Ft({},t);let n,{data:r,withXSRFToken:i,xsrfHeaderName:a,xsrfCookieName:s,headers:o,auth:l}=e;if(e.headers=o=Et.from(o),e.url=st(Nt(e.baseURL,e.url),t.params,t.paramsSerializer),l&&o.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):""))),X.isFormData(r))if(mt.hasStandardBrowserEnv||mt.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0);else if(!1!==(n=o.getContentType())){const[t,...e]=n?n.split(";").map((t=>t.trim())).filter(Boolean):[];o.setContentType([t||"multipart/form-data",...e].join("; "))}if(mt.hasStandardBrowserEnv&&(i&&X.isFunction(i)&&(i=i(e)),i||!1!==i&&Dt(e.url))){const t=a&&s&&Ot.read(s);t&&o.set(a,t)}return e},kt="undefined"!=typeof XMLHttpRequest&&function(t){return new Promise((function(e,n){const r=Bt(t);let i=r.data;const a=Et.from(r.headers).normalize();let s,o,l,c,u,{responseType:h,onUploadProgress:d,onDownloadProgress:p}=r;function f(){c&&c(),u&&u(),r.cancelToken&&r.cancelToken.unsubscribe(s),r.signal&&r.signal.removeEventListener("abort",s)}let m=new XMLHttpRequest;function g(){if(!m)return;const r=Et.from("getAllResponseHeaders"in m&&m.getAllResponseHeaders());Ct((function(t){e(t),f()}),(function(t){n(t),f()}),{data:h&&"text"!==h&&"json"!==h?m.response:m.responseText,status:m.status,statusText:m.statusText,headers:r,config:t,request:m}),m=null}m.open(r.method.toUpperCase(),r.url,!0),m.timeout=r.timeout,"onloadend"in m?m.onloadend=g:m.onreadystatechange=function(){m&&4===m.readyState&&(0!==m.status||m.responseURL&&0===m.responseURL.indexOf("file:"))&&setTimeout(g)},m.onabort=function(){m&&(n(new Y("Request aborted",Y.ECONNABORTED,t,m)),m=null)},m.onerror=function(){n(new Y("Network Error",Y.ERR_NETWORK,t,m)),m=null},m.ontimeout=function(){let e=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const i=r.transitional||lt;r.timeoutErrorMessage&&(e=r.timeoutErrorMessage),n(new Y(e,i.clarifyTimeoutError?Y.ETIMEDOUT:Y.ECONNABORTED,t,m)),m=null},void 0===i&&a.setContentType(null),"setRequestHeader"in m&&X.forEach(a.toJSON(),(function(t,e){m.setRequestHeader(e,t)})),X.isUndefined(r.withCredentials)||(m.withCredentials=!!r.withCredentials),h&&"json"!==h&&(m.responseType=r.responseType),p&&([l,u]=Pt(p,!0),m.addEventListener("progress",l)),d&&m.upload&&([o,c]=Pt(d),m.upload.addEventListener("progress",o),m.upload.addEventListener("loadend",c)),(r.cancelToken||r.signal)&&(s=e=>{m&&(n(!e||e.type?new Rt(null,t,m):e),m.abort(),m=null)},r.cancelToken&&r.cancelToken.subscribe(s),r.signal&&(r.signal.aborted?s():r.signal.addEventListener("abort",s)));const v=function(t){const e=/^([-+\w]{1,25})(:?\/\/|:)/.exec(t);return e&&e[1]||""}(r.url);v&&-1===mt.protocols.indexOf(v)?n(new Y("Unsupported protocol "+v+":",Y.ERR_BAD_REQUEST,t)):m.send(i||null)}))},zt=(t,e)=>{const{length:n}=t=t?t.filter(Boolean):[];if(e||n){let n,r=new AbortController;const i=function(t){if(!n){n=!0,s();const e=t instanceof Error?t:this.reason;r.abort(e instanceof Y?e:new Rt(e instanceof Error?e.message:e))}};let a=e&&setTimeout((()=>{a=null,i(new Y(`timeout ${e} of ms exceeded`,Y.ETIMEDOUT))}),e);const s=()=>{t&&(a&&clearTimeout(a),a=null,t.forEach((t=>{t.unsubscribe?t.unsubscribe(i):t.removeEventListener("abort",i)})),t=null)};t.forEach((t=>t.addEventListener("abort",i)));const{signal:o}=r;return o.unsubscribe=()=>X.asap(s),o}};const Ht=function*(t,e){let n=t.byteLength;if(!e||n<e)return void(yield t);let r,i=0;for(;i<n;)r=i+e,yield t.slice(i,r),i=r},Gt=(t,e,n,r)=>{const i=async function*(t,e){for await(const n of async function*(t){if(t[Symbol.asyncIterator])return void(yield*t);const e=t.getReader();try{for(;;){const{done:t,value:n}=await e.read();if(t)break;yield n}}finally{await e.cancel()}}(t))yield*Ht(n,e)}(t,e);let a,s=0,o=t=>{a||(a=!0,r&&r(t))};return new ReadableStream({async pull(t){try{const{done:e,value:r}=await i.next();if(e)return o(),void t.close();let a=r.byteLength;if(n){let t=s+=a;n(t)}t.enqueue(new Uint8Array(r))}catch(t){throw o(t),t}},cancel:t=>(o(t),i.return())},{highWaterMark:2})},Vt="function"==typeof fetch&&"function"==typeof Request&&"function"==typeof Response,Wt=Vt&&"function"==typeof ReadableStream,jt=Vt&&("function"==typeof TextEncoder?(qt=new TextEncoder,t=>qt.encode(t)):async t=>new Uint8Array(await new Response(t).arrayBuffer()));var qt;const Xt=(t,...e)=>{try{return!!t(...e)}catch(t){return!1}},Yt=Wt&&Xt((()=>{let t=!1;const e=new Request(mt.origin,{body:new ReadableStream,method:"POST",get duplex(){return t=!0,"half"}}).headers.has("Content-Type");return t&&!e})),$t=Wt&&Xt((()=>X.isReadableStream(new Response("").body))),Kt={stream:$t&&(t=>t.body)};var Zt;Vt&&(Zt=new Response,["text","arrayBuffer","blob","formData","stream"].forEach((t=>{!Kt[t]&&(Kt[t]=X.isFunction(Zt[t])?e=>e[t]():(e,n)=>{throw new Y(`Response type '${t}' is not supported`,Y.ERR_NOT_SUPPORT,n)})})));const Jt={http:null,xhr:kt,fetch:Vt&&(async t=>{let{url:e,method:n,data:r,signal:i,cancelToken:a,timeout:s,onDownloadProgress:o,onUploadProgress:l,responseType:c,headers:u,withCredentials:h="same-origin",fetchOptions:d}=Bt(t);c=c?(c+"").toLowerCase():"text";let p,f=zt([i,a&&a.toAbortSignal()],s);const m=f&&f.unsubscribe&&(()=>{f.unsubscribe()});let g;try{if(l&&Yt&&"get"!==n&&"head"!==n&&0!==(g=await(async(t,e)=>{const n=X.toFiniteNumber(t.getContentLength());return null==n?(async t=>{if(null==t)return 0;if(X.isBlob(t))return t.size;if(X.isSpecCompliantForm(t)){const e=new Request(mt.origin,{method:"POST",body:t});return(await e.arrayBuffer()).byteLength}return X.isArrayBufferView(t)||X.isArrayBuffer(t)?t.byteLength:(X.isURLSearchParams(t)&&(t+=""),X.isString(t)?(await jt(t)).byteLength:void 0)})(e):n})(u,r))){let t,n=new Request(e,{method:"POST",body:r,duplex:"half"});if(X.isFormData(r)&&(t=n.headers.get("content-type"))&&u.setContentType(t),n.body){const[t,e]=It(g,Pt(Lt(l)));r=Gt(n.body,65536,t,e)}}X.isString(h)||(h=h?"include":"omit");const i="credentials"in Request.prototype;p=new Request(e,{...d,signal:f,method:n.toUpperCase(),headers:u.normalize().toJSON(),body:r,duplex:"half",credentials:i?h:void 0});let a=await fetch(p);const s=$t&&("stream"===c||"response"===c);if($t&&(o||s&&m)){const t={};["status","statusText","headers"].forEach((e=>{t[e]=a[e]}));const e=X.toFiniteNumber(a.headers.get("content-length")),[n,r]=o&&It(e,Pt(Lt(o),!0))||[];a=new Response(Gt(a.body,65536,n,(()=>{r&&r(),m&&m()})),t)}c=c||"text";let v=await Kt[X.findKey(Kt,c)||"text"](a,t);return!s&&m&&m(),await new Promise(((e,n)=>{Ct(e,n,{data:v,headers:Et.from(a.headers),status:a.status,statusText:a.statusText,config:t,request:p})}))}catch(e){if(m&&m(),e&&"TypeError"===e.name&&/fetch/i.test(e.message))throw Object.assign(new Y("Network Error",Y.ERR_NETWORK,t,p),{cause:e.cause||e});throw Y.from(e,e&&e.code,t,p)}})};X.forEach(Jt,((t,e)=>{if(t){try{Object.defineProperty(t,"name",{value:e})}catch(t){}Object.defineProperty(t,"adapterName",{value:e})}}));const Qt=t=>`- ${t}`,te=t=>X.isFunction(t)||null===t||!1===t;var ee=t=>{t=X.isArray(t)?t:[t];const{length:e}=t;let n,r;const i={};for(let a=0;a<e;a++){let e;if(n=t[a],r=n,!te(n)&&(r=Jt[(e=String(n)).toLowerCase()],void 0===r))throw new Y(`Unknown adapter '${e}'`);if(r)break;i[e||"#"+a]=r}if(!r){const t=Object.entries(i).map((([t,e])=>`adapter ${t} `+(!1===e?"is not supported by the environment":"is not available in the build")));throw new Y("There is no suitable adapter to dispatch the request "+(e?t.length>1?"since :\n"+t.map(Qt).join("\n"):" "+Qt(t[0]):"as no adapter specified"),"ERR_NOT_SUPPORT")}return r};function ne(t){if(t.cancelToken&&t.cancelToken.throwIfRequested(),t.signal&&t.signal.aborted)throw new Rt(null,t)}function re(t){return ne(t),t.headers=Et.from(t.headers),t.data=St.call(t,t.transformRequest),-1!==["post","put","patch"].indexOf(t.method)&&t.headers.setContentType("application/x-www-form-urlencoded",!1),ee(t.adapter||_t.adapter)(t).then((function(e){return ne(t),e.data=St.call(t,t.transformResponse,e),e.headers=Et.from(e.headers),e}),(function(e){return At(e)||(ne(t),e&&e.response&&(e.response.data=St.call(t,t.transformResponse,e.response),e.response.headers=Et.from(e.response.headers))),Promise.reject(e)}))}const ie={};["object","boolean","number","function","string","symbol"].forEach(((t,e)=>{ie[t]=function(n){return typeof n===t||"a"+(e<1?"n ":" ")+t}}));const ae={};ie.transitional=function(t,e,n){function r(t,e){return"[Axios v1.7.7] Transitional option '"+t+"'"+e+(n?". "+n:"")}return(n,i,a)=>{if(!1===t)throw new Y(r(i," has been removed"+(e?" in "+e:"")),Y.ERR_DEPRECATED);return e&&!ae[i]&&(ae[i]=!0,console.warn(r(i," has been deprecated since v"+e+" and will be removed in the near future"))),!t||t(n,i,a)}};var se={assertOptions:function(t,e,n){if("object"!=typeof t)throw new Y("options must be an object",Y.ERR_BAD_OPTION_VALUE);const r=Object.keys(t);let i=r.length;for(;i-- >0;){const a=r[i],s=e[a];if(s){const e=t[a],n=void 0===e||s(e,a,t);if(!0!==n)throw new Y("option "+a+" must be "+n,Y.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new Y("Unknown option "+a,Y.ERR_BAD_OPTION)}},validators:ie};const oe=se.validators;class le{constructor(t){this.defaults=t,this.interceptors={request:new ot,response:new ot}}async request(t,e){try{return await this._request(t,e)}catch(t){if(t instanceof Error){let e;Error.captureStackTrace?Error.captureStackTrace(e={}):e=new Error;const n=e.stack?e.stack.replace(/^.+\n/,""):"";try{t.stack?n&&!String(t.stack).endsWith(n.replace(/^.+\n.+\n/,""))&&(t.stack+="\n"+n):t.stack=n}catch(t){}}throw t}}_request(t,e){"string"==typeof t?(e=e||{}).url=t:e=t||{},e=Ft(this.defaults,e);const{transitional:n,paramsSerializer:r,headers:i}=e;void 0!==n&&se.assertOptions(n,{silentJSONParsing:oe.transitional(oe.boolean),forcedJSONParsing:oe.transitional(oe.boolean),clarifyTimeoutError:oe.transitional(oe.boolean)},!1),null!=r&&(X.isFunction(r)?e.paramsSerializer={serialize:r}:se.assertOptions(r,{encode:oe.function,serialize:oe.function},!0)),e.method=(e.method||this.defaults.method||"get").toLowerCase();let a=i&&X.merge(i.common,i[e.method]);i&&X.forEach(["delete","get","head","post","put","patch","common"],(t=>{delete i[t]})),e.headers=Et.concat(a,i);const s=[];let o=!0;this.interceptors.request.forEach((function(t){"function"==typeof t.runWhen&&!1===t.runWhen(e)||(o=o&&t.synchronous,s.unshift(t.fulfilled,t.rejected))}));const l=[];let c;this.interceptors.response.forEach((function(t){l.push(t.fulfilled,t.rejected)}));let u,h=0;if(!o){const t=[re.bind(this),void 0];for(t.unshift.apply(t,s),t.push.apply(t,l),u=t.length,c=Promise.resolve(e);h<u;)c=c.then(t[h++],t[h++]);return c}u=s.length;let d=e;for(h=0;h<u;){const t=s[h++],e=s[h++];try{d=t(d)}catch(t){e.call(this,t);break}}try{c=re.call(this,d)}catch(t){return Promise.reject(t)}for(h=0,u=l.length;h<u;)c=c.then(l[h++],l[h++]);return c}getUri(t){return st(Nt((t=Ft(this.defaults,t)).baseURL,t.url),t.params,t.paramsSerializer)}}X.forEach(["delete","get","head","options"],(function(t){le.prototype[t]=function(e,n){return this.request(Ft(n||{},{method:t,url:e,data:(n||{}).data}))}})),X.forEach(["post","put","patch"],(function(t){function e(e){return function(n,r,i){return this.request(Ft(i||{},{method:t,headers:e?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}le.prototype[t]=e(),le.prototype[t+"Form"]=e(!0)}));var ce=le;class ue{constructor(t){if("function"!=typeof t)throw new TypeError("executor must be a function.");let e;this.promise=new Promise((function(t){e=t}));const n=this;this.promise.then((t=>{if(!n._listeners)return;let e=n._listeners.length;for(;e-- >0;)n._listeners[e](t);n._listeners=null})),this.promise.then=t=>{let e;const r=new Promise((t=>{n.subscribe(t),e=t})).then(t);return r.cancel=function(){n.unsubscribe(e)},r},t((function(t,r,i){n.reason||(n.reason=new Rt(t,r,i),e(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(t){this.reason?t(this.reason):this._listeners?this._listeners.push(t):this._listeners=[t]}unsubscribe(t){if(!this._listeners)return;const e=this._listeners.indexOf(t);-1!==e&&this._listeners.splice(e,1)}toAbortSignal(){const t=new AbortController,e=e=>{t.abort(e)};return this.subscribe(e),t.signal.unsubscribe=()=>this.unsubscribe(e),t.signal}static source(){let t;return{token:new ue((function(e){t=e})),cancel:t}}}var he=ue;const de={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(de).forEach((([t,e])=>{de[e]=t}));var pe=de;const fe=function t(e){const n=new ce(e),i=r(ce.prototype.request,n);return X.extend(i,ce.prototype,n,{allOwnKeys:!0}),X.extend(i,n,null,{allOwnKeys:!0}),i.create=function(n){return t(Ft(e,n))},i}(_t);fe.Axios=ce,fe.CanceledError=Rt,fe.CancelToken=he,fe.isCancel=At,fe.VERSION="1.7.7",fe.toFormData=et,fe.AxiosError=Y,fe.Cancel=fe.CanceledError,fe.all=function(t){return Promise.all(t)},fe.spread=function(t){return function(e){return t.apply(null,e)}},fe.isAxiosError=function(t){return X.isObject(t)&&!0===t.isAxiosError},fe.mergeConfig=Ft,fe.AxiosHeaders=Et,fe.formToJSON=t=>gt(X.isHTMLForm(t)?new FormData(t):t),fe.getAdapter=ee,fe.HttpStatusCode=pe,fe.default=fe,t.exports=fe}},e={};function n(r){var i=e[r];if(void 0!==i)return i.exports;var a=e[r]={exports:{}};return t[r].call(a.exports,a,a.exports,n),a.exports}n.m=t,n.u=t=>t+".bundle.js",n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),(()=>{var t;n.g.importScripts&&(t=n.g.location+"");var e=n.g.document;if(!t&&e&&(e.currentScript&&"SCRIPT"===e.currentScript.tagName.toUpperCase()&&(t=e.currentScript.src),!t)){var r=e.getElementsByTagName("script");if(r.length)for(var i=r.length-1;i>-1&&(!t||!/^http(s?):/.test(t));)t=r[i--].src}if(!t)throw new Error("Automatic publicPath is not supported in this browser");t=t.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),n.p=t})(),n.b=document.baseURI||self.location.href,(()=>{"use strict";var t=n(55),e=n(877),r=n(488);const i="170",a=0,s=1,o=2,l=100,c=101,u=102,h=200,d=201,p=202,f=203,m=204,g=205,v=206,_=207,y=208,x=209,b=210,w=211,M=212,T=213,E=214,S=0,A=1,R=2,C=3,P=4,I=5,L=6,D=7,O="attached",N=301,U=302,F=303,B=306,k=1e3,z=1001,H=1002,G=1003,V=1004,W=1005,j=1006,q=1007,X=1008,Y=1009,$=1010,K=1011,Z=1012,J=1013,Q=1014,tt=1015,et=1016,nt=1017,rt=1018,it=1020,at=1023,st=1026,ot=1027,lt=1028,ct=1029,ut=1030,ht=1031,dt=1033,pt=33776,ft=33777,mt=33778,gt=33779,vt=35840,_t=35841,yt=35842,xt=35843,bt=36196,wt=37492,Mt=37496,Tt=37808,Et=37809,St=37810,At=37811,Rt=37812,Ct=37813,Pt=37814,It=37815,Lt=37816,Dt=37817,Ot=37818,Nt=37819,Ut=37820,Ft=37821,Bt=36492,kt=36494,zt=36495,Ht=36284,Gt=36285,Vt=36286,Wt=2300,jt=2301,qt=2302,Xt="",Yt="srgb",$t="srgb-linear",Kt="linear",Zt="srgb",Jt=7680,Qt=512,te=513,ee=514,ne=515,re=516,ie=517,ae=518,se=519,oe=35044,le="300 es",ce=2e3,ue=2001;class he{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,r=n.length;e<r;e++)n[e].call(this,t);t.target=null}}}const de=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];const pe=Math.PI/180,fe=180/Math.PI;function me(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(de[255&t]+de[t>>8&255]+de[t>>16&255]+de[t>>24&255]+"-"+de[255&e]+de[e>>8&255]+"-"+de[e>>16&15|64]+de[e>>24&255]+"-"+de[63&n|128]+de[n>>8&255]+"-"+de[n>>16&255]+de[n>>24&255]+de[255&r]+de[r>>8&255]+de[r>>16&255]+de[r>>24&255]).toLowerCase()}function ge(t,e,n){return Math.max(e,Math.min(n,t))}function ve(t,e){return(t%e+e)%e}function _e(t,e,n){return(1-n)*t+n*e}function ye(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function xe(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const be=pe,we=function(t){return t*fe};class Me{constructor(t=0,e=0){Me.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(ge(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),i=this.x-t.x,a=this.y-t.y;return this.x=i*n-a*r+t.x,this.y=i*r+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Te{constructor(t,e,n,r,i,a,s,o,l){Te.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,n,r,i,a,s,o,l)}set(t,e,n,r,i,a,s,o,l){const c=this.elements;return c[0]=t,c[1]=r,c[2]=s,c[3]=e,c[4]=i,c[5]=o,c[6]=n,c[7]=a,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,a=n[0],s=n[3],o=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],v=r[1],_=r[4],y=r[7],x=r[2],b=r[5],w=r[8];return i[0]=a*f+s*v+o*x,i[3]=a*m+s*_+o*b,i[6]=a*g+s*y+o*w,i[1]=l*f+c*v+u*x,i[4]=l*m+c*_+u*b,i[7]=l*g+c*y+u*w,i[2]=h*f+d*v+p*x,i[5]=h*m+d*_+p*b,i[8]=h*g+d*y+p*w,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],a=t[4],s=t[5],o=t[6],l=t[7],c=t[8];return e*a*c-e*s*l-n*i*c+n*s*o+r*i*l-r*a*o}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],a=t[4],s=t[5],o=t[6],l=t[7],c=t[8],u=c*a-s*l,h=s*o-c*i,d=l*i-a*o,p=e*u+n*h+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=u*f,t[1]=(r*l-c*n)*f,t[2]=(s*n-r*a)*f,t[3]=h*f,t[4]=(c*e-r*o)*f,t[5]=(r*i-s*e)*f,t[6]=d*f,t[7]=(n*o-l*e)*f,t[8]=(a*e-n*i)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,i,a,s){const o=Math.cos(i),l=Math.sin(i);return this.set(n*o,n*l,-n*(o*a+l*s)+a+t,-r*l,r*o,-r*(-l*a+o*s)+s+e,0,0,1),this}scale(t,e){return this.premultiply(Ee.makeScale(t,e)),this}rotate(t){return this.premultiply(Ee.makeRotation(-t)),this}translate(t,e){return this.premultiply(Ee.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const Ee=new Te;function Se(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}function Ae(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function Re(){const t=Ae("canvas");return t.style.display="block",t}Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;const Ce={};function Pe(t){t in Ce||(Ce[t]=!0,console.warn(t))}const Ie={enabled:!0,workingColorSpace:$t,spaces:{},convert:function(t,e,n){return!1!==this.enabled&&e!==n&&e&&n?(this.spaces[e].transfer===Zt&&(t.r=Le(t.r),t.g=Le(t.g),t.b=Le(t.b)),this.spaces[e].primaries!==this.spaces[n].primaries&&(t.applyMatrix3(this.spaces[e].toXYZ),t.applyMatrix3(this.spaces[n].fromXYZ)),this.spaces[n].transfer===Zt&&(t.r=De(t.r),t.g=De(t.g),t.b=De(t.b)),t):t},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)},getPrimaries:function(t){return this.spaces[t].primaries},getTransfer:function(t){return t===Xt?Kt:this.spaces[t].transfer},getLuminanceCoefficients:function(t,e=this.workingColorSpace){return t.fromArray(this.spaces[e].luminanceCoefficients)},define:function(t){Object.assign(this.spaces,t)},_getMatrix:function(t,e,n){return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ)},_getDrawingBufferColorSpace:function(t){return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(t=this.workingColorSpace){return this.spaces[t].workingColorSpaceConfig.unpackColorSpace}};function Le(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function De(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}const Oe=[.64,.33,.3,.6,.15,.06],Ne=[.2126,.7152,.0722],Ue=[.3127,.329],Fe=(new Te).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Be=(new Te).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);let ke;Ie.define({[$t]:{primaries:Oe,whitePoint:Ue,transfer:Kt,toXYZ:Fe,fromXYZ:Be,luminanceCoefficients:Ne,workingColorSpaceConfig:{unpackColorSpace:Yt},outputColorSpaceConfig:{drawingBufferColorSpace:Yt}},[Yt]:{primaries:Oe,whitePoint:Ue,transfer:Zt,toXYZ:Fe,fromXYZ:Be,luminanceCoefficients:Ne,outputColorSpaceConfig:{drawingBufferColorSpace:Yt}}});class ze{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===ke&&(ke=Ae("canvas")),ke.width=t.width,ke.height=t.height;const n=ke.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=ke}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=Ae("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const r=n.getImageData(0,0,t.width,t.height),i=r.data;for(let t=0;t<i.length;t++)i[t]=255*Le(i[t]/255);return n.putImageData(r,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*Le(e[t]/255)):e[t]=Le(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let He=0;class Ge{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:He++}),this.uuid=me(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(null!==r){let t;if(Array.isArray(r)){t=[];for(let e=0,n=r.length;e<n;e++)r[e].isDataTexture?t.push(Ve(r[e].image)):t.push(Ve(r[e]))}else t=Ve(r);n.url=t}return e||(t.images[this.uuid]=n),n}}function Ve(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?ze.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let We=0;class je extends he{constructor(t=je.DEFAULT_IMAGE,e=je.DEFAULT_MAPPING,n=1001,r=1001,i=1006,a=1008,s=1023,o=1009,l=je.DEFAULT_ANISOTROPY,c=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:We++}),this.uuid=me(),this.name="",this.source=new Ge(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=a,this.anisotropy=l,this.format=s,this.internalFormat=null,this.type=o,this.offset=new Me(0,0),this.repeat=new Me(1,1),this.center=new Me(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Te,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case k:t.x=t.x-Math.floor(t.x);break;case z:t.x=t.x<0?0:1;break;case H:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case k:t.y=t.y-Math.floor(t.y);break;case z:t.y=t.y<0?0:1;break;case H:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}}je.DEFAULT_IMAGE=null,je.DEFAULT_MAPPING=300,je.DEFAULT_ANISOTROPY=1;class qe{constructor(t=0,e=0,n=0,r=1){qe.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*r+a[12]*i,this.y=a[1]*e+a[5]*n+a[9]*r+a[13]*i,this.z=a[2]*e+a[6]*n+a[10]*r+a[14]*i,this.w=a[3]*e+a[7]*n+a[11]*r+a[15]*i,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,i;const a=.01,s=.1,o=t.elements,l=o[0],c=o[4],u=o[8],h=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(c-h)<a&&Math.abs(u-f)<a&&Math.abs(p-m)<a){if(Math.abs(c+h)<s&&Math.abs(u+f)<s&&Math.abs(p+m)<s&&Math.abs(l+d+g-3)<s)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,v=(g+1)/2,_=(c+h)/4,y=(u+f)/4,x=(p+m)/4;return t>o&&t>v?t<a?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(t),r=_/n,i=y/n):o>v?o<a?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(o),n=_/r,i=x/r):v<a?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(v),n=y/i,r=x/i),this.set(n,r,i,e),this}let v=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));return Math.abs(v)<.001&&(v=1),this.x=(m-p)/v,this.y=(u-f)/v,this.z=(h-c)/v,this.w=Math.acos((l+d+g-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Xe extends he{constructor(t=1,e=1,n={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new qe(0,0,t,e),this.scissorTest=!1,this.viewport=new qe(0,0,t,e);const r={width:t,height:e,depth:1};n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:j,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},n);const i=new je(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);i.flipY=!1,i.generateMipmaps=n.generateMipmaps,i.internalFormat=n.internalFormat,this.textures=[];const a=n.count;for(let t=0;t<a;t++)this.textures[t]=i.clone(),this.textures[t].isRenderTargetTexture=!0;this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let r=0,i=this.textures.length;r<i;r++)this.textures[r].image.width=t,this.textures[r].image.height=e,this.textures[r].image.depth=n;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let e=0,n=t.textures.length;e<n;e++)this.textures[e]=t.textures[e].clone(),this.textures[e].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Ge(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Ye extends Xe{constructor(t=1,e=1,n={}){super(t,e,n),this.isWebGLRenderTarget=!0}}class $e extends je{constructor(t=null,e=1,n=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:r},this.magFilter=G,this.minFilter=G,this.wrapR=z,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class Ke extends Ye{constructor(t=1,e=1,n=1,r={}){super(t,e,r),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new $e(null,t,e,n),this.texture.isRenderTargetTexture=!0}}class Ze extends je{constructor(t=null,e=1,n=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:r},this.magFilter=G,this.minFilter=G,this.wrapR=z,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Je{constructor(t=0,e=0,n=0,r=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=r}static slerpFlat(t,e,n,r,i,a,s){let o=n[r+0],l=n[r+1],c=n[r+2],u=n[r+3];const h=i[a+0],d=i[a+1],p=i[a+2],f=i[a+3];if(0===s)return t[e+0]=o,t[e+1]=l,t[e+2]=c,void(t[e+3]=u);if(1===s)return t[e+0]=h,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(u!==f||o!==h||l!==d||c!==p){let t=1-s;const e=o*h+l*d+c*p+u*f,n=e>=0?1:-1,r=1-e*e;if(r>Number.EPSILON){const i=Math.sqrt(r),a=Math.atan2(i,e*n);t=Math.sin(t*a)/i,s=Math.sin(s*a)/i}const i=s*n;if(o=o*t+h*i,l=l*t+d*i,c=c*t+p*i,u=u*t+f*i,t===1-s){const t=1/Math.sqrt(o*o+l*l+c*c+u*u);o*=t,l*=t,c*=t,u*=t}}t[e]=o,t[e+1]=l,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,r,i,a){const s=n[r],o=n[r+1],l=n[r+2],c=n[r+3],u=i[a],h=i[a+1],d=i[a+2],p=i[a+3];return t[e]=s*p+c*u+o*d-l*h,t[e+1]=o*p+c*h+l*u-s*d,t[e+2]=l*p+c*d+s*h-o*u,t[e+3]=c*p-s*u-o*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const n=t._x,r=t._y,i=t._z,a=t._order,s=Math.cos,o=Math.sin,l=s(n/2),c=s(r/2),u=s(i/2),h=o(n/2),d=o(r/2),p=o(i/2);switch(a){case"XYZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],i=e[8],a=e[1],s=e[5],o=e[9],l=e[2],c=e[6],u=e[10],h=n+s+u;if(h>0){const t=.5/Math.sqrt(h+1);this._w=.25/t,this._x=(c-o)*t,this._y=(i-l)*t,this._z=(a-r)*t}else if(n>s&&n>u){const t=2*Math.sqrt(1+n-s-u);this._w=(c-o)/t,this._x=.25*t,this._y=(r+a)/t,this._z=(i+l)/t}else if(s>u){const t=2*Math.sqrt(1+s-n-u);this._w=(i-l)/t,this._x=(r+a)/t,this._y=.25*t,this._z=(o+c)/t}else{const t=2*Math.sqrt(1+u-n-s);this._w=(a-r)/t,this._x=(i+l)/t,this._y=(o+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ge(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,i=t._z,a=t._w,s=e._x,o=e._y,l=e._z,c=e._w;return this._x=n*c+a*s+r*l-i*o,this._y=r*c+a*o+i*s-n*l,this._z=i*c+a*l+n*o-r*s,this._w=a*c-n*s-r*o-i*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,r=this._y,i=this._z,a=this._w;let s=a*t._w+n*t._x+r*t._y+i*t._z;if(s<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,s=-s):this.copy(t),s>=1)return this._w=a,this._x=n,this._y=r,this._z=i,this;const o=1-s*s;if(o<=Number.EPSILON){const t=1-e;return this._w=t*a+e*this._w,this._x=t*n+e*this._x,this._y=t*r+e*this._y,this._z=t*i+e*this._z,this.normalize(),this}const l=Math.sqrt(o),c=Math.atan2(l,s),u=Math.sin((1-e)*c)/l,h=Math.sin(e*c)/l;return this._w=a*u+this._w*h,this._x=n*u+this._x*h,this._y=r*u+this._y*h,this._z=i*u+this._z*h,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),n=Math.random(),r=Math.sqrt(1-n),i=Math.sqrt(n);return this.set(r*Math.sin(t),r*Math.cos(t),i*Math.sin(e),i*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Qe{constructor(t=0,e=0,n=0){Qe.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(en.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(en.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6]*r,this.y=i[1]*e+i[4]*n+i[7]*r,this.z=i[2]*e+i[5]*n+i[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=t.elements,a=1/(i[3]*e+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*e+i[4]*n+i[8]*r+i[12])*a,this.y=(i[1]*e+i[5]*n+i[9]*r+i[13])*a,this.z=(i[2]*e+i[6]*n+i[10]*r+i[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,i=t.x,a=t.y,s=t.z,o=t.w,l=2*(a*r-s*n),c=2*(s*e-i*r),u=2*(i*n-a*e);return this.x=e+o*l+a*u-s*c,this.y=n+o*c+s*l-i*u,this.z=r+o*u+i*c-a*l,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[4]*n+i[8]*r,this.y=i[1]*e+i[5]*n+i[9]*r,this.z=i[2]*e+i[6]*n+i[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,i=t.z,a=e.x,s=e.y,o=e.z;return this.x=r*o-i*s,this.y=i*a-n*o,this.z=n*s-r*a,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return tn.copy(this).projectOnVector(t),this.sub(tn)}reflect(t){return this.sub(tn.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(ge(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,n=Math.sqrt(1-e*e);return this.x=n*Math.cos(t),this.y=e,this.z=n*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const tn=new Qe,en=new Je;class nn{constructor(t=new Qe(1/0,1/0,1/0),e=new Qe(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(an.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(an.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=an.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(void 0!==n){const r=n.getAttribute("position");if(!0===e&&void 0!==r&&!0!==t.isInstancedMesh)for(let e=0,n=r.count;e<n;e++)!0===t.isMesh?t.getVertexPosition(e,an):an.fromBufferAttribute(r,e),an.applyMatrix4(t.matrixWorld),this.expandByPoint(an);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),sn.copy(t.boundingBox)):(null===n.boundingBox&&n.computeBoundingBox(),sn.copy(n.boundingBox)),sn.applyMatrix4(t.matrixWorld),this.union(sn)}const r=t.children;for(let t=0,n=r.length;t<n;t++)this.expandByObject(r[t],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,an),an.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(pn),fn.subVectors(this.max,pn),on.subVectors(t.a,pn),ln.subVectors(t.b,pn),cn.subVectors(t.c,pn),un.subVectors(ln,on),hn.subVectors(cn,ln),dn.subVectors(on,cn);let e=[0,-un.z,un.y,0,-hn.z,hn.y,0,-dn.z,dn.y,un.z,0,-un.x,hn.z,0,-hn.x,dn.z,0,-dn.x,-un.y,un.x,0,-hn.y,hn.x,0,-dn.y,dn.x,0];return!!vn(e,on,ln,cn,fn)&&(e=[1,0,0,0,1,0,0,0,1],!!vn(e,on,ln,cn,fn)&&(mn.crossVectors(un,hn),e=[mn.x,mn.y,mn.z],vn(e,on,ln,cn,fn)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,an).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(an).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(rn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),rn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),rn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),rn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),rn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),rn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),rn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),rn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(rn)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const rn=[new Qe,new Qe,new Qe,new Qe,new Qe,new Qe,new Qe,new Qe],an=new Qe,sn=new nn,on=new Qe,ln=new Qe,cn=new Qe,un=new Qe,hn=new Qe,dn=new Qe,pn=new Qe,fn=new Qe,mn=new Qe,gn=new Qe;function vn(t,e,n,r,i){for(let a=0,s=t.length-3;a<=s;a+=3){gn.fromArray(t,a);const s=i.x*Math.abs(gn.x)+i.y*Math.abs(gn.y)+i.z*Math.abs(gn.z),o=e.dot(gn),l=n.dot(gn),c=r.dot(gn);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>s)return!1}return!0}const _n=new nn,yn=new Qe,xn=new Qe;class bn{constructor(t=new Qe,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):_n.setFromPoints(t).getCenter(n);let r=0;for(let e=0,i=t.length;e<i;e++)r=Math.max(r,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;yn.subVectors(t,this.center);const e=yn.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.addScaledVector(yn,n/t),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(xn.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(yn.copy(t.center).add(xn)),this.expandByPoint(yn.copy(t.center).sub(xn))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const wn=new Qe,Mn=new Qe,Tn=new Qe,En=new Qe,Sn=new Qe,An=new Qe,Rn=new Qe;class Cn{constructor(t=new Qe,e=new Qe(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,wn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=wn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(wn.copy(this.origin).addScaledVector(this.direction,e),wn.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){Mn.copy(t).add(e).multiplyScalar(.5),Tn.copy(e).sub(t).normalize(),En.copy(this.origin).sub(Mn);const i=.5*t.distanceTo(e),a=-this.direction.dot(Tn),s=En.dot(this.direction),o=-En.dot(Tn),l=En.lengthSq(),c=Math.abs(1-a*a);let u,h,d,p;if(c>0)if(u=a*o-s,h=a*s-o,p=i*c,u>=0)if(h>=-p)if(h<=p){const t=1/c;u*=t,h*=t,d=u*(u+a*h+2*s)+h*(a*u+h+2*o)+l}else h=i,u=Math.max(0,-(a*h+s)),d=-u*u+h*(h+2*o)+l;else h=-i,u=Math.max(0,-(a*h+s)),d=-u*u+h*(h+2*o)+l;else h<=-p?(u=Math.max(0,-(-a*i+s)),h=u>0?-i:Math.min(Math.max(-i,-o),i),d=-u*u+h*(h+2*o)+l):h<=p?(u=0,h=Math.min(Math.max(-i,-o),i),d=h*(h+2*o)+l):(u=Math.max(0,-(a*i+s)),h=u>0?i:Math.min(Math.max(-i,-o),i),d=-u*u+h*(h+2*o)+l);else h=a>0?-i:i,u=Math.max(0,-(a*h+s)),d=-u*u+h*(h+2*o)+l;return n&&n.copy(this.origin).addScaledVector(this.direction,u),r&&r.copy(Mn).addScaledVector(Tn,h),d}intersectSphere(t,e){wn.subVectors(t.center,this.origin);const n=wn.dot(this.direction),r=wn.dot(wn)-n*n,i=t.radius*t.radius;if(r>i)return null;const a=Math.sqrt(i-r),s=n-a,o=n+a;return o<0?null:s<0?this.at(o,e):this.at(s,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,i,a,s,o;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,r=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,r=(t.min.x-h.x)*l),c>=0?(i=(t.min.y-h.y)*c,a=(t.max.y-h.y)*c):(i=(t.max.y-h.y)*c,a=(t.min.y-h.y)*c),n>a||i>r?null:((i>n||isNaN(n))&&(n=i),(a<r||isNaN(r))&&(r=a),u>=0?(s=(t.min.z-h.z)*u,o=(t.max.z-h.z)*u):(s=(t.max.z-h.z)*u,o=(t.min.z-h.z)*u),n>o||s>r?null:((s>n||n!=n)&&(n=s),(o<r||r!=r)&&(r=o),r<0?null:this.at(n>=0?n:r,e)))}intersectsBox(t){return null!==this.intersectBox(t,wn)}intersectTriangle(t,e,n,r,i){Sn.subVectors(e,t),An.subVectors(n,t),Rn.crossVectors(Sn,An);let a,s=this.direction.dot(Rn);if(s>0){if(r)return null;a=1}else{if(!(s<0))return null;a=-1,s=-s}En.subVectors(this.origin,t);const o=a*this.direction.dot(An.crossVectors(En,An));if(o<0)return null;const l=a*this.direction.dot(Sn.cross(En));if(l<0)return null;if(o+l>s)return null;const c=-a*En.dot(Rn);return c<0?null:this.at(c/s,i)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Pn{constructor(t,e,n,r,i,a,s,o,l,c,u,h,d,p,f,m){Pn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,n,r,i,a,s,o,l,c,u,h,d,p,f,m)}set(t,e,n,r,i,a,s,o,l,c,u,h,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=i,g[5]=a,g[9]=s,g[13]=o,g[2]=l,g[6]=c,g[10]=u,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Pn).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/In.setFromMatrixColumn(t,0).length(),i=1/In.setFromMatrixColumn(t,1).length(),a=1/In.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*i,e[5]=n[5]*i,e[6]=n[6]*i,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,r=t.y,i=t.z,a=Math.cos(n),s=Math.sin(n),o=Math.cos(r),l=Math.sin(r),c=Math.cos(i),u=Math.sin(i);if("XYZ"===t.order){const t=a*c,n=a*u,r=s*c,i=s*u;e[0]=o*c,e[4]=-o*u,e[8]=l,e[1]=n+r*l,e[5]=t-i*l,e[9]=-s*o,e[2]=i-t*l,e[6]=r+n*l,e[10]=a*o}else if("YXZ"===t.order){const t=o*c,n=o*u,r=l*c,i=l*u;e[0]=t+i*s,e[4]=r*s-n,e[8]=a*l,e[1]=a*u,e[5]=a*c,e[9]=-s,e[2]=n*s-r,e[6]=i+t*s,e[10]=a*o}else if("ZXY"===t.order){const t=o*c,n=o*u,r=l*c,i=l*u;e[0]=t-i*s,e[4]=-a*u,e[8]=r+n*s,e[1]=n+r*s,e[5]=a*c,e[9]=i-t*s,e[2]=-a*l,e[6]=s,e[10]=a*o}else if("ZYX"===t.order){const t=a*c,n=a*u,r=s*c,i=s*u;e[0]=o*c,e[4]=r*l-n,e[8]=t*l+i,e[1]=o*u,e[5]=i*l+t,e[9]=n*l-r,e[2]=-l,e[6]=s*o,e[10]=a*o}else if("YZX"===t.order){const t=a*o,n=a*l,r=s*o,i=s*l;e[0]=o*c,e[4]=i-t*u,e[8]=r*u+n,e[1]=u,e[5]=a*c,e[9]=-s*c,e[2]=-l*c,e[6]=n*u+r,e[10]=t-i*u}else if("XZY"===t.order){const t=a*o,n=a*l,r=s*o,i=s*l;e[0]=o*c,e[4]=-u,e[8]=l*c,e[1]=t*u+i,e[5]=a*c,e[9]=n*u-r,e[2]=r*u-n,e[6]=s*c,e[10]=i*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Dn,t,On)}lookAt(t,e,n){const r=this.elements;return Fn.subVectors(t,e),0===Fn.lengthSq()&&(Fn.z=1),Fn.normalize(),Nn.crossVectors(n,Fn),0===Nn.lengthSq()&&(1===Math.abs(n.z)?Fn.x+=1e-4:Fn.z+=1e-4,Fn.normalize(),Nn.crossVectors(n,Fn)),Nn.normalize(),Un.crossVectors(Fn,Nn),r[0]=Nn.x,r[4]=Un.x,r[8]=Fn.x,r[1]=Nn.y,r[5]=Un.y,r[9]=Fn.y,r[2]=Nn.z,r[6]=Un.z,r[10]=Fn.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,a=n[0],s=n[4],o=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],v=n[3],_=n[7],y=n[11],x=n[15],b=r[0],w=r[4],M=r[8],T=r[12],E=r[1],S=r[5],A=r[9],R=r[13],C=r[2],P=r[6],I=r[10],L=r[14],D=r[3],O=r[7],N=r[11],U=r[15];return i[0]=a*b+s*E+o*C+l*D,i[4]=a*w+s*S+o*P+l*O,i[8]=a*M+s*A+o*I+l*N,i[12]=a*T+s*R+o*L+l*U,i[1]=c*b+u*E+h*C+d*D,i[5]=c*w+u*S+h*P+d*O,i[9]=c*M+u*A+h*I+d*N,i[13]=c*T+u*R+h*L+d*U,i[2]=p*b+f*E+m*C+g*D,i[6]=p*w+f*S+m*P+g*O,i[10]=p*M+f*A+m*I+g*N,i[14]=p*T+f*R+m*L+g*U,i[3]=v*b+_*E+y*C+x*D,i[7]=v*w+_*S+y*P+x*O,i[11]=v*M+_*A+y*I+x*N,i[15]=v*T+_*R+y*L+x*U,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],i=t[12],a=t[1],s=t[5],o=t[9],l=t[13],c=t[2],u=t[6],h=t[10],d=t[14];return t[3]*(+i*o*u-r*l*u-i*s*h+n*l*h+r*s*d-n*o*d)+t[7]*(+e*o*d-e*l*h+i*a*h-r*a*d+r*l*c-i*o*c)+t[11]*(+e*l*u-e*s*d-i*a*u+n*a*d+i*s*c-n*l*c)+t[15]*(-r*s*c-e*o*u+e*s*h+r*a*u-n*a*h+n*o*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],a=t[4],s=t[5],o=t[6],l=t[7],c=t[8],u=t[9],h=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],v=u*m*l-f*h*l+f*o*d-s*m*d-u*o*g+s*h*g,_=p*h*l-c*m*l-p*o*d+a*m*d+c*o*g-a*h*g,y=c*f*l-p*u*l+p*s*d-a*f*d-c*s*g+a*u*g,x=p*u*o-c*f*o-p*s*h+a*f*h+c*s*m-a*u*m,b=e*v+n*_+r*y+i*x;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/b;return t[0]=v*w,t[1]=(f*h*i-u*m*i-f*r*d+n*m*d+u*r*g-n*h*g)*w,t[2]=(s*m*i-f*o*i+f*r*l-n*m*l-s*r*g+n*o*g)*w,t[3]=(u*o*i-s*h*i-u*r*l+n*h*l+s*r*d-n*o*d)*w,t[4]=_*w,t[5]=(c*m*i-p*h*i+p*r*d-e*m*d-c*r*g+e*h*g)*w,t[6]=(p*o*i-a*m*i-p*r*l+e*m*l+a*r*g-e*o*g)*w,t[7]=(a*h*i-c*o*i+c*r*l-e*h*l-a*r*d+e*o*d)*w,t[8]=y*w,t[9]=(p*u*i-c*f*i-p*n*d+e*f*d+c*n*g-e*u*g)*w,t[10]=(a*f*i-p*s*i+p*n*l-e*f*l-a*n*g+e*s*g)*w,t[11]=(c*s*i-a*u*i-c*n*l+e*u*l+a*n*d-e*s*d)*w,t[12]=x*w,t[13]=(c*f*r-p*u*r+p*n*h-e*f*h-c*n*m+e*u*m)*w,t[14]=(p*s*r-a*f*r-p*n*o+e*f*o+a*n*m-e*s*m)*w,t[15]=(a*u*r-c*s*r+c*n*o-e*u*o-a*n*h+e*s*h)*w,this}scale(t){const e=this.elements,n=t.x,r=t.y,i=t.z;return e[0]*=n,e[4]*=r,e[8]*=i,e[1]*=n,e[5]*=r,e[9]*=i,e[2]*=n,e[6]*=r,e[10]*=i,e[3]*=n,e[7]*=r,e[11]*=i,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),i=1-n,a=t.x,s=t.y,o=t.z,l=i*a,c=i*s;return this.set(l*a+n,l*s-r*o,l*o+r*s,0,l*s+r*o,c*s+n,c*o-r*a,0,l*o-r*s,c*o+r*a,i*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,r,i,a){return this.set(1,n,i,0,t,1,a,0,e,r,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,i=e._x,a=e._y,s=e._z,o=e._w,l=i+i,c=a+a,u=s+s,h=i*l,d=i*c,p=i*u,f=a*c,m=a*u,g=s*u,v=o*l,_=o*c,y=o*u,x=n.x,b=n.y,w=n.z;return r[0]=(1-(f+g))*x,r[1]=(d+y)*x,r[2]=(p-_)*x,r[3]=0,r[4]=(d-y)*b,r[5]=(1-(h+g))*b,r[6]=(m+v)*b,r[7]=0,r[8]=(p+_)*w,r[9]=(m-v)*w,r[10]=(1-(h+f))*w,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let i=In.set(r[0],r[1],r[2]).length();const a=In.set(r[4],r[5],r[6]).length(),s=In.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),t.x=r[12],t.y=r[13],t.z=r[14],Ln.copy(this);const o=1/i,l=1/a,c=1/s;return Ln.elements[0]*=o,Ln.elements[1]*=o,Ln.elements[2]*=o,Ln.elements[4]*=l,Ln.elements[5]*=l,Ln.elements[6]*=l,Ln.elements[8]*=c,Ln.elements[9]*=c,Ln.elements[10]*=c,e.setFromRotationMatrix(Ln),n.x=i,n.y=a,n.z=s,this}makePerspective(t,e,n,r,i,a,s=2e3){const o=this.elements,l=2*i/(e-t),c=2*i/(n-r),u=(e+t)/(e-t),h=(n+r)/(n-r);let d,p;if(s===ce)d=-(a+i)/(a-i),p=-2*a*i/(a-i);else{if(s!==ue)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+s);d=-a/(a-i),p=-a*i/(a-i)}return o[0]=l,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=c,o[9]=h,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,r,i,a,s=2e3){const o=this.elements,l=1/(e-t),c=1/(n-r),u=1/(a-i),h=(e+t)*l,d=(n+r)*c;let p,f;if(s===ce)p=(a+i)*u,f=-2*u;else{if(s!==ue)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+s);p=i*u,f=-1*u}return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=f,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const In=new Qe,Ln=new Pn,Dn=new Qe(0,0,0),On=new Qe(1,1,1),Nn=new Qe,Un=new Qe,Fn=new Qe,Bn=new Pn,kn=new Je;class zn{constructor(t=0,e=0,n=0,r=zn.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r=this._order){return this._x=t,this._y=e,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const r=t.elements,i=r[0],a=r[4],s=r[8],o=r[1],l=r[5],c=r[9],u=r[2],h=r[6],d=r[10];switch(e){case"XYZ":this._y=Math.asin(ge(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-a,i)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-ge(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(s,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-u,i),this._z=0);break;case"ZXY":this._x=Math.asin(ge(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-ge(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(h,d),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(ge(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-u,i)):(this._x=0,this._y=Math.atan2(s,d));break;case"XZY":this._z=Math.asin(-ge(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(s,i)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Bn.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Bn,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return kn.setFromEuler(this),this.setFromQuaternion(kn,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}zn.DEFAULT_ORDER="XYZ";class Hn{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return!!(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let Gn=0;const Vn=new Qe,Wn=new Je,jn=new Pn,qn=new Qe,Xn=new Qe,Yn=new Qe,$n=new Je,Kn=new Qe(1,0,0),Zn=new Qe(0,1,0),Jn=new Qe(0,0,1),Qn={type:"added"},tr={type:"removed"},er={type:"childadded",child:null},nr={type:"childremoved",child:null};class rr extends he{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Gn++}),this.uuid=me(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=rr.DEFAULT_UP.clone();const t=new Qe,e=new zn,n=new Je,r=new Qe(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Pn},normalMatrix:{value:new Te}}),this.matrix=new Pn,this.matrixWorld=new Pn,this.matrixAutoUpdate=rr.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=rr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Hn,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Wn.setFromAxisAngle(t,e),this.quaternion.multiply(Wn),this}rotateOnWorldAxis(t,e){return Wn.setFromAxisAngle(t,e),this.quaternion.premultiply(Wn),this}rotateX(t){return this.rotateOnAxis(Kn,t)}rotateY(t){return this.rotateOnAxis(Zn,t)}rotateZ(t){return this.rotateOnAxis(Jn,t)}translateOnAxis(t,e){return Vn.copy(t).applyQuaternion(this.quaternion),this.position.add(Vn.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Kn,t)}translateY(t){return this.translateOnAxis(Zn,t)}translateZ(t){return this.translateOnAxis(Jn,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(jn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?qn.copy(t):qn.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),Xn.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?jn.lookAt(Xn,qn,this.up):jn.lookAt(qn,Xn,this.up),this.quaternion.setFromRotationMatrix(jn),r&&(jn.extractRotation(r.matrixWorld),Wn.setFromRotationMatrix(jn),this.quaternion.premultiply(Wn.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(Qn),er.child=t,this.dispatchEvent(er),er.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(tr),nr.child=t,this.dispatchEvent(nr),nr.child=null),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),jn.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),jn.multiply(t.parent.matrixWorld)),t.applyMatrix4(jn),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(Qn),er.child=t,this.dispatchEvent(er),er.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(t,e);if(void 0!==r)return r}}getObjectsByProperty(t,e,n=[]){this[t]===e&&n.push(this);const r=this.children;for(let i=0,a=r.length;i<a;i++)r[i].getObjectsByProperty(t,e,n);return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Xn,t,Yn),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Xn,$n,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const r={};function i(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),r.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(r.type="BatchedMesh",r.perObjectFrustumCulled=this.perObjectFrustumCulled,r.sortObjects=this.sortObjects,r.drawRanges=this._drawRanges,r.reservedRanges=this._reservedRanges,r.visibility=this._visibility,r.active=this._active,r.bounds=this._bounds.map((t=>({boxInitialized:t.boxInitialized,boxMin:t.box.min.toArray(),boxMax:t.box.max.toArray(),sphereInitialized:t.sphereInitialized,sphereRadius:t.sphere.radius,sphereCenter:t.sphere.center.toArray()}))),r.maxInstanceCount=this._maxInstanceCount,r.maxVertexCount=this._maxVertexCount,r.maxIndexCount=this._maxIndexCount,r.geometryInitialized=this._geometryInitialized,r.geometryCount=this._geometryCount,r.matricesTexture=this._matricesTexture.toJSON(t),null!==this._colorsTexture&&(r.colorsTexture=this._colorsTexture.toJSON(t)),null!==this.boundingSphere&&(r.boundingSphere={center:r.boundingSphere.center.toArray(),radius:r.boundingSphere.radius}),null!==this.boundingBox&&(r.boundingBox={min:r.boundingBox.min.toArray(),max:r.boundingBox.max.toArray()})),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,r=n.length;e<r;e++){const r=n[e];i(t.shapes,r)}else i(t.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,r=this.material.length;n<r;n++)e.push(i(t.materials,this.material[n]));r.material=e}else r.material=i(t.materials,this.material);if(this.children.length>0){r.children=[];for(let e=0;e<this.children.length;e++)r.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];r.animations.push(i(t.animations,n))}}if(e){const e=a(t.geometries),r=a(t.materials),i=a(t.textures),s=a(t.images),o=a(t.shapes),l=a(t.skeletons),c=a(t.animations),u=a(t.nodes);e.length>0&&(n.geometries=e),r.length>0&&(n.materials=r),i.length>0&&(n.textures=i),s.length>0&&(n.images=s),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),u.length>0&&(n.nodes=u)}return n.object=r,n;function a(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}rr.DEFAULT_UP=new Qe(0,1,0),rr.DEFAULT_MATRIX_AUTO_UPDATE=!0,rr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ir=new Qe,ar=new Qe,sr=new Qe,or=new Qe,lr=new Qe,cr=new Qe,ur=new Qe,hr=new Qe,dr=new Qe,pr=new Qe,fr=new qe,mr=new qe,gr=new qe;class vr{constructor(t=new Qe,e=new Qe,n=new Qe){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r.subVectors(n,e),ir.subVectors(t,e),r.cross(ir);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(t,e,n,r,i){ir.subVectors(r,e),ar.subVectors(n,e),sr.subVectors(t,e);const a=ir.dot(ir),s=ir.dot(ar),o=ir.dot(sr),l=ar.dot(ar),c=ar.dot(sr),u=a*l-s*s;if(0===u)return i.set(0,0,0),null;const h=1/u,d=(l*o-s*c)*h,p=(a*c-s*o)*h;return i.set(1-d-p,p,d)}static containsPoint(t,e,n,r){return null!==this.getBarycoord(t,e,n,r,or)&&or.x>=0&&or.y>=0&&or.x+or.y<=1}static getInterpolation(t,e,n,r,i,a,s,o){return null===this.getBarycoord(t,e,n,r,or)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(i,or.x),o.addScaledVector(a,or.y),o.addScaledVector(s,or.z),o)}static getInterpolatedAttribute(t,e,n,r,i,a){return fr.setScalar(0),mr.setScalar(0),gr.setScalar(0),fr.fromBufferAttribute(t,e),mr.fromBufferAttribute(t,n),gr.fromBufferAttribute(t,r),a.setScalar(0),a.addScaledVector(fr,i.x),a.addScaledVector(mr,i.y),a.addScaledVector(gr,i.z),a}static isFrontFacing(t,e,n,r){return ir.subVectors(n,e),ar.subVectors(t,e),ir.cross(ar).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,n,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,r),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ir.subVectors(this.c,this.b),ar.subVectors(this.a,this.b),.5*ir.cross(ar).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return vr.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return vr.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,n,r,i){return vr.getInterpolation(t,this.a,this.b,this.c,e,n,r,i)}containsPoint(t){return vr.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return vr.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,r=this.b,i=this.c;let a,s;lr.subVectors(r,n),cr.subVectors(i,n),hr.subVectors(t,n);const o=lr.dot(hr),l=cr.dot(hr);if(o<=0&&l<=0)return e.copy(n);dr.subVectors(t,r);const c=lr.dot(dr),u=cr.dot(dr);if(c>=0&&u<=c)return e.copy(r);const h=o*u-c*l;if(h<=0&&o>=0&&c<=0)return a=o/(o-c),e.copy(n).addScaledVector(lr,a);pr.subVectors(t,i);const d=lr.dot(pr),p=cr.dot(pr);if(p>=0&&d<=p)return e.copy(i);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return s=l/(l-p),e.copy(n).addScaledVector(cr,s);const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0)return ur.subVectors(i,r),s=(u-c)/(u-c+(d-p)),e.copy(r).addScaledVector(ur,s);const g=1/(m+f+h);return a=f*g,s=h*g,e.copy(n).addScaledVector(lr,a).addScaledVector(cr,s)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const _r={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},yr={h:0,s:0,l:0},xr={h:0,s:0,l:0};function br(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}class wr{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(void 0===e&&void 0===n){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Yt){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,Ie.toWorkingColorSpace(this,e),this}setRGB(t,e,n,r=Ie.workingColorSpace){return this.r=t,this.g=e,this.b=n,Ie.toWorkingColorSpace(this,r),this}setHSL(t,e,n,r=Ie.workingColorSpace){if(t=ve(t,1),e=ge(e,0,1),n=ge(n,0,1),0===e)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,i=2*n-r;this.r=br(i,r,t+1/3),this.g=br(i,r,t),this.b=br(i,r,t-1/3)}return Ie.toWorkingColorSpace(this,r),this}setStyle(t,e=Yt){function n(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(t)){let i;const a=r[1],s=r[2];switch(a){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,e);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,e);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=r[1],i=n.length;if(3===i)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(6===i)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Yt){const n=_r[t.toLowerCase()];return void 0!==n?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Le(t.r),this.g=Le(t.g),this.b=Le(t.b),this}copyLinearToSRGB(t){return this.r=De(t.r),this.g=De(t.g),this.b=De(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Yt){return Ie.fromWorkingColorSpace(Mr.copy(this),t),65536*Math.round(ge(255*Mr.r,0,255))+256*Math.round(ge(255*Mr.g,0,255))+Math.round(ge(255*Mr.b,0,255))}getHexString(t=Yt){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Ie.workingColorSpace){Ie.fromWorkingColorSpace(Mr.copy(this),e);const n=Mr.r,r=Mr.g,i=Mr.b,a=Math.max(n,r,i),s=Math.min(n,r,i);let o,l;const c=(s+a)/2;if(s===a)o=0,l=0;else{const t=a-s;switch(l=c<=.5?t/(a+s):t/(2-a-s),a){case n:o=(r-i)/t+(r<i?6:0);break;case r:o=(i-n)/t+2;break;case i:o=(n-r)/t+4}o/=6}return t.h=o,t.s=l,t.l=c,t}getRGB(t,e=Ie.workingColorSpace){return Ie.fromWorkingColorSpace(Mr.copy(this),e),t.r=Mr.r,t.g=Mr.g,t.b=Mr.b,t}getStyle(t=Yt){Ie.fromWorkingColorSpace(Mr.copy(this),t);const e=Mr.r,n=Mr.g,r=Mr.b;return t!==Yt?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*r)})`}offsetHSL(t,e,n){return this.getHSL(yr),this.setHSL(yr.h+t,yr.s+e,yr.l+n)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(yr),t.getHSL(xr);const n=_e(yr.h,xr.h,e),r=_e(yr.s,xr.s,e),i=_e(yr.l,xr.l,e);return this.setHSL(n,r,i),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,r=this.b,i=t.elements;return this.r=i[0]*e+i[3]*n+i[6]*r,this.g=i[1]*e+i[4]*n+i[7]*r,this.b=i[2]*e+i[5]*n+i[8]*r,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Mr=new wr;wr.NAMES=_r;let Tr=0;class Er extends he{static get type(){return"Material"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Tr++}),this.uuid=me(),this.name="",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=l,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new wr(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Jt,this.stencilZFail=Jt,this.stencilZPass=Jt,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const r=this[e];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n:console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};function r(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.dispersion&&(n.dispersion=this.dispersion),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(n.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapRotation&&(n.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),!0===this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=!0),204!==this.blendSrc&&(n.blendSrc=this.blendSrc),205!==this.blendDst&&(n.blendDst=this.blendDst),this.blendEquation!==l&&(n.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(n.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(n.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(n.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(n.depthFunc=this.depthFunc),!1===this.depthTest&&(n.depthTest=this.depthTest),!1===this.depthWrite&&(n.depthWrite=this.depthWrite),!1===this.colorWrite&&(n.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(n.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(n.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(n.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Jt&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Jt&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Jt&&(n.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(n.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaHash&&(n.alphaHash=!0),!0===this.alphaToCoverage&&(n.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=!0),!0===this.forceSinglePass&&(n.forceSinglePass=!0),!0===this.wireframe&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData),e){const e=r(t.textures),i=r(t.images);e.length>0&&(n.textures=e),i.length>0&&(n.images=i)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let r=0;r!==t;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class Sr extends Er{static get type(){return"MeshBasicMaterial"}constructor(t){super(),this.isMeshBasicMaterial=!0,this.color=new wr(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new zn,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Ar=Rr();function Rr(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),r=new Uint32Array(512),i=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(r[t]=0,r[256|t]=32768,i[t]=24,i[256|t]=24):e<-14?(r[t]=1024>>-e-14,r[256|t]=1024>>-e-14|32768,i[t]=-e-1,i[256|t]=-e-1):e<=15?(r[t]=e+15<<10,r[256|t]=e+15<<10|32768,i[t]=13,i[256|t]=13):e<128?(r[t]=31744,r[256|t]=64512,i[t]=24,i[256|t]=24):(r[t]=31744,r[256|t]=64512,i[t]=13,i[256|t]=13)}const a=new Uint32Array(2048),s=new Uint32Array(64),o=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,a[t]=e|n}for(let t=1024;t<2048;++t)a[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)s[t]=t<<23;s[31]=1199570944,s[32]=2147483648;for(let t=33;t<63;++t)s[t]=2147483648+(t-32<<23);s[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(o[t]=1024);return{floatView:e,uint32View:n,baseTable:r,shiftTable:i,mantissaTable:a,exponentTable:s,offsetTable:o}}const Cr={toHalfFloat:function(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=ge(t,-65504,65504),Ar.floatView[0]=t;const e=Ar.uint32View[0],n=e>>23&511;return Ar.baseTable[n]+((8388607&e)>>Ar.shiftTable[n])},fromHalfFloat:function(t){const e=t>>10;return Ar.uint32View[0]=Ar.mantissaTable[Ar.offsetTable[e]+(1023&t)]+Ar.exponentTable[e],Ar.floatView[0]}},Pr=new Qe,Ir=new Me;class Lr{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=n,this.usage=oe,this.updateRanges=[],this.gpuType=tt,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)Ir.fromBufferAttribute(this,e),Ir.applyMatrix3(t),this.setXY(e,Ir.x,Ir.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)Pr.fromBufferAttribute(this,e),Pr.applyMatrix3(t),this.setXYZ(e,Pr.x,Pr.y,Pr.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Pr.fromBufferAttribute(this,e),Pr.applyMatrix4(t),this.setXYZ(e,Pr.x,Pr.y,Pr.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Pr.fromBufferAttribute(this,e),Pr.applyNormalMatrix(t),this.setXYZ(e,Pr.x,Pr.y,Pr.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Pr.fromBufferAttribute(this,e),Pr.transformDirection(t),this.setXYZ(e,Pr.x,Pr.y,Pr.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let n=this.array[t*this.itemSize+e];return this.normalized&&(n=ye(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=xe(n,this.array)),this.array[t*this.itemSize+e]=n,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=ye(e,this.array)),e}setX(t,e){return this.normalized&&(e=xe(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=ye(e,this.array)),e}setY(t,e){return this.normalized&&(e=xe(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=ye(e,this.array)),e}setZ(t,e){return this.normalized&&(e=xe(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=ye(e,this.array)),e}setW(t,e){return this.normalized&&(e=xe(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=xe(e,this.array),n=xe(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.normalized&&(e=xe(e,this.array),n=xe(n,this.array),r=xe(r,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,i){return t*=this.itemSize,this.normalized&&(e=xe(e,this.array),n=xe(n,this.array),r=xe(r,this.array),i=xe(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=i,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==oe&&(t.usage=this.usage),t}}class Dr extends Lr{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Or extends Lr{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Nr extends Lr{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Ur=0;const Fr=new Pn,Br=new rr,kr=new Qe,zr=new nn,Hr=new nn,Gr=new Qe;class Vr extends he{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ur++}),this.uuid=me(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Se(t)?Or:Dr)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new Te).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(t),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Fr.makeRotationFromQuaternion(t),this.applyMatrix4(Fr),this}rotateX(t){return Fr.makeRotationX(t),this.applyMatrix4(Fr),this}rotateY(t){return Fr.makeRotationY(t),this.applyMatrix4(Fr),this}rotateZ(t){return Fr.makeRotationZ(t),this.applyMatrix4(Fr),this}translate(t,e,n){return Fr.makeTranslation(t,e,n),this.applyMatrix4(Fr),this}scale(t,e,n){return Fr.makeScale(t,e,n),this.applyMatrix4(Fr),this}lookAt(t){return Br.lookAt(t),Br.updateMatrix(),this.applyMatrix4(Br.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(kr).negate(),this.translate(kr.x,kr.y,kr.z),this}setFromPoints(t){const e=this.getAttribute("position");if(void 0===e){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}this.setAttribute("position",new Nr(e,3))}else{for(let n=0,r=e.count;n<r;n++){const r=t[n];e.setXYZ(n,r.x,r.y,r.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new nn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new Qe(-1/0,-1/0,-1/0),new Qe(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];zr.setFromBufferAttribute(n),this.morphTargetsRelative?(Gr.addVectors(this.boundingBox.min,zr.min),this.boundingBox.expandByPoint(Gr),Gr.addVectors(this.boundingBox.max,zr.max),this.boundingBox.expandByPoint(Gr)):(this.boundingBox.expandByPoint(zr.min),this.boundingBox.expandByPoint(zr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new bn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new Qe,1/0);if(t){const n=this.boundingSphere.center;if(zr.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Hr.setFromBufferAttribute(n),this.morphTargetsRelative?(Gr.addVectors(zr.min,Hr.min),zr.expandByPoint(Gr),Gr.addVectors(zr.max,Hr.max),zr.expandByPoint(Gr)):(zr.expandByPoint(Hr.min),zr.expandByPoint(Hr.max))}zr.getCenter(n);let r=0;for(let e=0,i=t.count;e<i;e++)Gr.fromBufferAttribute(t,e),r=Math.max(r,n.distanceToSquared(Gr));if(e)for(let i=0,a=e.length;i<a;i++){const a=e[i],s=this.morphTargetsRelative;for(let e=0,i=a.count;e<i;e++)Gr.fromBufferAttribute(a,e),s&&(kr.fromBufferAttribute(t,e),Gr.add(kr)),r=Math.max(r,n.distanceToSquared(Gr))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.position,r=e.normal,i=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Lr(new Float32Array(4*n.count),4));const a=this.getAttribute("tangent"),s=[],o=[];for(let t=0;t<n.count;t++)s[t]=new Qe,o[t]=new Qe;const l=new Qe,c=new Qe,u=new Qe,h=new Me,d=new Me,p=new Me,f=new Qe,m=new Qe;function g(t,e,r){l.fromBufferAttribute(n,t),c.fromBufferAttribute(n,e),u.fromBufferAttribute(n,r),h.fromBufferAttribute(i,t),d.fromBufferAttribute(i,e),p.fromBufferAttribute(i,r),c.sub(l),u.sub(l),d.sub(h),p.sub(h);const a=1/(d.x*p.y-p.x*d.y);isFinite(a)&&(f.copy(c).multiplyScalar(p.y).addScaledVector(u,-d.y).multiplyScalar(a),m.copy(u).multiplyScalar(d.x).addScaledVector(c,-p.x).multiplyScalar(a),s[t].add(f),s[e].add(f),s[r].add(f),o[t].add(m),o[e].add(m),o[r].add(m))}let v=this.groups;0===v.length&&(v=[{start:0,count:t.count}]);for(let e=0,n=v.length;e<n;++e){const n=v[e],r=n.start;for(let e=r,i=r+n.count;e<i;e+=3)g(t.getX(e+0),t.getX(e+1),t.getX(e+2))}const _=new Qe,y=new Qe,x=new Qe,b=new Qe;function w(t){x.fromBufferAttribute(r,t),b.copy(x);const e=s[t];_.copy(e),_.sub(x.multiplyScalar(x.dot(e))).normalize(),y.crossVectors(b,e);const n=y.dot(o[t])<0?-1:1;a.setXYZW(t,_.x,_.y,_.z,n)}for(let e=0,n=v.length;e<n;++e){const n=v[e],r=n.start;for(let e=r,i=r+n.count;e<i;e+=3)w(t.getX(e+0)),w(t.getX(e+1)),w(t.getX(e+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new Lr(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const r=new Qe,i=new Qe,a=new Qe,s=new Qe,o=new Qe,l=new Qe,c=new Qe,u=new Qe;if(t)for(let h=0,d=t.count;h<d;h+=3){const d=t.getX(h+0),p=t.getX(h+1),f=t.getX(h+2);r.fromBufferAttribute(e,d),i.fromBufferAttribute(e,p),a.fromBufferAttribute(e,f),c.subVectors(a,i),u.subVectors(r,i),c.cross(u),s.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),s.add(c),o.add(c),l.add(c),n.setXYZ(d,s.x,s.y,s.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,s=e.count;t<s;t+=3)r.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),a.fromBufferAttribute(e,t+2),c.subVectors(a,i),u.subVectors(r,i),c.cross(u),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Gr.fromBufferAttribute(t,e),Gr.normalize(),t.setXYZ(e,Gr.x,Gr.y,Gr.z)}toNonIndexed(){function t(t,e){const n=t.array,r=t.itemSize,i=t.normalized,a=new n.constructor(e.length*r);let s=0,o=0;for(let i=0,l=e.length;i<l;i++){s=t.isInterleavedBufferAttribute?e[i]*t.data.stride+t.offset:e[i]*r;for(let t=0;t<r;t++)a[o++]=n[s++]}return new Lr(a,r,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Vr,n=this.index.array,r=this.attributes;for(const i in r){const a=t(r[i],n);e.setAttribute(i,a)}const i=this.morphAttributes;for(const r in i){const a=[],s=i[r];for(let e=0,r=s.length;e<r;e++){const r=t(s[e],n);a.push(r)}e.morphAttributes[r]=a}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let t=0,n=a.length;t<n;t++){const n=a[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const r=n[e];t.data.attributes[e]=r.toJSON(t.data)}const r={};let i=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],a=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];a.push(r.toJSON(t.data))}a.length>0&&(r[e]=a,i=!0)}i&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const s=this.boundingSphere;return null!==s&&(t.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const r=t.attributes;for(const t in r){const n=r[t];this.setAttribute(t,n.clone(e))}const i=t.morphAttributes;for(const t in i){const n=[],r=i[t];for(let t=0,i=r.length;t<i;t++)n.push(r[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let t=0,e=a.length;t<e;t++){const e=a[t];this.addGroup(e.start,e.count,e.materialIndex)}const s=t.boundingBox;null!==s&&(this.boundingBox=s.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Wr=new Pn,jr=new Cn,qr=new bn,Xr=new Qe,Yr=new Qe,$r=new Qe,Kr=new Qe,Zr=new Qe,Jr=new Qe,Qr=new Qe,ti=new Qe;class ei extends rr{constructor(t=new Vr,e=new Sr){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const n=this.geometry,r=n.attributes.position,i=n.morphAttributes.position,a=n.morphTargetsRelative;e.fromBufferAttribute(r,t);const s=this.morphTargetInfluences;if(i&&s){Jr.set(0,0,0);for(let n=0,r=i.length;n<r;n++){const r=s[n],o=i[n];0!==r&&(Zr.fromBufferAttribute(o,t),a?Jr.addScaledVector(Zr,r):Jr.addScaledVector(Zr.sub(e),r))}e.add(Jr)}return e}raycast(t,e){const n=this.geometry,r=this.material,i=this.matrixWorld;if(void 0!==r){if(null===n.boundingSphere&&n.computeBoundingSphere(),qr.copy(n.boundingSphere),qr.applyMatrix4(i),jr.copy(t.ray).recast(t.near),!1===qr.containsPoint(jr.origin)){if(null===jr.intersectSphere(qr,Xr))return;if(jr.origin.distanceToSquared(Xr)>(t.far-t.near)**2)return}Wr.copy(i).invert(),jr.copy(t.ray).applyMatrix4(Wr),null!==n.boundingBox&&!1===jr.intersectsBox(n.boundingBox)||this._computeIntersections(t,e,jr)}}_computeIntersections(t,e,n){let r;const i=this.geometry,a=this.material,s=i.index,o=i.attributes.position,l=i.attributes.uv,c=i.attributes.uv1,u=i.attributes.normal,h=i.groups,d=i.drawRange;if(null!==s)if(Array.isArray(a))for(let i=0,o=h.length;i<o;i++){const o=h[i],p=a[o.materialIndex];for(let i=Math.max(o.start,d.start),a=Math.min(s.count,Math.min(o.start+o.count,d.start+d.count));i<a;i+=3)r=ni(this,p,t,n,l,c,u,s.getX(i),s.getX(i+1),s.getX(i+2)),r&&(r.faceIndex=Math.floor(i/3),r.face.materialIndex=o.materialIndex,e.push(r))}else for(let i=Math.max(0,d.start),o=Math.min(s.count,d.start+d.count);i<o;i+=3)r=ni(this,a,t,n,l,c,u,s.getX(i),s.getX(i+1),s.getX(i+2)),r&&(r.faceIndex=Math.floor(i/3),e.push(r));else if(void 0!==o)if(Array.isArray(a))for(let i=0,s=h.length;i<s;i++){const s=h[i],p=a[s.materialIndex];for(let i=Math.max(s.start,d.start),a=Math.min(o.count,Math.min(s.start+s.count,d.start+d.count));i<a;i+=3)r=ni(this,p,t,n,l,c,u,i,i+1,i+2),r&&(r.faceIndex=Math.floor(i/3),r.face.materialIndex=s.materialIndex,e.push(r))}else for(let i=Math.max(0,d.start),s=Math.min(o.count,d.start+d.count);i<s;i+=3)r=ni(this,a,t,n,l,c,u,i,i+1,i+2),r&&(r.faceIndex=Math.floor(i/3),e.push(r))}}function ni(t,e,n,r,i,a,s,o,l,c){t.getVertexPosition(o,Yr),t.getVertexPosition(l,$r),t.getVertexPosition(c,Kr);const u=function(t,e,n,r,i,a,s,o){let l;if(l=1===e.side?r.intersectTriangle(s,a,i,!0,o):r.intersectTriangle(i,a,s,0===e.side,o),null===l)return null;ti.copy(o),ti.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(ti);return c<n.near||c>n.far?null:{distance:c,point:ti.clone(),object:t}}(t,e,n,r,Yr,$r,Kr,Qr);if(u){const t=new Qe;vr.getBarycoord(Qr,Yr,$r,Kr,t),i&&(u.uv=vr.getInterpolatedAttribute(i,o,l,c,t,new Me)),a&&(u.uv1=vr.getInterpolatedAttribute(a,o,l,c,t,new Me)),s&&(u.normal=vr.getInterpolatedAttribute(s,o,l,c,t,new Qe),u.normal.dot(r.direction)>0&&u.normal.multiplyScalar(-1));const e={a:o,b:l,c,normal:new Qe,materialIndex:0};vr.getNormal(Yr,$r,Kr,e.normal),u.face=e,u.barycoord=t}return u}class ri extends Vr{constructor(t=1,e=1,n=1,r=1,i=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:i,depthSegments:a};const s=this;r=Math.floor(r),i=Math.floor(i),a=Math.floor(a);const o=[],l=[],c=[],u=[];let h=0,d=0;function p(t,e,n,r,i,a,p,f,m,g,v){const _=a/m,y=p/g,x=a/2,b=p/2,w=f/2,M=m+1,T=g+1;let E=0,S=0;const A=new Qe;for(let a=0;a<T;a++){const s=a*y-b;for(let o=0;o<M;o++){const h=o*_-x;A[t]=h*r,A[e]=s*i,A[n]=w,l.push(A.x,A.y,A.z),A[t]=0,A[e]=0,A[n]=f>0?1:-1,c.push(A.x,A.y,A.z),u.push(o/m),u.push(1-a/g),E+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=h+e+M*t,r=h+e+M*(t+1),i=h+(e+1)+M*(t+1),a=h+(e+1)+M*t;o.push(n,r,a),o.push(r,i,a),S+=6}s.addGroup(d,S,v),d+=S,h+=E}p("z","y","x",-1,-1,n,e,t,a,i,0),p("z","y","x",1,-1,n,e,-t,a,i,1),p("x","z","y",1,1,t,n,e,r,a,2),p("x","z","y",1,-1,t,n,-e,r,a,3),p("x","y","z",1,-1,t,e,n,r,i,4),p("x","y","z",-1,-1,t,e,-n,r,i,5),this.setIndex(o),this.setAttribute("position",new Nr(l,3)),this.setAttribute("normal",new Nr(c,3)),this.setAttribute("uv",new Nr(u,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ri(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function ii(t){const e={};for(const n in t){e[n]={};for(const r in t[n]){const i=t[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[n][r]=null):e[n][r]=i.clone():Array.isArray(i)?e[n][r]=i.slice():e[n][r]=i}}return e}function ai(t){const e={};for(let n=0;n<t.length;n++){const r=ii(t[n]);for(const t in r)e[t]=r[t]}return e}function si(t){const e=t.getRenderTarget();return null===e?t.outputColorSpace:!0===e.isXRRenderTarget?e.texture.colorSpace:Ie.workingColorSpace}const oi={clone:ii,merge:ai};class li extends Er{static get type(){return"ShaderMaterial"}constructor(t){super(),this.isShaderMaterial=!0,this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=ii(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?e.uniforms[n]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[n]={type:"m4",value:r.toArray()}:e.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class ci extends rr{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Pn,this.projectionMatrix=new Pn,this.projectionMatrixInverse=new Pn,this.coordinateSystem=ce}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const ui=new Qe,hi=new Me,di=new Me;class pi extends ci{constructor(t=50,e=1,n=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*fe*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*pe*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*fe*Math.atan(Math.tan(.5*pe*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,n){ui.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(ui.x,ui.y).multiplyScalar(-t/ui.z),ui.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(ui.x,ui.y).multiplyScalar(-t/ui.z)}getViewSize(t,e){return this.getViewBounds(t,hi,di),e.subVectors(di,hi)}setViewOffset(t,e,n,r,i,a){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*pe*this.fov)/this.zoom,n=2*e,r=this.aspect*n,i=-.5*r;const a=this.view;if(null!==this.view&&this.view.enabled){const t=a.fullWidth,s=a.fullHeight;i+=a.offsetX*r/t,e-=a.offsetY*n/s,r*=a.width/t,n*=a.height/s}const s=this.filmOffset;0!==s&&(i+=t*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const fi=-90;class mi extends rr{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const r=new pi(fi,1,t,e);r.layers=this.layers,this.add(r);const i=new pi(fi,1,t,e);i.layers=this.layers,this.add(i);const a=new pi(fi,1,t,e);a.layers=this.layers,this.add(a);const s=new pi(fi,1,t,e);s.layers=this.layers,this.add(s);const o=new pi(fi,1,t,e);o.layers=this.layers,this.add(o);const l=new pi(fi,1,t,e);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,r,i,a,s,o]=e;for(const t of e)this.remove(t);if(t===ce)n.up.set(0,1,0),n.lookAt(1,0,0),r.up.set(0,1,0),r.lookAt(-1,0,0),i.up.set(0,0,-1),i.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),s.up.set(0,1,0),s.lookAt(0,0,1),o.up.set(0,1,0),o.lookAt(0,0,-1);else{if(t!==ue)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);n.up.set(0,-1,0),n.lookAt(-1,0,0),r.up.set(0,-1,0),r.lookAt(1,0,0),i.up.set(0,0,1),i.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),s.up.set(0,-1,0),s.lookAt(0,0,1),o.up.set(0,-1,0),o.lookAt(0,0,-1)}for(const t of e)this.add(t),t.updateMatrixWorld()}update(t,e){null===this.parent&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:r}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[i,a,s,o,l,c]=this.children,u=t.getRenderTarget(),h=t.getActiveCubeFace(),d=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0,r),t.render(e,i),t.setRenderTarget(n,1,r),t.render(e,a),t.setRenderTarget(n,2,r),t.render(e,s),t.setRenderTarget(n,3,r),t.render(e,o),t.setRenderTarget(n,4,r),t.render(e,l),n.texture.generateMipmaps=f,t.setRenderTarget(n,5,r),t.render(e,c),t.setRenderTarget(u,h,d),t.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class gi extends je{constructor(t,e,n,r,i,a,s,o,l,c){super(t=void 0!==t?t:[],e=void 0!==e?e:N,n,r,i,a,s,o,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class vi extends Ye{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},r=[n,n,n,n,n,n];this.texture=new gi(r,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:j}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={tEquirect:{value:null}},r="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",i="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",a=new ri(5,5,5),s=new li({name:"CubemapFromEquirect",uniforms:ii(n),vertexShader:r,fragmentShader:i,side:1,blending:0});s.uniforms.tEquirect.value=e;const o=new ei(a,s),l=e.minFilter;return e.minFilter===X&&(e.minFilter=j),new mi(1,10,this).update(t,o),e.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,n,r){const i=t.getRenderTarget();for(let i=0;i<6;i++)t.setRenderTarget(this,i),t.clear(e,n,r);t.setRenderTarget(i)}}const _i=new Qe,yi=new Qe,xi=new Te;class bi{constructor(t=new Qe(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=_i.subVectors(n,e).cross(yi.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(_i),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const i=-(t.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:e.copy(t.start).addScaledVector(n,i)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||xi.getNormalMatrix(t),r=this.coplanarPoint(_i).applyMatrix4(t),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const wi=new bn,Mi=new Qe;class Ti{constructor(t=new bi,e=new bi,n=new bi,r=new bi,i=new bi,a=new bi){this.planes=[t,e,n,r,i,a]}set(t,e,n,r,i,a){const s=this.planes;return s[0].copy(t),s[1].copy(e),s[2].copy(n),s[3].copy(r),s[4].copy(i),s[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=2e3){const n=this.planes,r=t.elements,i=r[0],a=r[1],s=r[2],o=r[3],l=r[4],c=r[5],u=r[6],h=r[7],d=r[8],p=r[9],f=r[10],m=r[11],g=r[12],v=r[13],_=r[14],y=r[15];if(n[0].setComponents(o-i,h-l,m-d,y-g).normalize(),n[1].setComponents(o+i,h+l,m+d,y+g).normalize(),n[2].setComponents(o+a,h+c,m+p,y+v).normalize(),n[3].setComponents(o-a,h-c,m-p,y-v).normalize(),n[4].setComponents(o-s,h-u,m-f,y-_).normalize(),e===ce)n[5].setComponents(o+s,h+u,m+f,y+_).normalize();else{if(e!==ue)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);n[5].setComponents(s,u,f,_).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),wi.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;null===e.boundingSphere&&e.computeBoundingSphere(),wi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(wi)}intersectsSprite(t){return wi.center.set(0,0,0),wi.radius=.7071067811865476,wi.applyMatrix4(t.matrixWorld),this.intersectsSphere(wi)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if(Mi.x=r.normal.x>0?t.max.x:t.min.x,Mi.y=r.normal.y>0?t.max.y:t.min.y,Mi.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(Mi)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Ei(){let t=null,e=!1,n=null,r=null;function i(e,a){n(e,a),r=t.requestAnimationFrame(i)}return{start:function(){!0!==e&&null!==n&&(r=t.requestAnimationFrame(i),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Si(t){const e=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),e.get(t)},remove:function(n){n.isInterleavedBufferAttribute&&(n=n.data);const r=e.get(n);r&&(t.deleteBuffer(r.buffer),e.delete(n))},update:function(n,r){if(n.isInterleavedBufferAttribute&&(n=n.data),n.isGLBufferAttribute){const t=e.get(n);return void((!t||t.version<n.version)&&e.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version}))}const i=e.get(n);if(void 0===i)e.set(n,function(e,n){const r=e.array,i=e.usage,a=r.byteLength,s=t.createBuffer();let o;if(t.bindBuffer(n,s),t.bufferData(n,r,i),e.onUploadCallback(),r instanceof Float32Array)o=t.FLOAT;else if(r instanceof Uint16Array)o=e.isFloat16BufferAttribute?t.HALF_FLOAT:t.UNSIGNED_SHORT;else if(r instanceof Int16Array)o=t.SHORT;else if(r instanceof Uint32Array)o=t.UNSIGNED_INT;else if(r instanceof Int32Array)o=t.INT;else if(r instanceof Int8Array)o=t.BYTE;else if(r instanceof Uint8Array)o=t.UNSIGNED_BYTE;else{if(!(r instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+r);o=t.UNSIGNED_BYTE}return{buffer:s,type:o,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version,size:a}}(n,r));else if(i.version<n.version){if(i.size!==n.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(e,n,r){const i=n.array,a=n.updateRanges;if(t.bindBuffer(r,e),0===a.length)t.bufferSubData(r,0,i);else{a.sort(((t,e)=>t.start-e.start));let e=0;for(let t=1;t<a.length;t++){const n=a[e],r=a[t];r.start<=n.start+n.count+1?n.count=Math.max(n.count,r.start+r.count-n.start):(++e,a[e]=r)}a.length=e+1;for(let e=0,n=a.length;e<n;e++){const n=a[e];t.bufferSubData(r,n.start*i.BYTES_PER_ELEMENT,i,n.start,n.count)}n.clearUpdateRanges()}n.onUploadCallback()}(i.buffer,n,r),i.version=n.version}}}}class Ai extends Vr{constructor(t=1,e=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const i=t/2,a=e/2,s=Math.floor(n),o=Math.floor(r),l=s+1,c=o+1,u=t/s,h=e/o,d=[],p=[],f=[],m=[];for(let t=0;t<c;t++){const e=t*h-a;for(let n=0;n<l;n++){const r=n*u-i;p.push(r,-e,0),f.push(0,0,1),m.push(n/s),m.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<s;e++){const n=e+l*t,r=e+l*(t+1),i=e+1+l*(t+1),a=e+1+l*t;d.push(n,r,a),d.push(r,i,a)}this.setIndex(d),this.setAttribute("position",new Nr(p,3)),this.setAttribute("normal",new Nr(f,3)),this.setAttribute("uv",new Nr(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ai(t.width,t.height,t.widthSegments,t.heightSegments)}}const Ri={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphinstance_vertex:"#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},Ci={common:{diffuse:{value:new wr(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Te},alphaMap:{value:null},alphaMapTransform:{value:new Te},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Te}},envmap:{envMap:{value:null},envMapRotation:{value:new Te},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Te}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Te}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Te},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Te},normalScale:{value:new Me(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Te},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Te}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Te}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Te}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new wr(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new wr(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Te},alphaTest:{value:0},uvTransform:{value:new Te}},sprite:{diffuse:{value:new wr(16777215)},opacity:{value:1},center:{value:new Me(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Te},alphaMap:{value:null},alphaMapTransform:{value:new Te},alphaTest:{value:0}}},Pi={basic:{uniforms:ai([Ci.common,Ci.specularmap,Ci.envmap,Ci.aomap,Ci.lightmap,Ci.fog]),vertexShader:Ri.meshbasic_vert,fragmentShader:Ri.meshbasic_frag},lambert:{uniforms:ai([Ci.common,Ci.specularmap,Ci.envmap,Ci.aomap,Ci.lightmap,Ci.emissivemap,Ci.bumpmap,Ci.normalmap,Ci.displacementmap,Ci.fog,Ci.lights,{emissive:{value:new wr(0)}}]),vertexShader:Ri.meshlambert_vert,fragmentShader:Ri.meshlambert_frag},phong:{uniforms:ai([Ci.common,Ci.specularmap,Ci.envmap,Ci.aomap,Ci.lightmap,Ci.emissivemap,Ci.bumpmap,Ci.normalmap,Ci.displacementmap,Ci.fog,Ci.lights,{emissive:{value:new wr(0)},specular:{value:new wr(1118481)},shininess:{value:30}}]),vertexShader:Ri.meshphong_vert,fragmentShader:Ri.meshphong_frag},standard:{uniforms:ai([Ci.common,Ci.envmap,Ci.aomap,Ci.lightmap,Ci.emissivemap,Ci.bumpmap,Ci.normalmap,Ci.displacementmap,Ci.roughnessmap,Ci.metalnessmap,Ci.fog,Ci.lights,{emissive:{value:new wr(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ri.meshphysical_vert,fragmentShader:Ri.meshphysical_frag},toon:{uniforms:ai([Ci.common,Ci.aomap,Ci.lightmap,Ci.emissivemap,Ci.bumpmap,Ci.normalmap,Ci.displacementmap,Ci.gradientmap,Ci.fog,Ci.lights,{emissive:{value:new wr(0)}}]),vertexShader:Ri.meshtoon_vert,fragmentShader:Ri.meshtoon_frag},matcap:{uniforms:ai([Ci.common,Ci.bumpmap,Ci.normalmap,Ci.displacementmap,Ci.fog,{matcap:{value:null}}]),vertexShader:Ri.meshmatcap_vert,fragmentShader:Ri.meshmatcap_frag},points:{uniforms:ai([Ci.points,Ci.fog]),vertexShader:Ri.points_vert,fragmentShader:Ri.points_frag},dashed:{uniforms:ai([Ci.common,Ci.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ri.linedashed_vert,fragmentShader:Ri.linedashed_frag},depth:{uniforms:ai([Ci.common,Ci.displacementmap]),vertexShader:Ri.depth_vert,fragmentShader:Ri.depth_frag},normal:{uniforms:ai([Ci.common,Ci.bumpmap,Ci.normalmap,Ci.displacementmap,{opacity:{value:1}}]),vertexShader:Ri.meshnormal_vert,fragmentShader:Ri.meshnormal_frag},sprite:{uniforms:ai([Ci.sprite,Ci.fog]),vertexShader:Ri.sprite_vert,fragmentShader:Ri.sprite_frag},background:{uniforms:{uvTransform:{value:new Te},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Ri.background_vert,fragmentShader:Ri.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Te}},vertexShader:Ri.backgroundCube_vert,fragmentShader:Ri.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Ri.cube_vert,fragmentShader:Ri.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ri.equirect_vert,fragmentShader:Ri.equirect_frag},distanceRGBA:{uniforms:ai([Ci.common,Ci.displacementmap,{referencePosition:{value:new Qe},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ri.distanceRGBA_vert,fragmentShader:Ri.distanceRGBA_frag},shadow:{uniforms:ai([Ci.lights,Ci.fog,{color:{value:new wr(0)},opacity:{value:1}}]),vertexShader:Ri.shadow_vert,fragmentShader:Ri.shadow_frag}};Pi.physical={uniforms:ai([Pi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Te},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Te},clearcoatNormalScale:{value:new Me(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Te},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Te},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Te},sheen:{value:0},sheenColor:{value:new wr(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Te},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Te},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Te},transmissionSamplerSize:{value:new Me},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Te},attenuationDistance:{value:0},attenuationColor:{value:new wr(0)},specularColor:{value:new wr(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Te},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Te},anisotropyVector:{value:new Me},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Te}}]),vertexShader:Ri.meshphysical_vert,fragmentShader:Ri.meshphysical_frag};const Ii={r:0,b:0,g:0},Li=new zn,Di=new Pn;function Oi(t,e,n,r,i,a,s){const o=new wr(0);let l,c,u=!0===a?0:1,h=null,d=0,p=null;function f(t){let r=!0===t.isScene?t.background:null;return r&&r.isTexture&&(r=(t.backgroundBlurriness>0?n:e).get(r)),r}function m(e,n){e.getRGB(Ii,si(t)),r.buffers.color.setClear(Ii.r,Ii.g,Ii.b,n,s)}return{getClearColor:function(){return o},setClearColor:function(t,e=1){o.set(t),u=e,m(o,u)},getClearAlpha:function(){return u},setClearAlpha:function(t){u=t,m(o,u)},render:function(e){let n=!1;const i=f(e);null===i?m(o,u):i&&i.isColor&&(m(i,1),n=!0);const a=t.xr.getEnvironmentBlendMode();"additive"===a?r.buffers.color.setClear(0,0,0,1,s):"alpha-blend"===a&&r.buffers.color.setClear(0,0,0,0,s),(t.autoClear||n)&&(r.buffers.depth.setTest(!0),r.buffers.depth.setMask(!0),r.buffers.color.setMask(!0),t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil))},addToRenderList:function(e,n){const r=f(n);r&&(r.isCubeTexture||r.mapping===B)?(void 0===c&&(c=new ei(new ri(1,1,1),new li({name:"BackgroundCubeMaterial",uniforms:ii(Pi.backgroundCube.uniforms),vertexShader:Pi.backgroundCube.vertexShader,fragmentShader:Pi.backgroundCube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),Li.copy(n.backgroundRotation),Li.x*=-1,Li.y*=-1,Li.z*=-1,r.isCubeTexture&&!1===r.isRenderTargetTexture&&(Li.y*=-1,Li.z*=-1),c.material.uniforms.envMap.value=r,c.material.uniforms.flipEnvMap.value=r.isCubeTexture&&!1===r.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=n.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,c.material.uniforms.backgroundRotation.value.setFromMatrix4(Di.makeRotationFromEuler(Li)),c.material.toneMapped=Ie.getTransfer(r.colorSpace)!==Zt,h===r&&d===r.version&&p===t.toneMapping||(c.material.needsUpdate=!0,h=r,d=r.version,p=t.toneMapping),c.layers.enableAll(),e.unshift(c,c.geometry,c.material,0,0,null)):r&&r.isTexture&&(void 0===l&&(l=new ei(new Ai(2,2),new li({name:"BackgroundMaterial",uniforms:ii(Pi.background.uniforms),vertexShader:Pi.background.vertexShader,fragmentShader:Pi.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=r,l.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,l.material.toneMapped=Ie.getTransfer(r.colorSpace)!==Zt,!0===r.matrixAutoUpdate&&r.updateMatrix(),l.material.uniforms.uvTransform.value.copy(r.matrix),h===r&&d===r.version&&p===t.toneMapping||(l.material.needsUpdate=!0,h=r,d=r.version,p=t.toneMapping),l.layers.enableAll(),e.unshift(l,l.geometry,l.material,0,0,null))}}}function Ni(t,e){const n=t.getParameter(t.MAX_VERTEX_ATTRIBS),r={},i=c(null);let a=i,s=!1;function o(e){return t.bindVertexArray(e)}function l(e){return t.deleteVertexArray(e)}function c(t){const e=[],r=[],i=[];for(let t=0;t<n;t++)e[t]=0,r[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:r,attributeDivisors:i,object:t,attributes:{},index:null}}function u(){const t=a.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function h(t){d(t,0)}function d(e,n){const r=a.newAttributes,i=a.enabledAttributes,s=a.attributeDivisors;r[e]=1,0===i[e]&&(t.enableVertexAttribArray(e),i[e]=1),s[e]!==n&&(t.vertexAttribDivisor(e,n),s[e]=n)}function p(){const e=a.newAttributes,n=a.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==e[r]&&(t.disableVertexAttribArray(r),n[r]=0)}function f(e,n,r,i,a,s,o){!0===o?t.vertexAttribIPointer(e,n,r,a,s):t.vertexAttribPointer(e,n,r,i,a,s)}function m(){g(),s=!0,a!==i&&(a=i,o(a.object))}function g(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:function(n,i,l,m,g){let v=!1;const _=function(e,n,i){const a=!0===i.wireframe;let s=r[e.id];void 0===s&&(s={},r[e.id]=s);let o=s[n.id];void 0===o&&(o={},s[n.id]=o);let l=o[a];return void 0===l&&(l=c(t.createVertexArray()),o[a]=l),l}(m,l,i);a!==_&&(a=_,o(a.object)),v=function(t,e,n,r){const i=a.attributes,s=e.attributes;let o=0;const l=n.getAttributes();for(const e in l)if(l[e].location>=0){const n=i[e];let r=s[e];if(void 0===r&&("instanceMatrix"===e&&t.instanceMatrix&&(r=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(r=t.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;o++}return a.attributesNum!==o||a.index!==r}(n,m,l,g),v&&function(t,e,n,r){const i={},s=e.attributes;let o=0;const l=n.getAttributes();for(const e in l)if(l[e].location>=0){let n=s[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[e]=r,o++}a.attributes=i,a.attributesNum=o,a.index=r}(n,m,l,g),null!==g&&e.update(g,t.ELEMENT_ARRAY_BUFFER),(v||s)&&(s=!1,function(n,r,i,a){u();const s=a.attributes,o=i.getAttributes(),l=r.defaultAttributeValues;for(const r in o){const i=o[r];if(i.location>=0){let o=s[r];if(void 0===o&&("instanceMatrix"===r&&n.instanceMatrix&&(o=n.instanceMatrix),"instanceColor"===r&&n.instanceColor&&(o=n.instanceColor)),void 0!==o){const r=o.normalized,s=o.itemSize,l=e.get(o);if(void 0===l)continue;const c=l.buffer,u=l.type,p=l.bytesPerElement,m=u===t.INT||u===t.UNSIGNED_INT||o.gpuType===J;if(o.isInterleavedBufferAttribute){const e=o.data,l=e.stride,g=o.offset;if(e.isInstancedInterleavedBuffer){for(let t=0;t<i.locationSize;t++)d(i.location+t,e.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=e.meshPerAttribute*e.count)}else for(let t=0;t<i.locationSize;t++)h(i.location+t);t.bindBuffer(t.ARRAY_BUFFER,c);for(let t=0;t<i.locationSize;t++)f(i.location+t,s/i.locationSize,u,r,l*p,(g+s/i.locationSize*t)*p,m)}else{if(o.isInstancedBufferAttribute){for(let t=0;t<i.locationSize;t++)d(i.location+t,o.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=o.meshPerAttribute*o.count)}else for(let t=0;t<i.locationSize;t++)h(i.location+t);t.bindBuffer(t.ARRAY_BUFFER,c);for(let t=0;t<i.locationSize;t++)f(i.location+t,s/i.locationSize,u,r,s*p,s/i.locationSize*t*p,m)}}else if(void 0!==l){const e=l[r];if(void 0!==e)switch(e.length){case 2:t.vertexAttrib2fv(i.location,e);break;case 3:t.vertexAttrib3fv(i.location,e);break;case 4:t.vertexAttrib4fv(i.location,e);break;default:t.vertexAttrib1fv(i.location,e)}}}}p()}(n,i,l,m),null!==g&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.get(g).buffer))},reset:m,resetDefaultState:g,dispose:function(){m();for(const t in r){const e=r[t];for(const t in e){const n=e[t];for(const t in n)l(n[t].object),delete n[t];delete e[t]}delete r[t]}},releaseStatesOfGeometry:function(t){if(void 0===r[t.id])return;const e=r[t.id];for(const t in e){const n=e[t];for(const t in n)l(n[t].object),delete n[t];delete e[t]}delete r[t.id]},releaseStatesOfProgram:function(t){for(const e in r){const n=r[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)l(i[t].object),delete i[t];delete n[t.id]}},initAttributes:u,enableAttribute:h,disableUnusedAttributes:p}}function Ui(t,e,n){let r;function i(e,i,a){0!==a&&(t.drawArraysInstanced(r,e,i,a),n.update(i,r,a))}this.setMode=function(t){r=t},this.render=function(e,i){t.drawArrays(r,e,i),n.update(i,r,1)},this.renderInstances=i,this.renderMultiDraw=function(t,i,a){if(0===a)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r,t,0,i,0,a);let s=0;for(let t=0;t<a;t++)s+=i[t];n.update(s,r,1)},this.renderMultiDrawInstances=function(t,a,s,o){if(0===s)return;const l=e.get("WEBGL_multi_draw");if(null===l)for(let e=0;e<t.length;e++)i(t[e],a[e],o[e]);else{l.multiDrawArraysInstancedWEBGL(r,t,0,a,0,o,0,s);let e=0;for(let t=0;t<s;t++)e+=a[t]*o[t];n.update(e,r,1)}}}function Fi(t,e,n,r){let i;function a(e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let s=void 0!==n.precision?n.precision:"highp";const o=a(s);o!==s&&(console.warn("THREE.WebGLRenderer:",s,"not supported, using",o,"instead."),s=o);const l=!0===n.logarithmicDepthBuffer,c=!0===n.reverseDepthBuffer&&e.has("EXT_clip_control"),u=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),h=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:a,textureFormatReadable:function(e){return e===at||r.convert(e)===t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(n){const i=n===et&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(n!==Y&&r.convert(n)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE)&&n!==tt&&!i)},precision:s,logarithmicDepthBuffer:l,reverseDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:t.getParameter(t.MAX_TEXTURE_SIZE),maxCubemapSize:t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:t.getParameter(t.MAX_VERTEX_ATTRIBS),maxVertexUniforms:t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:t.getParameter(t.MAX_VARYING_VECTORS),maxFragmentUniforms:t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:h>0,maxSamples:t.getParameter(t.MAX_SAMPLES)}}function Bi(t){const e=this;let n=null,r=0,i=!1,a=!1;const s=new bi,o=new Te,l={value:null,needsUpdate:!1};function c(t,n,r,i){const a=null!==t?t.length:0;let c=null;if(0!==a){if(c=l.value,!0!==i||null===c){const e=r+4*a,i=n.matrixWorldInverse;o.getNormalMatrix(i),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=r;e!==a;++e,n+=4)s.copy(t[e]).applyMatrix4(i,o),s.normal.toArray(c,n),c[n+3]=s.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=a,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e){const n=0!==t.length||e||0!==r||i;return i=e,r=t.length,n},this.beginShadows=function(){a=!0,c(null)},this.endShadows=function(){a=!1},this.setGlobalState=function(t,e){n=c(t,e,0)},this.setState=function(s,o,u){const h=s.clippingPlanes,d=s.clipIntersection,p=s.clipShadows,f=t.get(s);if(!i||null===h||0===h.length||a&&!p)a?c(null):(l.value!==n&&(l.value=n,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0);else{const t=a?0:r,e=4*t;let i=f.clippingState||null;l.value=i,i=c(h,o,e,u);for(let t=0;t!==e;++t)i[t]=n[t];f.clippingState=i,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function ki(t){let e=new WeakMap;function n(t,e){return e===F?t.mapping=N:304===e&&(t.mapping=U),t}function r(t){const n=t.target;n.removeEventListener("dispose",r);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const a=i.mapping;if(a===F||304===a){if(e.has(i))return n(e.get(i).texture,i.mapping);{const a=i.image;if(a&&a.height>0){const s=new vi(a.height);return s.fromEquirectangularTexture(t,i),e.set(i,s),i.addEventListener("dispose",r),n(s.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}class zi extends ci{constructor(t=-1,e=1,n=1,r=-1,i=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=i,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,r,i,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-t,a=n+t,s=r+e,o=r-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=t*this.view.offsetX,a=i+t*this.view.width,s-=e*this.view.offsetY,o=s-e*this.view.height}this.projectionMatrix.makeOrthographic(i,a,s,o,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}const Hi=[.125,.215,.35,.446,.526,.582],Gi=new zi,Vi=new wr;let Wi=null,ji=0,qi=0,Xi=!1;const Yi=(1+Math.sqrt(5))/2,$i=1/Yi,Ki=[new Qe(-Yi,$i,0),new Qe(Yi,$i,0),new Qe(-$i,0,Yi),new Qe($i,0,Yi),new Qe(0,Yi,-$i),new Qe(0,Yi,$i),new Qe(-1,1,-1),new Qe(1,1,-1),new Qe(-1,1,1),new Qe(1,1,1)];class Zi{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,r=100){Wi=this._renderer.getRenderTarget(),ji=this._renderer.getActiveCubeFace(),qi=this._renderer.getActiveMipmapLevel(),Xi=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(t,n,r,i),e>0&&this._blur(i,0,0,e),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=ea(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=ta(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Wi,ji,qi),this._renderer.xr.enabled=Xi,t.scissorTest=!1,Qi(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===N||t.mapping===U?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Wi=this._renderer.getRenderTarget(),ji=this._renderer.getActiveCubeFace(),qi=this._renderer.getActiveMipmapLevel(),Xi=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:j,minFilter:j,generateMipmaps:!1,type:et,format:at,colorSpace:$t,depthBuffer:!1},r=Ji(t,e,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Ji(t,e,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const e=[],n=[],r=[];let i=t;const a=t-4+1+Hi.length;for(let s=0;s<a;s++){const a=Math.pow(2,i);n.push(a);let o=1/a;s>t-4?o=Hi[s-t+4-1]:0===s&&(o=0),r.push(o);const l=1/(a-2),c=-l,u=1+l,h=[c,c,u,c,u,u,c,c,u,u,c,u],d=6,p=6,f=3,m=2,g=1,v=new Float32Array(f*p*d),_=new Float32Array(m*p*d),y=new Float32Array(g*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,n=t>2?0:-1,r=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];v.set(r,f*p*t),_.set(h,m*p*t);const i=[t,t,t,t,t,t];y.set(i,g*p*t)}const x=new Vr;x.setAttribute("position",new Lr(v,f)),x.setAttribute("uv",new Lr(_,m)),x.setAttribute("faceIndex",new Lr(y,g)),e.push(x),i>4&&i--}return{lodPlanes:e,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(t,e,n){const r=new Float32Array(20),i=new Qe(0,1,0);return new li({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(r,t,e)}return r}_compileMaterial(t){const e=new ei(this._lodPlanes[0],t);this._renderer.compile(e,Gi)}_sceneToCubeUV(t,e,n,r){const i=new pi(90,1,e,n),a=[1,-1,1,1,1,1],s=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,c=o.toneMapping;o.getClearColor(Vi),o.toneMapping=0,o.autoClear=!1;const u=new Sr({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),h=new ei(new ri,u);let d=!1;const p=t.background;p?p.isColor&&(u.color.copy(p),t.background=null,d=!0):(u.color.copy(Vi),d=!0);for(let e=0;e<6;e++){const n=e%3;0===n?(i.up.set(0,a[e],0),i.lookAt(s[e],0,0)):1===n?(i.up.set(0,0,a[e]),i.lookAt(0,s[e],0)):(i.up.set(0,a[e],0),i.lookAt(0,0,s[e]));const l=this._cubeSize;Qi(r,n*l,e>2?l:0,l,l),o.setRenderTarget(r),d&&o.render(h,i),o.render(t,i)}h.geometry.dispose(),h.material.dispose(),o.toneMapping=c,o.autoClear=l,t.background=p}_textureToCubeUV(t,e){const n=this._renderer,r=t.mapping===N||t.mapping===U;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=ea()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=ta());const i=r?this._cubemapMaterial:this._equirectMaterial,a=new ei(this._lodPlanes[0],i);i.uniforms.envMap.value=t;const s=this._cubeSize;Qi(e,0,0,3*s,2*s),n.setRenderTarget(e),n.render(a,Gi)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;const r=this._lodPlanes.length;for(let e=1;e<r;e++){const n=Math.sqrt(this._sigmas[e]*this._sigmas[e]-this._sigmas[e-1]*this._sigmas[e-1]),i=Ki[(r-e-1)%Ki.length];this._blur(t,e-1,e,n,i)}e.autoClear=n}_blur(t,e,n,r,i){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,r,"latitudinal",i),this._halfBlur(a,t,n,n,r,"longitudinal",i)}_halfBlur(t,e,n,r,i,a,s){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new ei(this._lodPlanes[r],l),u=l.uniforms,h=this._sizeLods[n]-1,d=isFinite(i)?Math.PI/(2*h):2*Math.PI/39,p=i/d,f=isFinite(i)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<20;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0===t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;u.envMap.value=t.texture,u.samples.value=f,u.weights.value=m,u.latitudinal.value="latitudinal"===a,s&&(u.poleAxis.value=s);const{_lodMax:v}=this;u.dTheta.value=d,u.mipInt.value=v-n;const _=this._sizeLods[r];Qi(e,3*_*(r>v-4?r-v+4:0),4*(this._cubeSize-_),3*_,2*_),o.setRenderTarget(e),o.render(c,Gi)}}function Ji(t,e,n){const r=new Ye(t,e,n);return r.texture.mapping=B,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function Qi(t,e,n,r,i){t.viewport.set(e,n,r,i),t.scissor.set(e,n,r,i)}function ta(){return new li({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function ea(){return new li({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function na(t){let e=new WeakMap,n=null;function r(t){const n=t.target;n.removeEventListener("dispose",r);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const a=i.mapping,s=a===F||304===a,o=a===N||a===U;if(s||o){let a=e.get(i);const l=void 0!==a?a.texture.pmremVersion:0;if(i.isRenderTargetTexture&&i.pmremVersion!==l)return null===n&&(n=new Zi(t)),a=s?n.fromEquirectangular(i,a):n.fromCubemap(i,a),a.texture.pmremVersion=i.pmremVersion,e.set(i,a),a.texture;if(void 0!==a)return a.texture;{const l=i.image;return s&&l&&l.height>0||o&&l&&function(t){let e=0;for(let n=0;n<6;n++)void 0!==t[n]&&e++;return 6===e}(l)?(null===n&&(n=new Zi(t)),a=s?n.fromEquirectangular(i):n.fromCubemap(i),a.texture.pmremVersion=i.pmremVersion,e.set(i,a),i.addEventListener("dispose",r),a.texture):null}}}return i},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function ra(t){const e={};function n(n){if(void 0!==e[n])return e[n];let r;switch(n){case"WEBGL_depth_texture":r=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=t.getExtension(n)}return e[n]=r,r}return{has:function(t){return null!==n(t)},init:function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")},get:function(t){const e=n(t);return null===e&&Pe("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function ia(t,e,n,r){const i={},a=new WeakMap;function s(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);for(const t in o.morphAttributes){const n=o.morphAttributes[t];for(let t=0,r=n.length;t<r;t++)e.remove(n[t])}o.removeEventListener("dispose",s),delete i[o.id];const l=a.get(o);l&&(e.remove(l),a.delete(o)),r.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],r=t.index,i=t.attributes.position;let s=0;if(null!==r){const t=r.array;s=r.version;for(let e=0,r=t.length;e<r;e+=3){const r=t[e+0],i=t[e+1],a=t[e+2];n.push(r,i,i,a,a,r)}}else{if(void 0===i)return;{const t=i.array;s=i.version;for(let e=0,r=t.length/3-1;e<r;e+=3){const t=e+0,r=e+1,i=e+2;n.push(t,r,r,i,i,t)}}}const o=new(Se(n)?Or:Dr)(n,1);o.version=s;const l=a.get(t);l&&e.remove(l),a.set(t,o)}return{get:function(t,e){return!0===i[e.id]||(e.addEventListener("dispose",s),i[e.id]=!0,n.memory.geometries++),e},update:function(n){const r=n.attributes;for(const n in r)e.update(r[n],t.ARRAY_BUFFER);const i=n.morphAttributes;for(const n in i){const r=i[n];for(let n=0,i=r.length;n<i;n++)e.update(r[n],t.ARRAY_BUFFER)}},getWireframeAttribute:function(t){const e=a.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return a.get(t)}}}function aa(t,e,n){let r,i,a;function s(e,s,o){0!==o&&(t.drawElementsInstanced(r,s,i,e*a,o),n.update(s,r,o))}this.setMode=function(t){r=t},this.setIndex=function(t){i=t.type,a=t.bytesPerElement},this.render=function(e,s){t.drawElements(r,s,i,e*a),n.update(s,r,1)},this.renderInstances=s,this.renderMultiDraw=function(t,a,s){if(0===s)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r,a,0,i,t,0,s);let o=0;for(let t=0;t<s;t++)o+=a[t];n.update(o,r,1)},this.renderMultiDrawInstances=function(t,o,l,c){if(0===l)return;const u=e.get("WEBGL_multi_draw");if(null===u)for(let e=0;e<t.length;e++)s(t[e]/a,o[e],c[e]);else{u.multiDrawElementsInstancedWEBGL(r,o,0,i,t,0,c,0,l);let e=0;for(let t=0;t<l;t++)e+=o[t]*c[t];n.update(e,r,1)}}}function sa(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,r,i){switch(e.calls++,r){case t.TRIANGLES:e.triangles+=i*(n/3);break;case t.LINES:e.lines+=i*(n/2);break;case t.LINE_STRIP:e.lines+=i*(n-1);break;case t.LINE_LOOP:e.lines+=i*n;break;case t.POINTS:e.points+=i*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}}}function oa(t,e,n){const r=new WeakMap,i=new qe;return{update:function(a,s,o){const l=a.morphTargetInfluences,c=s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color,u=void 0!==c?c.length:0;let h=r.get(s);if(void 0===h||h.count!==u){void 0!==h&&h.texture.dispose();const d=void 0!==s.morphAttributes.position,p=void 0!==s.morphAttributes.normal,f=void 0!==s.morphAttributes.color,m=s.morphAttributes.position||[],g=s.morphAttributes.normal||[],v=s.morphAttributes.color||[];let _=0;!0===d&&(_=1),!0===p&&(_=2),!0===f&&(_=3);let y=s.attributes.position.count*_,x=1;y>e.maxTextureSize&&(x=Math.ceil(y/e.maxTextureSize),y=e.maxTextureSize);const b=new Float32Array(y*x*4*u),w=new $e(b,y,x,u);w.type=tt,w.needsUpdate=!0;const M=4*_;for(let E=0;E<u;E++){const S=m[E],A=g[E],R=v[E],C=y*x*4*E;for(let P=0;P<S.count;P++){const I=P*M;!0===d&&(i.fromBufferAttribute(S,P),b[C+I+0]=i.x,b[C+I+1]=i.y,b[C+I+2]=i.z,b[C+I+3]=0),!0===p&&(i.fromBufferAttribute(A,P),b[C+I+4]=i.x,b[C+I+5]=i.y,b[C+I+6]=i.z,b[C+I+7]=0),!0===f&&(i.fromBufferAttribute(R,P),b[C+I+8]=i.x,b[C+I+9]=i.y,b[C+I+10]=i.z,b[C+I+11]=4===R.itemSize?i.w:1)}}function T(){w.dispose(),r.delete(s),s.removeEventListener("dispose",T)}h={count:u,texture:w,size:new Me(y,x)},r.set(s,h),s.addEventListener("dispose",T)}if(!0===a.isInstancedMesh&&null!==a.morphTexture)o.getUniforms().setValue(t,"morphTexture",a.morphTexture,n);else{let L=0;for(let O=0;O<l.length;O++)L+=l[O];const D=s.morphTargetsRelative?1:1-L;o.getUniforms().setValue(t,"morphTargetBaseInfluence",D),o.getUniforms().setValue(t,"morphTargetInfluences",l)}o.getUniforms().setValue(t,"morphTargetsTexture",h.texture,n),o.getUniforms().setValue(t,"morphTargetsTextureSize",h.size)}}}function la(t,e,n,r){let i=new WeakMap;function a(t){const e=t.target;e.removeEventListener("dispose",a),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(s){const o=r.render.frame,l=s.geometry,c=e.get(s,l);if(i.get(c)!==o&&(e.update(c),i.set(c,o)),s.isInstancedMesh&&(!1===s.hasEventListener("dispose",a)&&s.addEventListener("dispose",a),i.get(s)!==o&&(n.update(s.instanceMatrix,t.ARRAY_BUFFER),null!==s.instanceColor&&n.update(s.instanceColor,t.ARRAY_BUFFER),i.set(s,o))),s.isSkinnedMesh){const t=s.skeleton;i.get(t)!==o&&(t.update(),i.set(t,o))}return c},dispose:function(){i=new WeakMap}}}class ca extends je{constructor(t,e,n,r,i,a,s,o,l,c=1026){if(c!==st&&c!==ot)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===st&&(n=Q),void 0===n&&c===ot&&(n=it),super(null,r,i,a,s,o,c,n,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==s?s:G,this.minFilter=void 0!==o?o:G,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}const ua=new je,ha=new ca(1,1),da=new $e,pa=new Ze,fa=new gi,ma=[],ga=[],va=new Float32Array(16),_a=new Float32Array(9),ya=new Float32Array(4);function xa(t,e,n){const r=t[0];if(r<=0||r>0)return t;const i=e*n;let a=ma[i];if(void 0===a&&(a=new Float32Array(i),ma[i]=a),0!==e){r.toArray(a,0);for(let r=1,i=0;r!==e;++r)i+=n,t[r].toArray(a,i)}return a}function ba(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}function wa(t,e){for(let n=0,r=e.length;n<r;n++)t[n]=e[n]}function Ma(t,e){let n=ga[e];void 0===n&&(n=new Int32Array(e),ga[e]=n);for(let r=0;r!==e;++r)n[r]=t.allocateTextureUnit();return n}function Ta(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Ea(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(ba(n,e))return;t.uniform2fv(this.addr,e),wa(n,e)}}function Sa(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(ba(n,e))return;t.uniform3fv(this.addr,e),wa(n,e)}}function Aa(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(ba(n,e))return;t.uniform4fv(this.addr,e),wa(n,e)}}function Ra(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(ba(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),wa(n,e)}else{if(ba(n,r))return;ya.set(r),t.uniformMatrix2fv(this.addr,!1,ya),wa(n,r)}}function Ca(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(ba(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),wa(n,e)}else{if(ba(n,r))return;_a.set(r),t.uniformMatrix3fv(this.addr,!1,_a),wa(n,r)}}function Pa(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(ba(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),wa(n,e)}else{if(ba(n,r))return;va.set(r),t.uniformMatrix4fv(this.addr,!1,va),wa(n,r)}}function Ia(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function La(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(ba(n,e))return;t.uniform2iv(this.addr,e),wa(n,e)}}function Da(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(ba(n,e))return;t.uniform3iv(this.addr,e),wa(n,e)}}function Oa(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(ba(n,e))return;t.uniform4iv(this.addr,e),wa(n,e)}}function Na(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Ua(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(ba(n,e))return;t.uniform2uiv(this.addr,e),wa(n,e)}}function Fa(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(ba(n,e))return;t.uniform3uiv(this.addr,e),wa(n,e)}}function Ba(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(ba(n,e))return;t.uniform4uiv(this.addr,e),wa(n,e)}}function ka(t,e,n){const r=this.cache,i=n.allocateTextureUnit();let a;r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),this.type===t.SAMPLER_2D_SHADOW?(ha.compareFunction=515,a=ha):a=ua,n.setTexture2D(e||a,i)}function za(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(e||pa,i)}function Ha(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(e||fa,i)}function Ga(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(e||da,i)}function Va(t,e){t.uniform1fv(this.addr,e)}function Wa(t,e){const n=xa(e,this.size,2);t.uniform2fv(this.addr,n)}function ja(t,e){const n=xa(e,this.size,3);t.uniform3fv(this.addr,n)}function qa(t,e){const n=xa(e,this.size,4);t.uniform4fv(this.addr,n)}function Xa(t,e){const n=xa(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function Ya(t,e){const n=xa(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function $a(t,e){const n=xa(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function Ka(t,e){t.uniform1iv(this.addr,e)}function Za(t,e){t.uniform2iv(this.addr,e)}function Ja(t,e){t.uniform3iv(this.addr,e)}function Qa(t,e){t.uniform4iv(this.addr,e)}function ts(t,e){t.uniform1uiv(this.addr,e)}function es(t,e){t.uniform2uiv(this.addr,e)}function ns(t,e){t.uniform3uiv(this.addr,e)}function rs(t,e){t.uniform4uiv(this.addr,e)}function is(t,e,n){const r=this.cache,i=e.length,a=Ma(n,i);ba(r,a)||(t.uniform1iv(this.addr,a),wa(r,a));for(let t=0;t!==i;++t)n.setTexture2D(e[t]||ua,a[t])}function as(t,e,n){const r=this.cache,i=e.length,a=Ma(n,i);ba(r,a)||(t.uniform1iv(this.addr,a),wa(r,a));for(let t=0;t!==i;++t)n.setTexture3D(e[t]||pa,a[t])}function ss(t,e,n){const r=this.cache,i=e.length,a=Ma(n,i);ba(r,a)||(t.uniform1iv(this.addr,a),wa(r,a));for(let t=0;t!==i;++t)n.setTextureCube(e[t]||fa,a[t])}function os(t,e,n){const r=this.cache,i=e.length,a=Ma(n,i);ba(r,a)||(t.uniform1iv(this.addr,a),wa(r,a));for(let t=0;t!==i;++t)n.setTexture2DArray(e[t]||da,a[t])}class ls{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.setValue=function(t){switch(t){case 5126:return Ta;case 35664:return Ea;case 35665:return Sa;case 35666:return Aa;case 35674:return Ra;case 35675:return Ca;case 35676:return Pa;case 5124:case 35670:return Ia;case 35667:case 35671:return La;case 35668:case 35672:return Da;case 35669:case 35673:return Oa;case 5125:return Na;case 36294:return Ua;case 36295:return Fa;case 36296:return Ba;case 35678:case 36198:case 36298:case 36306:case 35682:return ka;case 35679:case 36299:case 36307:return za;case 35680:case 36300:case 36308:case 36293:return Ha;case 36289:case 36303:case 36311:case 36292:return Ga}}(e.type)}}class cs{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Va;case 35664:return Wa;case 35665:return ja;case 35666:return qa;case 35674:return Xa;case 35675:return Ya;case 35676:return $a;case 5124:case 35670:return Ka;case 35667:case 35671:return Za;case 35668:case 35672:return Ja;case 35669:case 35673:return Qa;case 5125:return ts;case 36294:return es;case 36295:return ns;case 36296:return rs;case 35678:case 36198:case 36298:case 36306:case 35682:return is;case 35679:case 36299:case 36307:return as;case 35680:case 36300:case 36308:case 36293:return ss;case 36289:case 36303:case 36311:case 36292:return os}}(e.type)}}class us{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const r=this.seq;for(let i=0,a=r.length;i!==a;++i){const a=r[i];a.setValue(t,e[a.id],n)}}}const hs=/(\w+)(\])?(\[|\.)?/g;function ds(t,e){t.seq.push(e),t.map[e.id]=e}function ps(t,e,n){const r=t.name,i=r.length;for(hs.lastIndex=0;;){const a=hs.exec(r),s=hs.lastIndex;let o=a[1];const l="]"===a[2],c=a[3];if(l&&(o|=0),void 0===c||"["===c&&s+2===i){ds(n,void 0===c?new ls(o,t,e):new cs(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new us(o),ds(n,t)),n=t}}}class fs{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let r=0;r<n;++r){const n=t.getActiveUniform(e,r);ps(n,t.getUniformLocation(e,n.name),this)}}setValue(t,e,n,r){const i=this.map[e];void 0!==i&&i.setValue(t,n,r)}setOptional(t,e,n){const r=e[n];void 0!==r&&this.setValue(t,n,r)}static upload(t,e,n,r){for(let i=0,a=e.length;i!==a;++i){const a=e[i],s=n[a.id];!1!==s.needsUpdate&&a.setValue(t,s.value,r)}}static seqWithValue(t,e){const n=[];for(let r=0,i=t.length;r!==i;++r){const i=t[r];i.id in e&&n.push(i)}return n}}function ms(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),r}let gs=0;const vs=new Te;function _s(t,e,n){const r=t.getShaderParameter(e,t.COMPILE_STATUS),i=t.getShaderInfoLog(e).trim();if(r&&""===i)return"";const a=/ERROR: 0:(\d+)/.exec(i);if(a){const r=parseInt(a[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(t,e){const n=t.split("\n"),r=[],i=Math.max(e-6,0),a=Math.min(e+6,n.length);for(let t=i;t<a;t++){const i=t+1;r.push(`${i===e?">":" "} ${i}: ${n[t]}`)}return r.join("\n")}(t.getShaderSource(e),r)}return i}function ys(t,e){const n=function(t){Ie._getMatrix(vs,Ie.workingColorSpace,t);const e=`mat3( ${vs.elements.map((t=>t.toFixed(4)))} )`;switch(Ie.getTransfer(t)){case Kt:return[e,"LinearTransferOETF"];case Zt:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",t),[e,"LinearTransferOETF"]}}(e);return[`vec4 ${t}( vec4 value ) {`,`\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,"}"].join("\n")}function xs(t,e){let n;switch(e){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="Cineon";break;case 4:n="ACESFilmic";break;case 6:n="AgX";break;case 7:n="Neutral";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}const bs=new Qe;function ws(t){return""!==t}function Ms(t,e){const n=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Ts(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Es=/^[ \t]*#include +<([\w\d./]+)>/gm;function Ss(t){return t.replace(Es,Rs)}const As=new Map;function Rs(t,e){let n=Ri[e];if(void 0===n){const t=As.get(e);if(void 0===t)throw new Error("Can not resolve #include <"+e+">");n=Ri[t],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,t)}return Ss(n)}const Cs=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ps(t){return t.replace(Cs,Is)}function Is(t,e,n,r){let i="";for(let t=parseInt(e);t<parseInt(n);t++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return i}function Ls(t){let e=`precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Ds(t,e,n,r){const i=t.getContext(),a=n.defines;let s=n.vertexShader,o=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case N:case U:e="ENVMAP_TYPE_CUBE";break;case B:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),u=function(t){let e="ENVMAP_MODE_REFLECTION";return t.envMap&&t.envMapMode===U&&(e="ENVMAP_MODE_REFRACTION"),e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(n),d=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const n=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:r,maxMip:n}}(n),p=function(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",t.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(ws).join("\n")}(n),f=function(t){const e=[];for(const n in t){const r=t[n];!1!==r&&e.push("#define "+n+" "+r)}return e.join("\n")}(a),m=i.createProgram();let g,v,_=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f].filter(ws).join("\n"),g.length>0&&(g+="\n"),v=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f].filter(ws).join("\n"),v.length>0&&(v+="\n")):(g=[Ls(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.batchingColor?"#define USE_BATCHING_COLOR":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(ws).join("\n"),v=[Ls(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.dispersion?"#define USE_DISPERSION":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor||n.batchingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?Ri.tonemapping_pars_fragment:"",0!==n.toneMapping?xs("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Ri.colorspace_pars_fragment,ys("linearToOutputTexel",n.outputColorSpace),(Ie.getLuminanceCoefficients(bs),["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${bs.x.toFixed(4)}, ${bs.y.toFixed(4)}, ${bs.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join("\n")),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(ws).join("\n")),s=Ss(s),s=Ms(s,n),s=Ts(s,n),o=Ss(o),o=Ms(o,n),o=Ts(o,n),s=Ps(s),o=Ps(o),!0!==n.isRawShaderMaterial&&(_="#version 300 es\n",g=[p,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,v=["#define varying in",n.glslVersion===le?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===le?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+v);const y=_+g+s,x=_+v+o,b=ms(i,i.VERTEX_SHADER,y),w=ms(i,i.FRAGMENT_SHADER,x);function M(e){if(t.debug.checkShaderErrors){const n=i.getProgramInfoLog(m).trim(),r=i.getShaderInfoLog(b).trim(),a=i.getShaderInfoLog(w).trim();let s=!0,o=!0;if(!1===i.getProgramParameter(m,i.LINK_STATUS))if(s=!1,"function"==typeof t.debug.onShaderError)t.debug.onShaderError(i,m,b,w);else{const t=_s(i,b,"vertex"),r=_s(i,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(m,i.VALIDATE_STATUS)+"\n\nMaterial Name: "+e.name+"\nMaterial Type: "+e.type+"\n\nProgram Info Log: "+n+"\n"+t+"\n"+r)}else""!==n?console.warn("THREE.WebGLProgram: Program Info Log:",n):""!==r&&""!==a||(o=!1);o&&(e.diagnostics={runnable:s,programLog:n,vertexShader:{log:r,prefix:g},fragmentShader:{log:a,prefix:v}})}i.deleteShader(b),i.deleteShader(w),T=new fs(i,m),E=function(t,e){const n={},r=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const r=t.getActiveAttrib(e,i),a=r.name;let s=1;r.type===t.FLOAT_MAT2&&(s=2),r.type===t.FLOAT_MAT3&&(s=3),r.type===t.FLOAT_MAT4&&(s=4),n[a]={type:r.type,location:t.getAttribLocation(e,a),locationSize:s}}return n}(i,m)}let T,E;i.attachShader(m,b),i.attachShader(m,w),void 0!==n.index0AttributeName?i.bindAttribLocation(m,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m),this.getUniforms=function(){return void 0===T&&M(this),T},this.getAttributes=function(){return void 0===E&&M(this),E};let S=!1===n.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===S&&(S=i.getProgramParameter(m,37297)),S},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=gs++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=b,this.fragmentShader=w,this}let Os=0;class Ns{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,r=this._getShaderStage(e),i=this._getShaderStage(n),a=this._getShaderCacheForMaterial(t);return!1===a.has(r)&&(a.add(r),r.usedTimes++),!1===a.has(i)&&(a.add(i),i.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return void 0===n&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return void 0===n&&(n=new Us(t),e.set(t,n)),n}}class Us{constructor(t){this.id=Os++,this.code=t,this.usedTimes=0}}function Fs(t,e,n,r,i,a,s){const o=new Hn,l=new Ns,c=new Set,u=[],h=i.logarithmicDepthBuffer,d=i.vertexTextures;let p=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(t){return c.add(t),0===t?"uv":`uv${t}`}return{getParameters:function(a,o,u,g,v){const _=g.fog,y=v.geometry,x=a.isMeshStandardMaterial?g.environment:null,b=(a.isMeshStandardMaterial?n:e).get(a.envMap||x),w=b&&b.mapping===B?b.image.height:null,M=f[a.type];null!==a.precision&&(p=i.getMaxPrecision(a.precision),p!==a.precision&&console.warn("THREE.WebGLProgram.getParameters:",a.precision,"not supported, using",p,"instead."));const T=y.morphAttributes.position||y.morphAttributes.normal||y.morphAttributes.color,E=void 0!==T?T.length:0;let S,A,R,C,P=0;if(void 0!==y.morphAttributes.position&&(P=1),void 0!==y.morphAttributes.normal&&(P=2),void 0!==y.morphAttributes.color&&(P=3),M){const t=Pi[M];S=t.vertexShader,A=t.fragmentShader}else S=a.vertexShader,A=a.fragmentShader,l.update(a),R=l.getVertexShaderID(a),C=l.getFragmentShaderID(a);const I=t.getRenderTarget(),L=t.state.buffers.depth.getReversed(),D=!0===v.isInstancedMesh,O=!0===v.isBatchedMesh,N=!!a.map,U=!!a.matcap,F=!!b,k=!!a.aoMap,z=!!a.lightMap,H=!!a.bumpMap,G=!!a.normalMap,V=!!a.displacementMap,W=!!a.emissiveMap,j=!!a.metalnessMap,q=!!a.roughnessMap,X=a.anisotropy>0,Y=a.clearcoat>0,$=a.dispersion>0,K=a.iridescence>0,Z=a.sheen>0,J=a.transmission>0,Q=X&&!!a.anisotropyMap,tt=Y&&!!a.clearcoatMap,et=Y&&!!a.clearcoatNormalMap,nt=Y&&!!a.clearcoatRoughnessMap,rt=K&&!!a.iridescenceMap,it=K&&!!a.iridescenceThicknessMap,at=Z&&!!a.sheenColorMap,st=Z&&!!a.sheenRoughnessMap,ot=!!a.specularMap,lt=!!a.specularColorMap,ct=!!a.specularIntensityMap,ut=J&&!!a.transmissionMap,ht=J&&!!a.thicknessMap,dt=!!a.gradientMap,pt=!!a.alphaMap,ft=a.alphaTest>0,mt=!!a.alphaHash,gt=!!a.extensions;let vt=0;a.toneMapped&&(null!==I&&!0!==I.isXRRenderTarget||(vt=t.toneMapping));const _t={shaderID:M,shaderType:a.type,shaderName:a.name,vertexShader:S,fragmentShader:A,defines:a.defines,customVertexShaderID:R,customFragmentShaderID:C,isRawShaderMaterial:!0===a.isRawShaderMaterial,glslVersion:a.glslVersion,precision:p,batching:O,batchingColor:O&&null!==v._colorsTexture,instancing:D,instancingColor:D&&null!==v.instanceColor,instancingMorph:D&&null!==v.morphTexture,supportsVertexTextures:d,outputColorSpace:null===I?t.outputColorSpace:!0===I.isXRRenderTarget?I.texture.colorSpace:$t,alphaToCoverage:!!a.alphaToCoverage,map:N,matcap:U,envMap:F,envMapMode:F&&b.mapping,envMapCubeUVHeight:w,aoMap:k,lightMap:z,bumpMap:H,normalMap:G,displacementMap:d&&V,emissiveMap:W,normalMapObjectSpace:G&&1===a.normalMapType,normalMapTangentSpace:G&&0===a.normalMapType,metalnessMap:j,roughnessMap:q,anisotropy:X,anisotropyMap:Q,clearcoat:Y,clearcoatMap:tt,clearcoatNormalMap:et,clearcoatRoughnessMap:nt,dispersion:$,iridescence:K,iridescenceMap:rt,iridescenceThicknessMap:it,sheen:Z,sheenColorMap:at,sheenRoughnessMap:st,specularMap:ot,specularColorMap:lt,specularIntensityMap:ct,transmission:J,transmissionMap:ut,thicknessMap:ht,gradientMap:dt,opaque:!1===a.transparent&&1===a.blending&&!1===a.alphaToCoverage,alphaMap:pt,alphaTest:ft,alphaHash:mt,combine:a.combine,mapUv:N&&m(a.map.channel),aoMapUv:k&&m(a.aoMap.channel),lightMapUv:z&&m(a.lightMap.channel),bumpMapUv:H&&m(a.bumpMap.channel),normalMapUv:G&&m(a.normalMap.channel),displacementMapUv:V&&m(a.displacementMap.channel),emissiveMapUv:W&&m(a.emissiveMap.channel),metalnessMapUv:j&&m(a.metalnessMap.channel),roughnessMapUv:q&&m(a.roughnessMap.channel),anisotropyMapUv:Q&&m(a.anisotropyMap.channel),clearcoatMapUv:tt&&m(a.clearcoatMap.channel),clearcoatNormalMapUv:et&&m(a.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:nt&&m(a.clearcoatRoughnessMap.channel),iridescenceMapUv:rt&&m(a.iridescenceMap.channel),iridescenceThicknessMapUv:it&&m(a.iridescenceThicknessMap.channel),sheenColorMapUv:at&&m(a.sheenColorMap.channel),sheenRoughnessMapUv:st&&m(a.sheenRoughnessMap.channel),specularMapUv:ot&&m(a.specularMap.channel),specularColorMapUv:lt&&m(a.specularColorMap.channel),specularIntensityMapUv:ct&&m(a.specularIntensityMap.channel),transmissionMapUv:ut&&m(a.transmissionMap.channel),thicknessMapUv:ht&&m(a.thicknessMap.channel),alphaMapUv:pt&&m(a.alphaMap.channel),vertexTangents:!!y.attributes.tangent&&(G||X),vertexColors:a.vertexColors,vertexAlphas:!0===a.vertexColors&&!!y.attributes.color&&4===y.attributes.color.itemSize,pointsUvs:!0===v.isPoints&&!!y.attributes.uv&&(N||pt),fog:!!_,useFog:!0===a.fog,fogExp2:!!_&&_.isFogExp2,flatShading:!0===a.flatShading,sizeAttenuation:!0===a.sizeAttenuation,logarithmicDepthBuffer:h,reverseDepthBuffer:L,skinning:!0===v.isSkinnedMesh,morphTargets:void 0!==y.morphAttributes.position,morphNormals:void 0!==y.morphAttributes.normal,morphColors:void 0!==y.morphAttributes.color,morphTargetsCount:E,morphTextureStride:P,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numSpotLightMaps:o.spotLightMap.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numSpotLightShadowsWithMaps:o.numSpotLightShadowsWithMaps,numLightProbes:o.numLightProbes,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:a.dithering,shadowMapEnabled:t.shadowMap.enabled&&u.length>0,shadowMapType:t.shadowMap.type,toneMapping:vt,decodeVideoTexture:N&&!0===a.map.isVideoTexture&&Ie.getTransfer(a.map.colorSpace)===Zt,decodeVideoTextureEmissive:W&&!0===a.emissiveMap.isVideoTexture&&Ie.getTransfer(a.emissiveMap.colorSpace)===Zt,premultipliedAlpha:a.premultipliedAlpha,doubleSided:2===a.side,flipSided:1===a.side,useDepthPacking:a.depthPacking>=0,depthPacking:a.depthPacking||0,index0AttributeName:a.index0AttributeName,extensionClipCullDistance:gt&&!0===a.extensions.clipCullDistance&&r.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(gt&&!0===a.extensions.multiDraw||O)&&r.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:a.customProgramCacheKey()};return _t.vertexUv1s=c.has(1),_t.vertexUv2s=c.has(2),_t.vertexUv3s=c.has(3),c.clear(),_t},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.customVertexShaderID),n.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputColorSpace),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.mapUv),t.push(e.alphaMapUv),t.push(e.lightMapUv),t.push(e.aoMapUv),t.push(e.bumpMapUv),t.push(e.normalMapUv),t.push(e.displacementMapUv),t.push(e.emissiveMapUv),t.push(e.metalnessMapUv),t.push(e.roughnessMapUv),t.push(e.anisotropyMapUv),t.push(e.clearcoatMapUv),t.push(e.clearcoatNormalMapUv),t.push(e.clearcoatRoughnessMapUv),t.push(e.iridescenceMapUv),t.push(e.iridescenceThicknessMapUv),t.push(e.sheenColorMapUv),t.push(e.sheenRoughnessMapUv),t.push(e.specularMapUv),t.push(e.specularColorMapUv),t.push(e.specularIntensityMapUv),t.push(e.transmissionMapUv),t.push(e.thicknessMapUv),t.push(e.combine),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numSpotLightMaps),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.numSpotLightShadowsWithMaps),t.push(e.numLightProbes),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(n,e),function(t,e){o.disableAll(),e.supportsVertexTextures&&o.enable(0),e.instancing&&o.enable(1),e.instancingColor&&o.enable(2),e.instancingMorph&&o.enable(3),e.matcap&&o.enable(4),e.envMap&&o.enable(5),e.normalMapObjectSpace&&o.enable(6),e.normalMapTangentSpace&&o.enable(7),e.clearcoat&&o.enable(8),e.iridescence&&o.enable(9),e.alphaTest&&o.enable(10),e.vertexColors&&o.enable(11),e.vertexAlphas&&o.enable(12),e.vertexUv1s&&o.enable(13),e.vertexUv2s&&o.enable(14),e.vertexUv3s&&o.enable(15),e.vertexTangents&&o.enable(16),e.anisotropy&&o.enable(17),e.alphaHash&&o.enable(18),e.batching&&o.enable(19),e.dispersion&&o.enable(20),e.batchingColor&&o.enable(21),t.push(o.mask),o.disableAll(),e.fog&&o.enable(0),e.useFog&&o.enable(1),e.flatShading&&o.enable(2),e.logarithmicDepthBuffer&&o.enable(3),e.reverseDepthBuffer&&o.enable(4),e.skinning&&o.enable(5),e.morphTargets&&o.enable(6),e.morphNormals&&o.enable(7),e.morphColors&&o.enable(8),e.premultipliedAlpha&&o.enable(9),e.shadowMapEnabled&&o.enable(10),e.doubleSided&&o.enable(11),e.flipSided&&o.enable(12),e.useDepthPacking&&o.enable(13),e.dithering&&o.enable(14),e.transmission&&o.enable(15),e.sheen&&o.enable(16),e.opaque&&o.enable(17),e.pointsUvs&&o.enable(18),e.decodeVideoTexture&&o.enable(19),e.decodeVideoTextureEmissive&&o.enable(20),e.alphaToCoverage&&o.enable(21),t.push(o.mask)}(n,e),n.push(t.outputColorSpace)),n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=f[t.type];let n;if(e){const t=Pi[e];n=oi.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let r;for(let t=0,e=u.length;t<e;t++){const e=u[t];if(e.cacheKey===n){r=e,++r.usedTimes;break}}return void 0===r&&(r=new Ds(t,n,e,a),u.push(r)),r},releaseProgram:function(t){if(0==--t.usedTimes){const e=u.indexOf(t);u[e]=u[u.length-1],u.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:u,dispose:function(){l.dispose()}}}function Bs(){let t=new WeakMap;return{has:function(e){return t.has(e)},get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,r){t.get(e)[n]=r},dispose:function(){t=new WeakMap}}}function ks(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function zs(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Hs(){const t=[];let e=0;const n=[],r=[],i=[];function a(n,r,i,a,s,o){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:a,renderOrder:n.renderOrder,z:s,group:o},t[e]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=a,l.renderOrder=n.renderOrder,l.z=s,l.group=o),e++,l}return{opaque:n,transmissive:r,transparent:i,init:function(){e=0,n.length=0,r.length=0,i.length=0},push:function(t,e,s,o,l,c){const u=a(t,e,s,o,l,c);s.transmission>0?r.push(u):!0===s.transparent?i.push(u):n.push(u)},unshift:function(t,e,s,o,l,c){const u=a(t,e,s,o,l,c);s.transmission>0?r.unshift(u):!0===s.transparent?i.unshift(u):n.unshift(u)},finish:function(){for(let n=e,r=t.length;n<r;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||ks),r.length>1&&r.sort(e||zs),i.length>1&&i.sort(e||zs)}}}function Gs(){let t=new WeakMap;return{get:function(e,n){const r=t.get(e);let i;return void 0===r?(i=new Hs,t.set(e,[i])):n>=r.length?(i=new Hs,r.push(i)):i=r[n],i},dispose:function(){t=new WeakMap}}}function Vs(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new Qe,color:new wr};break;case"SpotLight":n={position:new Qe,direction:new Qe,color:new wr,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Qe,color:new wr,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Qe,skyColor:new wr,groundColor:new wr};break;case"RectAreaLight":n={color:new wr,position:new Qe,halfWidth:new Qe,halfHeight:new Qe}}return t[e.id]=n,n}}}let Ws=0;function js(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function qs(t){const e=new Vs,n=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Me};break;case"PointLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Me,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let t=0;t<9;t++)r.probe.push(new Qe);const i=new Qe,a=new Pn,s=new Pn;return{setup:function(i){let a=0,s=0,o=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let l=0,c=0,u=0,h=0,d=0,p=0,f=0,m=0,g=0,v=0,_=0;i.sort(js);for(let t=0,y=i.length;t<y;t++){const y=i[t],x=y.color,b=y.intensity,w=y.distance,M=y.shadow&&y.shadow.map?y.shadow.map.texture:null;if(y.isAmbientLight)a+=x.r*b,s+=x.g*b,o+=x.b*b;else if(y.isLightProbe){for(let t=0;t<9;t++)r.probe[t].addScaledVector(y.sh.coefficients[t],b);_++}else if(y.isDirectionalLight){const t=e.get(y);if(t.color.copy(y.color).multiplyScalar(y.intensity),y.castShadow){const t=y.shadow,e=n.get(y);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,r.directionalShadow[l]=e,r.directionalShadowMap[l]=M,r.directionalShadowMatrix[l]=y.shadow.matrix,p++}r.directional[l]=t,l++}else if(y.isSpotLight){const t=e.get(y);t.position.setFromMatrixPosition(y.matrixWorld),t.color.copy(x).multiplyScalar(b),t.distance=w,t.coneCos=Math.cos(y.angle),t.penumbraCos=Math.cos(y.angle*(1-y.penumbra)),t.decay=y.decay,r.spot[u]=t;const i=y.shadow;if(y.map&&(r.spotLightMap[g]=y.map,g++,i.updateMatrices(y),y.castShadow&&v++),r.spotLightMatrix[u]=i.matrix,y.castShadow){const t=n.get(y);t.shadowIntensity=i.intensity,t.shadowBias=i.bias,t.shadowNormalBias=i.normalBias,t.shadowRadius=i.radius,t.shadowMapSize=i.mapSize,r.spotShadow[u]=t,r.spotShadowMap[u]=M,m++}u++}else if(y.isRectAreaLight){const t=e.get(y);t.color.copy(x).multiplyScalar(b),t.halfWidth.set(.5*y.width,0,0),t.halfHeight.set(0,.5*y.height,0),r.rectArea[h]=t,h++}else if(y.isPointLight){const t=e.get(y);if(t.color.copy(y.color).multiplyScalar(y.intensity),t.distance=y.distance,t.decay=y.decay,y.castShadow){const t=y.shadow,e=n.get(y);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,e.shadowCameraNear=t.camera.near,e.shadowCameraFar=t.camera.far,r.pointShadow[c]=e,r.pointShadowMap[c]=M,r.pointShadowMatrix[c]=y.shadow.matrix,f++}r.point[c]=t,c++}else if(y.isHemisphereLight){const t=e.get(y);t.skyColor.copy(y.color).multiplyScalar(b),t.groundColor.copy(y.groundColor).multiplyScalar(b),r.hemi[d]=t,d++}}h>0&&(!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=Ci.LTC_FLOAT_1,r.rectAreaLTC2=Ci.LTC_FLOAT_2):(r.rectAreaLTC1=Ci.LTC_HALF_1,r.rectAreaLTC2=Ci.LTC_HALF_2)),r.ambient[0]=a,r.ambient[1]=s,r.ambient[2]=o;const y=r.hash;y.directionalLength===l&&y.pointLength===c&&y.spotLength===u&&y.rectAreaLength===h&&y.hemiLength===d&&y.numDirectionalShadows===p&&y.numPointShadows===f&&y.numSpotShadows===m&&y.numSpotMaps===g&&y.numLightProbes===_||(r.directional.length=l,r.spot.length=u,r.rectArea.length=h,r.point.length=c,r.hemi.length=d,r.directionalShadow.length=p,r.directionalShadowMap.length=p,r.pointShadow.length=f,r.pointShadowMap.length=f,r.spotShadow.length=m,r.spotShadowMap.length=m,r.directionalShadowMatrix.length=p,r.pointShadowMatrix.length=f,r.spotLightMatrix.length=m+g-v,r.spotLightMap.length=g,r.numSpotLightShadowsWithMaps=v,r.numLightProbes=_,y.directionalLength=l,y.pointLength=c,y.spotLength=u,y.rectAreaLength=h,y.hemiLength=d,y.numDirectionalShadows=p,y.numPointShadows=f,y.numSpotShadows=m,y.numSpotMaps=g,y.numLightProbes=_,r.version=Ws++)},setupView:function(t,e){let n=0,o=0,l=0,c=0,u=0;const h=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),i.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(i),t.direction.transformDirection(h),n++}else if(d.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),t.direction.setFromMatrixPosition(d.matrixWorld),i.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(i),t.direction.transformDirection(h),l++}else if(d.isRectAreaLight){const t=r.rectArea[c];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),s.identity(),a.copy(d.matrixWorld),a.premultiply(h),s.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(s),t.halfHeight.applyMatrix4(s),c++}else if(d.isPointLight){const t=r.point[o];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),o++}else if(d.isHemisphereLight){const t=r.hemi[u];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(h),u++}}},state:r}}function Xs(t){const e=new qs(t),n=[],r=[],i={lightsArray:n,shadowsArray:r,camera:null,lights:e,transmissionRenderTarget:{}};return{init:function(t){i.camera=t,n.length=0,r.length=0},state:i,setupLights:function(){e.setup(n)},setupLightsView:function(t){e.setupView(n,t)},pushLight:function(t){n.push(t)},pushShadow:function(t){r.push(t)}}}function Ys(t){let e=new WeakMap;return{get:function(n,r=0){const i=e.get(n);let a;return void 0===i?(a=new Xs(t),e.set(n,[a])):r>=i.length?(a=new Xs(t),i.push(a)):a=i[r],a},dispose:function(){e=new WeakMap}}}class $s extends Er{static get type(){return"MeshDepthMaterial"}constructor(t){super(),this.isMeshDepthMaterial=!0,this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Ks extends Er{static get type(){return"MeshDistanceMaterial"}constructor(t){super(),this.isMeshDistanceMaterial=!0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function Zs(t,e,n){let r=new Ti;const i=new Me,l=new Me,c=new qe,u=new $s({depthPacking:3201}),h=new Ks,d={},p=n.maxTextureSize,f={[a]:1,[s]:0,[o]:2},m=new li({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Me},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),g=m.clone();g.defines.HORIZONTAL_PASS=1;const v=new Vr;v.setAttribute("position",new Lr(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const _=new ei(v,m),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1;let x=this.type;function b(n,r){const a=e.update(_);m.defines.VSM_SAMPLES!==n.blurSamples&&(m.defines.VSM_SAMPLES=n.blurSamples,g.defines.VSM_SAMPLES=n.blurSamples,m.needsUpdate=!0,g.needsUpdate=!0),null===n.mapPass&&(n.mapPass=new Ye(i.x,i.y)),m.uniforms.shadow_pass.value=n.map.texture,m.uniforms.resolution.value=n.mapSize,m.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(r,null,a,m,_,null),g.uniforms.shadow_pass.value=n.mapPass.texture,g.uniforms.resolution.value=n.mapSize,g.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(r,null,a,g,_,null)}function w(e,n,r,i){let a=null;const s=!0===r.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(void 0!==s)a=s;else if(a=!0===r.isPointLight?h:u,t.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0||n.map&&n.alphaTest>0){const t=a.uuid,e=n.uuid;let r=d[t];void 0===r&&(r={},d[t]=r);let i=r[e];void 0===i&&(i=a.clone(),r[e]=i,n.addEventListener("dispose",T)),a=i}return a.visible=n.visible,a.wireframe=n.wireframe,a.side=3===i?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:f[n.side],a.alphaMap=n.alphaMap,a.alphaTest=n.alphaTest,a.map=n.map,a.clipShadows=n.clipShadows,a.clippingPlanes=n.clippingPlanes,a.clipIntersection=n.clipIntersection,a.displacementMap=n.displacementMap,a.displacementScale=n.displacementScale,a.displacementBias=n.displacementBias,a.wireframeLinewidth=n.wireframeLinewidth,a.linewidth=n.linewidth,!0===r.isPointLight&&!0===a.isMeshDistanceMaterial&&(t.properties.get(a).light=r),a}function M(n,i,a,s,o){if(!1===n.visible)return;if(n.layers.test(i.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===o)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,n.matrixWorld);const r=e.update(n),l=n.material;if(Array.isArray(l)){const e=r.groups;for(let c=0,u=e.length;c<u;c++){const u=e[c],h=l[u.materialIndex];if(h&&h.visible){const e=w(n,h,s,o);n.onBeforeShadow(t,n,i,a,r,e,u),t.renderBufferDirect(a,null,r,e,n,u),n.onAfterShadow(t,n,i,a,r,e,u)}}}else if(l.visible){const e=w(n,l,s,o);n.onBeforeShadow(t,n,i,a,r,e,null),t.renderBufferDirect(a,null,r,e,n,null),n.onAfterShadow(t,n,i,a,r,e,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)M(l[t],i,a,s,o)}function T(t){t.target.removeEventListener("dispose",T);for(const e in d){const n=d[e],r=t.target.uuid;r in n&&(n[r].dispose(),delete n[r])}}this.render=function(e,n,a){if(!1===y.enabled)return;if(!1===y.autoUpdate&&!1===y.needsUpdate)return;if(0===e.length)return;const s=t.getRenderTarget(),o=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),h=t.state;h.setBlending(0),h.buffers.color.setClear(1,1,1,1),h.buffers.depth.setTest(!0),h.setScissorTest(!1);const d=3!==x&&3===this.type,f=3===x&&3!==this.type;for(let s=0,o=e.length;s<o;s++){const o=e[s],u=o.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",o,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;i.copy(u.mapSize);const m=u.getFrameExtents();if(i.multiply(m),l.copy(u.mapSize),(i.x>p||i.y>p)&&(i.x>p&&(l.x=Math.floor(p/m.x),i.x=l.x*m.x,u.mapSize.x=l.x),i.y>p&&(l.y=Math.floor(p/m.y),i.y=l.y*m.y,u.mapSize.y=l.y)),null===u.map||!0===d||!0===f){const t=3!==this.type?{minFilter:G,magFilter:G}:{};null!==u.map&&u.map.dispose(),u.map=new Ye(i.x,i.y,t),u.map.texture.name=o.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const g=u.getViewportCount();for(let t=0;t<g;t++){const e=u.getViewport(t);c.set(l.x*e.x,l.y*e.y,l.x*e.z,l.y*e.w),h.viewport(c),u.updateMatrices(o,t),r=u.getFrustum(),M(n,a,u.camera,o,this.type)}!0!==u.isPointLightShadow&&3===this.type&&b(u,a),u.needsUpdate=!1}x=this.type,y.needsUpdate=!1,t.setRenderTarget(s,o,u)}}const Js={[S]:1,[R]:6,[P]:7,[C]:5,[A]:0,[L]:2,[D]:4,[I]:3};function Qs(t,e){const n=new function(){let e=!1;const n=new qe;let r=null;const i=new qe(0,0,0,0);return{setMask:function(n){r===n||e||(t.colorMask(n,n,n,n),r=n)},setLocked:function(t){e=t},setClear:function(e,r,a,s,o){!0===o&&(e*=s,r*=s,a*=s),n.set(e,r,a,s),!1===i.equals(n)&&(t.clearColor(e,r,a,s),i.copy(n))},reset:function(){e=!1,r=null,i.set(-1,0,0,0)}}},r=new function(){let n=!1,r=!1,i=null,a=null,s=null;return{setReversed:function(t){if(r!==t){const t=e.get("EXT_clip_control");r?t.clipControlEXT(t.LOWER_LEFT_EXT,t.ZERO_TO_ONE_EXT):t.clipControlEXT(t.LOWER_LEFT_EXT,t.NEGATIVE_ONE_TO_ONE_EXT);const n=s;s=null,this.setClear(n)}r=t},getReversed:function(){return r},setTest:function(e){e?it(t.DEPTH_TEST):at(t.DEPTH_TEST)},setMask:function(e){i===e||n||(t.depthMask(e),i=e)},setFunc:function(e){if(r&&(e=Js[e]),a!==e){switch(e){case 0:t.depthFunc(t.NEVER);break;case 1:t.depthFunc(t.ALWAYS);break;case 2:t.depthFunc(t.LESS);break;case 3:default:t.depthFunc(t.LEQUAL);break;case 4:t.depthFunc(t.EQUAL);break;case 5:t.depthFunc(t.GEQUAL);break;case 6:t.depthFunc(t.GREATER);break;case 7:t.depthFunc(t.NOTEQUAL)}a=e}},setLocked:function(t){n=t},setClear:function(e){s!==e&&(r&&(e=1-e),t.clearDepth(e),s=e)},reset:function(){n=!1,i=null,a=null,s=null,r=!1}}},i=new function(){let e=!1,n=null,r=null,i=null,a=null,s=null,o=null,l=null,c=null;return{setTest:function(n){e||(n?it(t.STENCIL_TEST):at(t.STENCIL_TEST))},setMask:function(r){n===r||e||(t.stencilMask(r),n=r)},setFunc:function(e,n,s){r===e&&i===n&&a===s||(t.stencilFunc(e,n,s),r=e,i=n,a=s)},setOp:function(e,n,r){s===e&&o===n&&l===r||(t.stencilOp(e,n,r),s=e,o=n,l=r)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,r=null,i=null,a=null,s=null,o=null,l=null,c=null}}},a=new WeakMap,s=new WeakMap;let o={},S={},A=new WeakMap,R=[],C=null,P=!1,I=null,L=null,D=null,O=null,N=null,U=null,F=null,B=new wr(0,0,0),k=0,z=!1,H=null,G=null,V=null,W=null,j=null;const q=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let X=!1,Y=0;const $=t.getParameter(t.VERSION);-1!==$.indexOf("WebGL")?(Y=parseFloat(/^WebGL (\d)/.exec($)[1]),X=Y>=1):-1!==$.indexOf("OpenGL ES")&&(Y=parseFloat(/^OpenGL ES (\d)/.exec($)[1]),X=Y>=2);let K=null,Z={};const J=t.getParameter(t.SCISSOR_BOX),Q=t.getParameter(t.VIEWPORT),tt=(new qe).fromArray(J),et=(new qe).fromArray(Q);function nt(e,n,r,i){const a=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let s=0;s<r;s++)e===t.TEXTURE_3D||e===t.TEXTURE_2D_ARRAY?t.texImage3D(n,0,t.RGBA,1,1,i,0,t.RGBA,t.UNSIGNED_BYTE,a):t.texImage2D(n+s,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,a);return s}const rt={};function it(e){!0!==o[e]&&(t.enable(e),o[e]=!0)}function at(e){!1!==o[e]&&(t.disable(e),o[e]=!1)}rt[t.TEXTURE_2D]=nt(t.TEXTURE_2D,t.TEXTURE_2D,1),rt[t.TEXTURE_CUBE_MAP]=nt(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),rt[t.TEXTURE_2D_ARRAY]=nt(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),rt[t.TEXTURE_3D]=nt(t.TEXTURE_3D,t.TEXTURE_3D,1,1),n.setClear(0,0,0,1),r.setClear(1),i.setClear(0),it(t.DEPTH_TEST),r.setFunc(3),ct(!1),ut(1),it(t.CULL_FACE),lt(0);const st={[l]:t.FUNC_ADD,[c]:t.FUNC_SUBTRACT,[u]:t.FUNC_REVERSE_SUBTRACT};st[103]=t.MIN,st[104]=t.MAX;const ot={[h]:t.ZERO,[d]:t.ONE,[p]:t.SRC_COLOR,[m]:t.SRC_ALPHA,[b]:t.SRC_ALPHA_SATURATE,[y]:t.DST_COLOR,[v]:t.DST_ALPHA,[f]:t.ONE_MINUS_SRC_COLOR,[g]:t.ONE_MINUS_SRC_ALPHA,[x]:t.ONE_MINUS_DST_COLOR,[_]:t.ONE_MINUS_DST_ALPHA,[w]:t.CONSTANT_COLOR,[M]:t.ONE_MINUS_CONSTANT_COLOR,[T]:t.CONSTANT_ALPHA,[E]:t.ONE_MINUS_CONSTANT_ALPHA};function lt(e,n,r,i,a,s,o,c,u,h){if(0!==e){if(!1===P&&(it(t.BLEND),P=!0),5===e)a=a||n,s=s||r,o=o||i,n===L&&a===N||(t.blendEquationSeparate(st[n],st[a]),L=n,N=a),r===D&&i===O&&s===U&&o===F||(t.blendFuncSeparate(ot[r],ot[i],ot[s],ot[o]),D=r,O=i,U=s,F=o),!1!==c.equals(B)&&u===k||(t.blendColor(c.r,c.g,c.b,u),B.copy(c),k=u),I=e,z=!1;else if(e!==I||h!==z){if(L===l&&N===l||(t.blendEquation(t.FUNC_ADD),L=l,N=l),h)switch(e){case 1:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.ONE,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case 4:t.blendFuncSeparate(t.ZERO,t.SRC_COLOR,t.ZERO,t.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.SRC_ALPHA,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case 4:t.blendFunc(t.ZERO,t.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}D=null,O=null,U=null,F=null,B.set(0,0,0),k=0,I=e,z=h}}else!0===P&&(at(t.BLEND),P=!1)}function ct(e){H!==e&&(e?t.frontFace(t.CW):t.frontFace(t.CCW),H=e)}function ut(e){0!==e?(it(t.CULL_FACE),e!==G&&(1===e?t.cullFace(t.BACK):2===e?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):at(t.CULL_FACE),G=e}function ht(e,n,r){e?(it(t.POLYGON_OFFSET_FILL),W===n&&j===r||(t.polygonOffset(n,r),W=n,j=r)):at(t.POLYGON_OFFSET_FILL)}return{buffers:{color:n,depth:r,stencil:i},enable:it,disable:at,bindFramebuffer:function(e,n){return S[e]!==n&&(t.bindFramebuffer(e,n),S[e]=n,e===t.DRAW_FRAMEBUFFER&&(S[t.FRAMEBUFFER]=n),e===t.FRAMEBUFFER&&(S[t.DRAW_FRAMEBUFFER]=n),!0)},drawBuffers:function(e,n){let r=R,i=!1;if(e){r=A.get(n),void 0===r&&(r=[],A.set(n,r));const a=e.textures;if(r.length!==a.length||r[0]!==t.COLOR_ATTACHMENT0){for(let e=0,n=a.length;e<n;e++)r[e]=t.COLOR_ATTACHMENT0+e;r.length=a.length,i=!0}}else r[0]!==t.BACK&&(r[0]=t.BACK,i=!0);i&&t.drawBuffers(r)},useProgram:function(e){return C!==e&&(t.useProgram(e),C=e,!0)},setBlending:lt,setMaterial:function(e,a){2===e.side?at(t.CULL_FACE):it(t.CULL_FACE);let s=1===e.side;a&&(s=!s),ct(s),1===e.blending&&!1===e.transparent?lt(0):lt(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.blendColor,e.blendAlpha,e.premultipliedAlpha),r.setFunc(e.depthFunc),r.setTest(e.depthTest),r.setMask(e.depthWrite),n.setMask(e.colorWrite);const o=e.stencilWrite;i.setTest(o),o&&(i.setMask(e.stencilWriteMask),i.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),i.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),ht(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?it(t.SAMPLE_ALPHA_TO_COVERAGE):at(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:ct,setCullFace:ut,setLineWidth:function(e){e!==V&&(X&&t.lineWidth(e),V=e)},setPolygonOffset:ht,setScissorTest:function(e){e?it(t.SCISSOR_TEST):at(t.SCISSOR_TEST)},activeTexture:function(e){void 0===e&&(e=t.TEXTURE0+q-1),K!==e&&(t.activeTexture(e),K=e)},bindTexture:function(e,n,r){void 0===r&&(r=null===K?t.TEXTURE0+q-1:K);let i=Z[r];void 0===i&&(i={type:void 0,texture:void 0},Z[r]=i),i.type===e&&i.texture===n||(K!==r&&(t.activeTexture(r),K=r),t.bindTexture(e,n||rt[e]),i.type=e,i.texture=n)},unbindTexture:function(){const e=Z[K];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexImage3D:function(){try{t.compressedTexImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},updateUBOMapping:function(e,n){let r=s.get(n);void 0===r&&(r=new WeakMap,s.set(n,r));let i=r.get(e);void 0===i&&(i=t.getUniformBlockIndex(n,e.name),r.set(e,i))},uniformBlockBinding:function(e,n){const r=s.get(n).get(e);a.get(n)!==r&&(t.uniformBlockBinding(n,r,e.__bindingPointIndex),a.set(n,r))},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===tt.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),tt.copy(e))},viewport:function(e){!1===et.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),et.copy(e))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),r.setReversed(!1),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),o={},K=null,Z={},S={},A=new WeakMap,R=[],C=null,P=!1,I=null,L=null,D=null,O=null,N=null,U=null,F=null,B=new wr(0,0,0),k=0,z=!1,H=null,G=null,V=null,W=null,j=null,tt.set(0,0,t.canvas.width,t.canvas.height),et.set(0,0,t.canvas.width,t.canvas.height),n.reset(),r.reset(),i.reset()}}}function to(t,e,n,r){const i=function(t){switch(t){case Y:case $:return{byteLength:1,components:1};case Z:case K:case et:return{byteLength:2,components:1};case nt:case rt:return{byteLength:2,components:4};case Q:case J:case tt:return{byteLength:4,components:1};case 35902:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${t}.`)}(r);switch(n){case 1021:case 1024:return t*e;case 1025:return t*e*2;case lt:case ct:return t*e/i.components*i.byteLength;case ut:case ht:return t*e*2/i.components*i.byteLength;case 1022:return t*e*3/i.components*i.byteLength;case at:case dt:return t*e*4/i.components*i.byteLength;case pt:case ft:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case mt:case gt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case _t:case xt:return Math.max(t,16)*Math.max(e,8)/4;case vt:case yt:return Math.max(t,8)*Math.max(e,8)/2;case bt:case wt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case Mt:case Tt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case Et:return Math.floor((t+4)/5)*Math.floor((e+3)/4)*16;case St:return Math.floor((t+4)/5)*Math.floor((e+4)/5)*16;case At:return Math.floor((t+5)/6)*Math.floor((e+4)/5)*16;case Rt:return Math.floor((t+5)/6)*Math.floor((e+5)/6)*16;case Ct:return Math.floor((t+7)/8)*Math.floor((e+4)/5)*16;case Pt:return Math.floor((t+7)/8)*Math.floor((e+5)/6)*16;case It:return Math.floor((t+7)/8)*Math.floor((e+7)/8)*16;case Lt:return Math.floor((t+9)/10)*Math.floor((e+4)/5)*16;case Dt:return Math.floor((t+9)/10)*Math.floor((e+5)/6)*16;case Ot:return Math.floor((t+9)/10)*Math.floor((e+7)/8)*16;case Nt:return Math.floor((t+9)/10)*Math.floor((e+9)/10)*16;case Ut:return Math.floor((t+11)/12)*Math.floor((e+9)/10)*16;case Ft:return Math.floor((t+11)/12)*Math.floor((e+11)/12)*16;case Bt:case kt:case zt:return Math.ceil(t/4)*Math.ceil(e/4)*16;case 36283:case Ht:return Math.ceil(t/4)*Math.ceil(e/4)*8;case Gt:case Vt:return Math.ceil(t/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${n} format.`)}function eo(t,e,n,r,i,a,s){const o=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),c=new Me,u=new WeakMap;let h;const d=new WeakMap;let p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function f(t,e){return p?new OffscreenCanvas(t,e):Ae("canvas")}function m(t,e,n){let r=1;const i=J(t);if((i.width>n||i.height>n)&&(r=n/Math.max(i.width,i.height)),r<1){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&t instanceof VideoFrame){const n=Math.floor(r*i.width),a=Math.floor(r*i.height);void 0===h&&(h=f(n,a));const s=e?f(n,a):h;return s.width=n,s.height=a,s.getContext("2d").drawImage(t,0,0,n,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+i.width+"x"+i.height+") to ("+n+"x"+a+")."),s}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+i.width+"x"+i.height+")."),t}return t}function g(t){return t.generateMipmaps}function v(e){t.generateMipmap(e)}function _(e){return e.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:e.isWebGL3DRenderTarget?t.TEXTURE_3D:e.isWebGLArrayRenderTarget||e.isCompressedArrayTexture?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D}function y(n,r,i,a,s=!1){if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let o=r;if(r===t.RED&&(i===t.FLOAT&&(o=t.R32F),i===t.HALF_FLOAT&&(o=t.R16F),i===t.UNSIGNED_BYTE&&(o=t.R8)),r===t.RED_INTEGER&&(i===t.UNSIGNED_BYTE&&(o=t.R8UI),i===t.UNSIGNED_SHORT&&(o=t.R16UI),i===t.UNSIGNED_INT&&(o=t.R32UI),i===t.BYTE&&(o=t.R8I),i===t.SHORT&&(o=t.R16I),i===t.INT&&(o=t.R32I)),r===t.RG&&(i===t.FLOAT&&(o=t.RG32F),i===t.HALF_FLOAT&&(o=t.RG16F),i===t.UNSIGNED_BYTE&&(o=t.RG8)),r===t.RG_INTEGER&&(i===t.UNSIGNED_BYTE&&(o=t.RG8UI),i===t.UNSIGNED_SHORT&&(o=t.RG16UI),i===t.UNSIGNED_INT&&(o=t.RG32UI),i===t.BYTE&&(o=t.RG8I),i===t.SHORT&&(o=t.RG16I),i===t.INT&&(o=t.RG32I)),r===t.RGB_INTEGER&&(i===t.UNSIGNED_BYTE&&(o=t.RGB8UI),i===t.UNSIGNED_SHORT&&(o=t.RGB16UI),i===t.UNSIGNED_INT&&(o=t.RGB32UI),i===t.BYTE&&(o=t.RGB8I),i===t.SHORT&&(o=t.RGB16I),i===t.INT&&(o=t.RGB32I)),r===t.RGBA_INTEGER&&(i===t.UNSIGNED_BYTE&&(o=t.RGBA8UI),i===t.UNSIGNED_SHORT&&(o=t.RGBA16UI),i===t.UNSIGNED_INT&&(o=t.RGBA32UI),i===t.BYTE&&(o=t.RGBA8I),i===t.SHORT&&(o=t.RGBA16I),i===t.INT&&(o=t.RGBA32I)),r===t.RGB&&i===t.UNSIGNED_INT_5_9_9_9_REV&&(o=t.RGB9_E5),r===t.RGBA){const e=s?Kt:Ie.getTransfer(a);i===t.FLOAT&&(o=t.RGBA32F),i===t.HALF_FLOAT&&(o=t.RGBA16F),i===t.UNSIGNED_BYTE&&(o=e===Zt?t.SRGB8_ALPHA8:t.RGBA8),i===t.UNSIGNED_SHORT_4_4_4_4&&(o=t.RGBA4),i===t.UNSIGNED_SHORT_5_5_5_1&&(o=t.RGB5_A1)}return o!==t.R16F&&o!==t.R32F&&o!==t.RG16F&&o!==t.RG32F&&o!==t.RGBA16F&&o!==t.RGBA32F||e.get("EXT_color_buffer_float"),o}function x(e,n){let r;return e?null===n||n===Q||n===it?r=t.DEPTH24_STENCIL8:n===tt?r=t.DEPTH32F_STENCIL8:n===Z&&(r=t.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):null===n||n===Q||n===it?r=t.DEPTH_COMPONENT24:n===tt?r=t.DEPTH_COMPONENT32F:n===Z&&(r=t.DEPTH_COMPONENT16),r}function b(t,e){return!0===g(t)||t.isFramebufferTexture&&t.minFilter!==G&&t.minFilter!==j?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function w(t){const e=t.target;e.removeEventListener("dispose",w),function(t){const e=r.get(t);if(void 0===e.__webglInit)return;const n=t.source,i=d.get(n);if(i){const r=i[e.__cacheKey];r.usedTimes--,0===r.usedTimes&&T(t),0===Object.keys(i).length&&d.delete(n)}r.remove(t)}(e),e.isVideoTexture&&u.delete(e)}function M(e){const n=e.target;n.removeEventListener("dispose",M),function(e){const n=r.get(e);if(e.depthTexture&&(e.depthTexture.dispose(),r.remove(e.depthTexture)),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++){if(Array.isArray(n.__webglFramebuffer[e]))for(let r=0;r<n.__webglFramebuffer[e].length;r++)t.deleteFramebuffer(n.__webglFramebuffer[e][r]);else t.deleteFramebuffer(n.__webglFramebuffer[e]);n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer[e])}else{if(Array.isArray(n.__webglFramebuffer))for(let e=0;e<n.__webglFramebuffer.length;e++)t.deleteFramebuffer(n.__webglFramebuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer);if(n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&t.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer)for(let e=0;e<n.__webglColorRenderbuffer.length;e++)n.__webglColorRenderbuffer[e]&&t.deleteRenderbuffer(n.__webglColorRenderbuffer[e]);n.__webglDepthRenderbuffer&&t.deleteRenderbuffer(n.__webglDepthRenderbuffer)}const i=e.textures;for(let e=0,n=i.length;e<n;e++){const n=r.get(i[e]);n.__webglTexture&&(t.deleteTexture(n.__webglTexture),s.memory.textures--),r.remove(i[e])}r.remove(e)}(n)}function T(e){const n=r.get(e);t.deleteTexture(n.__webglTexture);const i=e.source;delete d.get(i)[n.__cacheKey],s.memory.textures--}let E=0;function S(e,i){const a=r.get(e);if(e.isVideoTexture&&function(t){const e=s.render.frame;u.get(t)!==e&&(u.set(t,e),t.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&a.__version!==e.version){const t=e.image;if(null===t)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==t.complete)return void L(a,e,i);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.bindTexture(t.TEXTURE_2D,a.__webglTexture,t.TEXTURE0+i)}const A={[k]:t.REPEAT,[z]:t.CLAMP_TO_EDGE,[H]:t.MIRRORED_REPEAT},R={[G]:t.NEAREST,[V]:t.NEAREST_MIPMAP_NEAREST,[W]:t.NEAREST_MIPMAP_LINEAR,[j]:t.LINEAR,[q]:t.LINEAR_MIPMAP_NEAREST,[X]:t.LINEAR_MIPMAP_LINEAR},C={[Qt]:t.NEVER,[se]:t.ALWAYS,[te]:t.LESS,[ne]:t.LEQUAL,[ee]:t.EQUAL,[ae]:t.GEQUAL,[re]:t.GREATER,[ie]:t.NOTEQUAL};function P(n,a){if(a.type!==tt||!1!==e.has("OES_texture_float_linear")||a.magFilter!==j&&a.magFilter!==q&&a.magFilter!==W&&a.magFilter!==X&&a.minFilter!==j&&a.minFilter!==q&&a.minFilter!==W&&a.minFilter!==X||console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),t.texParameteri(n,t.TEXTURE_WRAP_S,A[a.wrapS]),t.texParameteri(n,t.TEXTURE_WRAP_T,A[a.wrapT]),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,A[a.wrapR]),t.texParameteri(n,t.TEXTURE_MAG_FILTER,R[a.magFilter]),t.texParameteri(n,t.TEXTURE_MIN_FILTER,R[a.minFilter]),a.compareFunction&&(t.texParameteri(n,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(n,t.TEXTURE_COMPARE_FUNC,C[a.compareFunction])),!0===e.has("EXT_texture_filter_anisotropic")){if(a.magFilter===G)return;if(a.minFilter!==W&&a.minFilter!==X)return;if(a.type===tt&&!1===e.has("OES_texture_float_linear"))return;if(a.anisotropy>1||r.get(a).__currentAnisotropy){const s=e.get("EXT_texture_filter_anisotropic");t.texParameterf(n,s.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,i.getMaxAnisotropy())),r.get(a).__currentAnisotropy=a.anisotropy}}}function I(e,n){let r=!1;void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",w));const i=n.source;let a=d.get(i);void 0===a&&(a={},d.set(i,a));const o=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.wrapR||0),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.colorSpace),e.join()}(n);if(o!==e.__cacheKey){void 0===a[o]&&(a[o]={texture:t.createTexture(),usedTimes:0},s.memory.textures++,r=!0),a[o].usedTimes++;const i=a[e.__cacheKey];void 0!==i&&(a[e.__cacheKey].usedTimes--,0===i.usedTimes&&T(n)),e.__cacheKey=o,e.__webglTexture=a[o].texture}return r}function L(e,s,o){let l=t.TEXTURE_2D;(s.isDataArrayTexture||s.isCompressedArrayTexture)&&(l=t.TEXTURE_2D_ARRAY),s.isData3DTexture&&(l=t.TEXTURE_3D);const c=I(e,s),u=s.source;n.bindTexture(l,e.__webglTexture,t.TEXTURE0+o);const h=r.get(u);if(u.version!==h.__version||!0===c){n.activeTexture(t.TEXTURE0+o);const e=Ie.getPrimaries(Ie.workingColorSpace),r=s.colorSpace===Xt?null:Ie.getPrimaries(s.colorSpace),d=s.colorSpace===Xt||e===r?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,s.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,s.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,d);let p=m(s.image,!1,i.maxTextureSize);p=K(s,p);const f=a.convert(s.format,s.colorSpace),_=a.convert(s.type);let w,M=y(s.internalFormat,f,_,s.colorSpace,s.isVideoTexture);P(l,s);const T=s.mipmaps,E=!0!==s.isVideoTexture,S=void 0===h.__version||!0===c,A=u.dataReady,R=b(s,p);if(s.isDepthTexture)M=x(s.format===ot,s.type),S&&(E?n.texStorage2D(t.TEXTURE_2D,1,M,p.width,p.height):n.texImage2D(t.TEXTURE_2D,0,M,p.width,p.height,0,f,_,null));else if(s.isDataTexture)if(T.length>0){E&&S&&n.texStorage2D(t.TEXTURE_2D,R,M,T[0].width,T[0].height);for(let e=0,r=T.length;e<r;e++)w=T[e],E?A&&n.texSubImage2D(t.TEXTURE_2D,e,0,0,w.width,w.height,f,_,w.data):n.texImage2D(t.TEXTURE_2D,e,M,w.width,w.height,0,f,_,w.data);s.generateMipmaps=!1}else E?(S&&n.texStorage2D(t.TEXTURE_2D,R,M,p.width,p.height),A&&n.texSubImage2D(t.TEXTURE_2D,0,0,0,p.width,p.height,f,_,p.data)):n.texImage2D(t.TEXTURE_2D,0,M,p.width,p.height,0,f,_,p.data);else if(s.isCompressedTexture)if(s.isCompressedArrayTexture){E&&S&&n.texStorage3D(t.TEXTURE_2D_ARRAY,R,M,T[0].width,T[0].height,p.depth);for(let e=0,r=T.length;e<r;e++)if(w=T[e],s.format!==at)if(null!==f)if(E){if(A)if(s.layerUpdates.size>0){const r=to(w.width,w.height,s.format,s.type);for(const i of s.layerUpdates){const a=w.data.subarray(i*r/w.data.BYTES_PER_ELEMENT,(i+1)*r/w.data.BYTES_PER_ELEMENT);n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,i,w.width,w.height,1,f,a)}s.clearLayerUpdates()}else n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,w.width,w.height,p.depth,f,w.data)}else n.compressedTexImage3D(t.TEXTURE_2D_ARRAY,e,M,w.width,w.height,p.depth,0,w.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else E?A&&n.texSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,w.width,w.height,p.depth,f,_,w.data):n.texImage3D(t.TEXTURE_2D_ARRAY,e,M,w.width,w.height,p.depth,0,f,_,w.data)}else{E&&S&&n.texStorage2D(t.TEXTURE_2D,R,M,T[0].width,T[0].height);for(let e=0,r=T.length;e<r;e++)w=T[e],s.format!==at?null!==f?E?A&&n.compressedTexSubImage2D(t.TEXTURE_2D,e,0,0,w.width,w.height,f,w.data):n.compressedTexImage2D(t.TEXTURE_2D,e,M,w.width,w.height,0,w.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):E?A&&n.texSubImage2D(t.TEXTURE_2D,e,0,0,w.width,w.height,f,_,w.data):n.texImage2D(t.TEXTURE_2D,e,M,w.width,w.height,0,f,_,w.data)}else if(s.isDataArrayTexture)if(E){if(S&&n.texStorage3D(t.TEXTURE_2D_ARRAY,R,M,p.width,p.height,p.depth),A)if(s.layerUpdates.size>0){const e=to(p.width,p.height,s.format,s.type);for(const r of s.layerUpdates){const i=p.data.subarray(r*e/p.data.BYTES_PER_ELEMENT,(r+1)*e/p.data.BYTES_PER_ELEMENT);n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,r,p.width,p.height,1,f,_,i)}s.clearLayerUpdates()}else n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,p.width,p.height,p.depth,f,_,p.data)}else n.texImage3D(t.TEXTURE_2D_ARRAY,0,M,p.width,p.height,p.depth,0,f,_,p.data);else if(s.isData3DTexture)E?(S&&n.texStorage3D(t.TEXTURE_3D,R,M,p.width,p.height,p.depth),A&&n.texSubImage3D(t.TEXTURE_3D,0,0,0,0,p.width,p.height,p.depth,f,_,p.data)):n.texImage3D(t.TEXTURE_3D,0,M,p.width,p.height,p.depth,0,f,_,p.data);else if(s.isFramebufferTexture){if(S)if(E)n.texStorage2D(t.TEXTURE_2D,R,M,p.width,p.height);else{let e=p.width,r=p.height;for(let i=0;i<R;i++)n.texImage2D(t.TEXTURE_2D,i,M,e,r,0,f,_,null),e>>=1,r>>=1}}else if(T.length>0){if(E&&S){const e=J(T[0]);n.texStorage2D(t.TEXTURE_2D,R,M,e.width,e.height)}for(let e=0,r=T.length;e<r;e++)w=T[e],E?A&&n.texSubImage2D(t.TEXTURE_2D,e,0,0,f,_,w):n.texImage2D(t.TEXTURE_2D,e,M,f,_,w);s.generateMipmaps=!1}else if(E){if(S){const e=J(p);n.texStorage2D(t.TEXTURE_2D,R,M,e.width,e.height)}A&&n.texSubImage2D(t.TEXTURE_2D,0,0,0,f,_,p)}else n.texImage2D(t.TEXTURE_2D,0,M,f,_,p);g(s)&&v(l),h.__version=u.version,s.onUpdate&&s.onUpdate(s)}e.__version=s.version}function D(e,i,s,l,c,u){const h=a.convert(s.format,s.colorSpace),d=a.convert(s.type),p=y(s.internalFormat,h,d,s.colorSpace),f=r.get(i),m=r.get(s);if(m.__renderTarget=i,!f.__hasExternalTextures){const e=Math.max(1,i.width>>u),r=Math.max(1,i.height>>u);c===t.TEXTURE_3D||c===t.TEXTURE_2D_ARRAY?n.texImage3D(c,u,p,e,r,i.depth,0,h,d,null):n.texImage2D(c,u,p,e,r,0,h,d,null)}n.bindFramebuffer(t.FRAMEBUFFER,e),$(i)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,l,c,m.__webglTexture,0,B(i)):(c===t.TEXTURE_2D||c>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&c<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,l,c,m.__webglTexture,u),n.bindFramebuffer(t.FRAMEBUFFER,null)}function O(e,n,r){if(t.bindRenderbuffer(t.RENDERBUFFER,e),n.depthBuffer){const i=n.depthTexture,a=i&&i.isDepthTexture?i.type:null,s=x(n.stencilBuffer,a),l=n.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,c=B(n);$(n)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,c,s,n.width,n.height):r?t.renderbufferStorageMultisample(t.RENDERBUFFER,c,s,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,s,n.width,n.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,l,t.RENDERBUFFER,e)}else{const e=n.textures;for(let i=0;i<e.length;i++){const s=e[i],l=a.convert(s.format,s.colorSpace),c=a.convert(s.type),u=y(s.internalFormat,l,c,s.colorSpace),h=B(n);r&&!1===$(n)?t.renderbufferStorageMultisample(t.RENDERBUFFER,h,u,n.width,n.height):$(n)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,h,u,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,u,n.width,n.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function N(e){const i=r.get(e),a=!0===e.isWebGLCubeRenderTarget;if(i.__boundDepthTexture!==e.depthTexture){const t=e.depthTexture;if(i.__depthDisposeCallback&&i.__depthDisposeCallback(),t){const e=()=>{delete i.__boundDepthTexture,delete i.__depthDisposeCallback,t.removeEventListener("dispose",e)};t.addEventListener("dispose",e),i.__depthDisposeCallback=e}i.__boundDepthTexture=t}if(e.depthTexture&&!i.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,i){if(i&&i.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(t.FRAMEBUFFER,e),!i.depthTexture||!i.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const a=r.get(i.depthTexture);a.__renderTarget=i,a.__webglTexture&&i.depthTexture.image.width===i.width&&i.depthTexture.image.height===i.height||(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),S(i.depthTexture,0);const s=a.__webglTexture,l=B(i);if(i.depthTexture.format===st)$(i)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,s,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,s,0);else{if(i.depthTexture.format!==ot)throw new Error("Unknown depthTexture format");$(i)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,s,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,s,0)}}(i.__webglFramebuffer,e)}else if(a){i.__webglDepthbuffer=[];for(let r=0;r<6;r++)if(n.bindFramebuffer(t.FRAMEBUFFER,i.__webglFramebuffer[r]),void 0===i.__webglDepthbuffer[r])i.__webglDepthbuffer[r]=t.createRenderbuffer(),O(i.__webglDepthbuffer[r],e,!1);else{const n=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,a=i.__webglDepthbuffer[r];t.bindRenderbuffer(t.RENDERBUFFER,a),t.framebufferRenderbuffer(t.FRAMEBUFFER,n,t.RENDERBUFFER,a)}}else if(n.bindFramebuffer(t.FRAMEBUFFER,i.__webglFramebuffer),void 0===i.__webglDepthbuffer)i.__webglDepthbuffer=t.createRenderbuffer(),O(i.__webglDepthbuffer,e,!1);else{const n=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,r=i.__webglDepthbuffer;t.bindRenderbuffer(t.RENDERBUFFER,r),t.framebufferRenderbuffer(t.FRAMEBUFFER,n,t.RENDERBUFFER,r)}n.bindFramebuffer(t.FRAMEBUFFER,null)}const U=[],F=[];function B(t){return Math.min(i.maxSamples,t.samples)}function $(t){const n=r.get(t);return t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function K(t,e){const n=t.colorSpace,r=t.format,i=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||n!==$t&&n!==Xt&&(Ie.getTransfer(n)===Zt?r===at&&i===Y||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",n)),e}function J(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement?(c.width=t.naturalWidth||t.width,c.height=t.naturalHeight||t.height):"undefined"!=typeof VideoFrame&&t instanceof VideoFrame?(c.width=t.displayWidth,c.height=t.displayHeight):(c.width=t.width,c.height=t.height),c}this.allocateTextureUnit=function(){const t=E;return t>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+i.maxTextures),E+=1,t},this.resetTextureUnits=function(){E=0},this.setTexture2D=S,this.setTexture2DArray=function(e,i){const a=r.get(e);e.version>0&&a.__version!==e.version?L(a,e,i):n.bindTexture(t.TEXTURE_2D_ARRAY,a.__webglTexture,t.TEXTURE0+i)},this.setTexture3D=function(e,i){const a=r.get(e);e.version>0&&a.__version!==e.version?L(a,e,i):n.bindTexture(t.TEXTURE_3D,a.__webglTexture,t.TEXTURE0+i)},this.setTextureCube=function(e,s){const o=r.get(e);e.version>0&&o.__version!==e.version?function(e,s,o){if(6!==s.image.length)return;const l=I(e,s),c=s.source;n.bindTexture(t.TEXTURE_CUBE_MAP,e.__webglTexture,t.TEXTURE0+o);const u=r.get(c);if(c.version!==u.__version||!0===l){n.activeTexture(t.TEXTURE0+o);const e=Ie.getPrimaries(Ie.workingColorSpace),r=s.colorSpace===Xt?null:Ie.getPrimaries(s.colorSpace),h=s.colorSpace===Xt||e===r?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,s.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,s.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,h);const d=s.isCompressedTexture||s.image[0].isCompressedTexture,p=s.image[0]&&s.image[0].isDataTexture,f=[];for(let t=0;t<6;t++)f[t]=d||p?p?s.image[t].image:s.image[t]:m(s.image[t],!0,i.maxCubemapSize),f[t]=K(s,f[t]);const _=f[0],x=a.convert(s.format,s.colorSpace),w=a.convert(s.type),M=y(s.internalFormat,x,w,s.colorSpace),T=!0!==s.isVideoTexture,E=void 0===u.__version||!0===l,S=c.dataReady;let A,R=b(s,_);if(P(t.TEXTURE_CUBE_MAP,s),d){T&&E&&n.texStorage2D(t.TEXTURE_CUBE_MAP,R,M,_.width,_.height);for(let e=0;e<6;e++){A=f[e].mipmaps;for(let r=0;r<A.length;r++){const i=A[r];s.format!==at?null!==x?T?S&&n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r,0,0,i.width,i.height,x,i.data):n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r,M,i.width,i.height,0,i.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):T?S&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r,0,0,i.width,i.height,x,w,i.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r,M,i.width,i.height,0,x,w,i.data)}}}else{if(A=s.mipmaps,T&&E){A.length>0&&R++;const e=J(f[0]);n.texStorage2D(t.TEXTURE_CUBE_MAP,R,M,e.width,e.height)}for(let e=0;e<6;e++)if(p){T?S&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,f[e].width,f[e].height,x,w,f[e].data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,M,f[e].width,f[e].height,0,x,w,f[e].data);for(let r=0;r<A.length;r++){const i=A[r].image[e].image;T?S&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r+1,0,0,i.width,i.height,x,w,i.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r+1,M,i.width,i.height,0,x,w,i.data)}}else{T?S&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,x,w,f[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,M,x,w,f[e]);for(let r=0;r<A.length;r++){const i=A[r];T?S&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r+1,0,0,x,w,i.image[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,r+1,M,x,w,i.image[e])}}}g(s)&&v(t.TEXTURE_CUBE_MAP),u.__version=c.version,s.onUpdate&&s.onUpdate(s)}e.__version=s.version}(o,e,s):n.bindTexture(t.TEXTURE_CUBE_MAP,o.__webglTexture,t.TEXTURE0+s)},this.rebindTextures=function(e,n,i){const a=r.get(e);void 0!==n&&D(a.__webglFramebuffer,e,e.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),void 0!==i&&N(e)},this.setupRenderTarget=function(e){const i=e.texture,o=r.get(e),l=r.get(i);e.addEventListener("dispose",M);const c=e.textures,u=!0===e.isWebGLCubeRenderTarget,h=c.length>1;if(h||(void 0===l.__webglTexture&&(l.__webglTexture=t.createTexture()),l.__version=i.version,s.memory.textures++),u){o.__webglFramebuffer=[];for(let e=0;e<6;e++)if(i.mipmaps&&i.mipmaps.length>0){o.__webglFramebuffer[e]=[];for(let n=0;n<i.mipmaps.length;n++)o.__webglFramebuffer[e][n]=t.createFramebuffer()}else o.__webglFramebuffer[e]=t.createFramebuffer()}else{if(i.mipmaps&&i.mipmaps.length>0){o.__webglFramebuffer=[];for(let e=0;e<i.mipmaps.length;e++)o.__webglFramebuffer[e]=t.createFramebuffer()}else o.__webglFramebuffer=t.createFramebuffer();if(h)for(let e=0,n=c.length;e<n;e++){const n=r.get(c[e]);void 0===n.__webglTexture&&(n.__webglTexture=t.createTexture(),s.memory.textures++)}if(e.samples>0&&!1===$(e)){o.__webglMultisampledFramebuffer=t.createFramebuffer(),o.__webglColorRenderbuffer=[],n.bindFramebuffer(t.FRAMEBUFFER,o.__webglMultisampledFramebuffer);for(let n=0;n<c.length;n++){const r=c[n];o.__webglColorRenderbuffer[n]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,o.__webglColorRenderbuffer[n]);const i=a.convert(r.format,r.colorSpace),s=a.convert(r.type),l=y(r.internalFormat,i,s,r.colorSpace,!0===e.isXRRenderTarget),u=B(e);t.renderbufferStorageMultisample(t.RENDERBUFFER,u,l,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+n,t.RENDERBUFFER,o.__webglColorRenderbuffer[n])}t.bindRenderbuffer(t.RENDERBUFFER,null),e.depthBuffer&&(o.__webglDepthRenderbuffer=t.createRenderbuffer(),O(o.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(t.FRAMEBUFFER,null)}}if(u){n.bindTexture(t.TEXTURE_CUBE_MAP,l.__webglTexture),P(t.TEXTURE_CUBE_MAP,i);for(let n=0;n<6;n++)if(i.mipmaps&&i.mipmaps.length>0)for(let r=0;r<i.mipmaps.length;r++)D(o.__webglFramebuffer[n][r],e,i,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n,r);else D(o.__webglFramebuffer[n],e,i,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n,0);g(i)&&v(t.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(h){for(let i=0,a=c.length;i<a;i++){const a=c[i],s=r.get(a);n.bindTexture(t.TEXTURE_2D,s.__webglTexture),P(t.TEXTURE_2D,a),D(o.__webglFramebuffer,e,a,t.COLOR_ATTACHMENT0+i,t.TEXTURE_2D,0),g(a)&&v(t.TEXTURE_2D)}n.unbindTexture()}else{let r=t.TEXTURE_2D;if((e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(r=e.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),n.bindTexture(r,l.__webglTexture),P(r,i),i.mipmaps&&i.mipmaps.length>0)for(let n=0;n<i.mipmaps.length;n++)D(o.__webglFramebuffer[n],e,i,t.COLOR_ATTACHMENT0,r,n);else D(o.__webglFramebuffer,e,i,t.COLOR_ATTACHMENT0,r,0);g(i)&&v(r),n.unbindTexture()}e.depthBuffer&&N(e)},this.updateRenderTargetMipmap=function(t){const e=t.textures;for(let i=0,a=e.length;i<a;i++){const a=e[i];if(g(a)){const e=_(t),i=r.get(a).__webglTexture;n.bindTexture(e,i),v(e),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.samples>0)if(!1===$(e)){const i=e.textures,a=e.width,s=e.height;let o=t.COLOR_BUFFER_BIT;const c=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,u=r.get(e),h=i.length>1;if(h)for(let e=0;e<i.length;e++)n.bindFramebuffer(t.FRAMEBUFFER,u.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,null),n.bindFramebuffer(t.FRAMEBUFFER,u.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,null,0);n.bindFramebuffer(t.READ_FRAMEBUFFER,u.__webglMultisampledFramebuffer),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,u.__webglFramebuffer);for(let n=0;n<i.length;n++){if(e.resolveDepthBuffer&&(e.depthBuffer&&(o|=t.DEPTH_BUFFER_BIT),e.stencilBuffer&&e.resolveStencilBuffer&&(o|=t.STENCIL_BUFFER_BIT)),h){t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,u.__webglColorRenderbuffer[n]);const e=r.get(i[n]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)}t.blitFramebuffer(0,0,a,s,0,0,a,s,o,t.NEAREST),!0===l&&(U.length=0,F.length=0,U.push(t.COLOR_ATTACHMENT0+n),e.depthBuffer&&!1===e.resolveDepthBuffer&&(U.push(c),F.push(c),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,F)),t.invalidateFramebuffer(t.READ_FRAMEBUFFER,U))}if(n.bindFramebuffer(t.READ_FRAMEBUFFER,null),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),h)for(let e=0;e<i.length;e++){n.bindFramebuffer(t.FRAMEBUFFER,u.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,u.__webglColorRenderbuffer[e]);const a=r.get(i[e]).__webglTexture;n.bindFramebuffer(t.FRAMEBUFFER,u.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,a,0)}n.bindFramebuffer(t.DRAW_FRAMEBUFFER,u.__webglMultisampledFramebuffer)}else if(e.depthBuffer&&!1===e.resolveDepthBuffer&&l){const n=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[n])}},this.setupDepthRenderbuffer=N,this.setupFrameBufferTexture=D,this.useMultisampledRTT=$}function no(t,e){return{convert:function(n,r=""){let i;const a=Ie.getTransfer(r);if(n===Y)return t.UNSIGNED_BYTE;if(n===nt)return t.UNSIGNED_SHORT_4_4_4_4;if(n===rt)return t.UNSIGNED_SHORT_5_5_5_1;if(35902===n)return t.UNSIGNED_INT_5_9_9_9_REV;if(n===$)return t.BYTE;if(n===K)return t.SHORT;if(n===Z)return t.UNSIGNED_SHORT;if(n===J)return t.INT;if(n===Q)return t.UNSIGNED_INT;if(n===tt)return t.FLOAT;if(n===et)return t.HALF_FLOAT;if(1021===n)return t.ALPHA;if(1022===n)return t.RGB;if(n===at)return t.RGBA;if(1024===n)return t.LUMINANCE;if(1025===n)return t.LUMINANCE_ALPHA;if(n===st)return t.DEPTH_COMPONENT;if(n===ot)return t.DEPTH_STENCIL;if(n===lt)return t.RED;if(n===ct)return t.RED_INTEGER;if(n===ut)return t.RG;if(n===ht)return t.RG_INTEGER;if(n===dt)return t.RGBA_INTEGER;if(n===pt||n===ft||n===mt||n===gt)if(a===Zt){if(i=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===i)return null;if(n===pt)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===ft)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===mt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===gt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(i=e.get("WEBGL_compressed_texture_s3tc"),null===i)return null;if(n===pt)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===ft)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===mt)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===gt)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===vt||n===_t||n===yt||n===xt){if(i=e.get("WEBGL_compressed_texture_pvrtc"),null===i)return null;if(n===vt)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===_t)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===yt)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===xt)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===bt||n===wt||n===Mt){if(i=e.get("WEBGL_compressed_texture_etc"),null===i)return null;if(n===bt||n===wt)return a===Zt?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(n===Mt)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}if(n===Tt||n===Et||n===St||n===At||n===Rt||n===Ct||n===Pt||n===It||n===Lt||n===Dt||n===Ot||n===Nt||n===Ut||n===Ft){if(i=e.get("WEBGL_compressed_texture_astc"),null===i)return null;if(n===Tt)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===Et)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===St)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===At)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Rt)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===Ct)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===Pt)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===It)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===Lt)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===Dt)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Ot)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===Nt)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===Ut)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===Ft)return a===Zt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===Bt||n===kt||n===zt){if(i=e.get("EXT_texture_compression_bptc"),null===i)return null;if(n===Bt)return a===Zt?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===kt)return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===zt)return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(36283===n||n===Ht||n===Gt||n===Vt){if(i=e.get("EXT_texture_compression_rgtc"),null===i)return null;if(n===Bt)return i.COMPRESSED_RED_RGTC1_EXT;if(n===Ht)return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Gt)return i.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===Vt)return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===it?t.UNSIGNED_INT_24_8:void 0!==t[n]?t[n]:null}}}class ro extends pi{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class io extends rr{constructor(){super(),this.isGroup=!0,this.type="Group"}}const ao={type:"move"};class so{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new io,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new io,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Qe,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Qe),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new io,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Qe,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Qe),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let r=null,i=null,a=null;const s=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){a=!0;for(const r of t.hand.values()){const t=e.getJointPose(r,n),i=this._getHandJoint(l,r);null!==t&&(i.matrix.fromArray(t.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.matrixWorldNeedsUpdate=!0,i.jointRadius=t.radius),i.visible=null!==t}const r=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],s=r.position.distanceTo(i.position),o=.02,c=.005;l.inputState.pinching&&s>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&s<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(i=e.getPose(t.gripSpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1));null!==s&&(r=e.getPose(t.targetRaySpace,n),null===r&&null!==i&&(r=i),null!==r&&(s.matrix.fromArray(r.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),s.matrixWorldNeedsUpdate=!0,r.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(r.linearVelocity)):s.hasLinearVelocity=!1,r.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(r.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(ao)))}return null!==s&&(s.visible=null!==r),null!==o&&(o.visible=null!==i),null!==l&&(l.visible=null!==a),this}_getHandJoint(t,e){if(void 0===t.joints[e.jointName]){const n=new io;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class oo{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e,n){if(null===this.texture){const r=new je;t.properties.get(r).__webglTexture=e.texture,e.depthNear==n.depthNear&&e.depthFar==n.depthFar||(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=r}}getMesh(t){if(null!==this.texture&&null===this.mesh){const e=t.cameras[0].viewport,n=new li({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new ei(new Ai(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class lo extends he{constructor(t,e){super();const n=this;let r=null,i=1,a=null,s="local-floor",o=1,l=null,c=null,u=null,h=null,d=null,p=null;const f=new oo,m=e.getContextAttributes();let g=null,v=null;const _=[],y=[],x=new Me;let b=null;const w=new pi;w.viewport=new qe;const M=new pi;M.viewport=new qe;const T=[w,M],E=new ro;let S=null,A=null;function R(t){const e=y.indexOf(t.inputSource);if(-1===e)return;const n=_[e];void 0!==n&&(n.update(t.inputSource,t.frame,l||a),n.dispatchEvent({type:t.type,data:t.inputSource}))}function C(){r.removeEventListener("select",R),r.removeEventListener("selectstart",R),r.removeEventListener("selectend",R),r.removeEventListener("squeeze",R),r.removeEventListener("squeezestart",R),r.removeEventListener("squeezeend",R),r.removeEventListener("end",C),r.removeEventListener("inputsourceschange",P);for(let t=0;t<_.length;t++){const e=y[t];null!==e&&(y[t]=null,_[t].disconnect(e))}S=null,A=null,f.reset(),t.setRenderTarget(g),d=null,h=null,u=null,r=null,v=null,N.stop(),n.isPresenting=!1,t.setPixelRatio(b),t.setSize(x.width,x.height,!1),n.dispatchEvent({type:"sessionend"})}function P(t){for(let e=0;e<t.removed.length;e++){const n=t.removed[e],r=y.indexOf(n);r>=0&&(y[r]=null,_[r].disconnect(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e];let r=y.indexOf(n);if(-1===r){for(let t=0;t<_.length;t++){if(t>=y.length){y.push(n),r=t;break}if(null===y[t]){y[t]=n,r=t;break}}if(-1===r)break}const i=_[r];i&&i.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=_[t];return void 0===e&&(e=new so,_[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=_[t];return void 0===e&&(e=new so,_[t]=e),e.getGripSpace()},this.getHand=function(t){let e=_[t];return void 0===e&&(e=new so,_[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){i=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){s=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||a},this.setReferenceSpace=function(t){l=t},this.getBaseLayer=function(){return null!==h?h:d},this.getBinding=function(){return u},this.getFrame=function(){return p},this.getSession=function(){return r},this.setSession=async function(c){if(r=c,null!==r){if(g=t.getRenderTarget(),r.addEventListener("select",R),r.addEventListener("selectstart",R),r.addEventListener("selectend",R),r.addEventListener("squeeze",R),r.addEventListener("squeezestart",R),r.addEventListener("squeezeend",R),r.addEventListener("end",C),r.addEventListener("inputsourceschange",P),!0!==m.xrCompatible&&await e.makeXRCompatible(),b=t.getPixelRatio(),t.getSize(x),void 0===r.renderState.layers){const n={antialias:m.antialias,alpha:!0,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:i};d=new XRWebGLLayer(r,e,n),r.updateRenderState({baseLayer:d}),t.setPixelRatio(1),t.setSize(d.framebufferWidth,d.framebufferHeight,!1),v=new Ye(d.framebufferWidth,d.framebufferHeight,{format:at,type:Y,colorSpace:t.outputColorSpace,stencilBuffer:m.stencil})}else{let n=null,a=null,s=null;m.depth&&(s=m.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,n=m.stencil?ot:st,a=m.stencil?it:Q);const o={colorFormat:e.RGBA8,depthFormat:s,scaleFactor:i};u=new XRWebGLBinding(r,e),h=u.createProjectionLayer(o),r.updateRenderState({layers:[h]}),t.setPixelRatio(1),t.setSize(h.textureWidth,h.textureHeight,!1),v=new Ye(h.textureWidth,h.textureHeight,{format:at,type:Y,depthTexture:new ca(h.textureWidth,h.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:m.stencil,colorSpace:t.outputColorSpace,samples:m.antialias?4:0,resolveDepthBuffer:!1===h.ignoreDepthValues})}v.isXRRenderTarget=!0,this.setFoveation(o),l=null,a=await r.requestReferenceSpace(s),N.setContext(r),N.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==r)return r.environmentBlendMode},this.getDepthTexture=function(){return f.getDepthTexture()};const I=new Qe,L=new Qe;function D(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===r)return;let e=t.near,n=t.far;null!==f.texture&&(f.depthNear>0&&(e=f.depthNear),f.depthFar>0&&(n=f.depthFar)),E.near=M.near=w.near=e,E.far=M.far=w.far=n,S===E.near&&A===E.far||(r.updateRenderState({depthNear:E.near,depthFar:E.far}),S=E.near,A=E.far),w.layers.mask=2|t.layers.mask,M.layers.mask=4|t.layers.mask,E.layers.mask=w.layers.mask|M.layers.mask;const i=t.parent,a=E.cameras;D(E,i);for(let t=0;t<a.length;t++)D(a[t],i);2===a.length?function(t,e,n){I.setFromMatrixPosition(e.matrixWorld),L.setFromMatrixPosition(n.matrixWorld);const r=I.distanceTo(L),i=e.projectionMatrix.elements,a=n.projectionMatrix.elements,s=i[14]/(i[10]-1),o=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],u=(i[8]-1)/i[0],h=(a[8]+1)/a[0],d=s*u,p=s*h,f=r/(-u+h),m=f*-u;if(e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert(),-1===i[10])t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse);else{const e=s+f,n=o+f,i=d-m,a=p+(r-m),u=l*o/n*e,h=c*o/n*e;t.projectionMatrix.makePerspective(i,a,u,h,e,n),t.projectionMatrixInverse.copy(t.projectionMatrix).invert()}}(E,w,M):E.projectionMatrix.copy(w.projectionMatrix),function(t,e,n){null===n?t.matrix.copy(e.matrixWorld):(t.matrix.copy(n.matrixWorld),t.matrix.invert(),t.matrix.multiply(e.matrixWorld)),t.matrix.decompose(t.position,t.quaternion,t.scale),t.updateMatrixWorld(!0),t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse),t.isPerspectiveCamera&&(t.fov=2*fe*Math.atan(1/t.projectionMatrix.elements[5]),t.zoom=1)}(t,E,i)},this.getCamera=function(){return E},this.getFoveation=function(){if(null!==h||null!==d)return o},this.setFoveation=function(t){o=t,null!==h&&(h.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)},this.hasDepthSensing=function(){return null!==f.texture},this.getDepthSensingMesh=function(){return f.getMesh(E)};let O=null;const N=new Ei;N.setAnimationLoop((function(e,i){if(c=i.getViewerPose(l||a),p=i,null!==c){const e=c.views;null!==d&&(t.setRenderTargetFramebuffer(v,d.framebuffer),t.setRenderTarget(v));let n=!1;e.length!==E.cameras.length&&(E.cameras.length=0,n=!0);for(let r=0;r<e.length;r++){const i=e[r];let a=null;if(null!==d)a=d.getViewport(i);else{const e=u.getViewSubImage(h,i);a=e.viewport,0===r&&(t.setRenderTargetTextures(v,e.colorTexture,h.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(v))}let s=T[r];void 0===s&&(s=new pi,s.layers.enable(r),s.viewport=new qe,T[r]=s),s.matrix.fromArray(i.transform.matrix),s.matrix.decompose(s.position,s.quaternion,s.scale),s.projectionMatrix.fromArray(i.projectionMatrix),s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),s.viewport.set(a.x,a.y,a.width,a.height),0===r&&(E.matrix.copy(s.matrix),E.matrix.decompose(E.position,E.quaternion,E.scale)),!0===n&&E.cameras.push(s)}const i=r.enabledFeatures;if(i&&i.includes("depth-sensing")){const n=u.getDepthInformation(e[0]);n&&n.isValid&&n.texture&&f.init(t,n,r.renderState)}}for(let t=0;t<_.length;t++){const e=y[t],n=_[t];null!==e&&void 0!==n&&n.update(e,i,l||a)}O&&O(e,i),i.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:i}),p=null})),this.setAnimationLoop=function(t){O=t},this.dispose=function(){}}}const co=new zn,uo=new Pn;function ho(t,e){function n(t,e){!0===t.matrixAutoUpdate&&t.updateMatrix(),e.value.copy(t.matrix)}function r(t,r){t.opacity.value=r.opacity,r.color&&t.diffuse.value.copy(r.color),r.emissive&&t.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(t.map.value=r.map,n(r.map,t.mapTransform)),r.alphaMap&&(t.alphaMap.value=r.alphaMap,n(r.alphaMap,t.alphaMapTransform)),r.bumpMap&&(t.bumpMap.value=r.bumpMap,n(r.bumpMap,t.bumpMapTransform),t.bumpScale.value=r.bumpScale,1===r.side&&(t.bumpScale.value*=-1)),r.normalMap&&(t.normalMap.value=r.normalMap,n(r.normalMap,t.normalMapTransform),t.normalScale.value.copy(r.normalScale),1===r.side&&t.normalScale.value.negate()),r.displacementMap&&(t.displacementMap.value=r.displacementMap,n(r.displacementMap,t.displacementMapTransform),t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias),r.emissiveMap&&(t.emissiveMap.value=r.emissiveMap,n(r.emissiveMap,t.emissiveMapTransform)),r.specularMap&&(t.specularMap.value=r.specularMap,n(r.specularMap,t.specularMapTransform)),r.alphaTest>0&&(t.alphaTest.value=r.alphaTest);const i=e.get(r),a=i.envMap,s=i.envMapRotation;a&&(t.envMap.value=a,co.copy(s),co.x*=-1,co.y*=-1,co.z*=-1,a.isCubeTexture&&!1===a.isRenderTargetTexture&&(co.y*=-1,co.z*=-1),t.envMapRotation.value.setFromMatrix4(uo.makeRotationFromEuler(co)),t.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,t.reflectivity.value=r.reflectivity,t.ior.value=r.ior,t.refractionRatio.value=r.refractionRatio),r.lightMap&&(t.lightMap.value=r.lightMap,t.lightMapIntensity.value=r.lightMapIntensity,n(r.lightMap,t.lightMapTransform)),r.aoMap&&(t.aoMap.value=r.aoMap,t.aoMapIntensity.value=r.aoMapIntensity,n(r.aoMap,t.aoMapTransform))}return{refreshFogUniforms:function(e,n){n.color.getRGB(e.fogColor.value,si(t)),n.isFog?(e.fogNear.value=n.near,e.fogFar.value=n.far):n.isFogExp2&&(e.fogDensity.value=n.density)},refreshMaterialUniforms:function(t,i,a,s,o){i.isMeshBasicMaterial||i.isMeshLambertMaterial?r(t,i):i.isMeshToonMaterial?(r(t,i),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,i)):i.isMeshPhongMaterial?(r(t,i),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,i)):i.isMeshStandardMaterial?(r(t,i),function(t,e){t.metalness.value=e.metalness,e.metalnessMap&&(t.metalnessMap.value=e.metalnessMap,n(e.metalnessMap,t.metalnessMapTransform)),t.roughness.value=e.roughness,e.roughnessMap&&(t.roughnessMap.value=e.roughnessMap,n(e.roughnessMap,t.roughnessMapTransform)),e.envMap&&(t.envMapIntensity.value=e.envMapIntensity)}(t,i),i.isMeshPhysicalMaterial&&function(t,e,r){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap,n(e.sheenColorMap,t.sheenColorMapTransform)),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap,n(e.sheenRoughnessMap,t.sheenRoughnessMapTransform))),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap,n(e.clearcoatMap,t.clearcoatMapTransform)),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap,n(e.clearcoatRoughnessMap,t.clearcoatRoughnessMapTransform)),e.clearcoatNormalMap&&(t.clearcoatNormalMap.value=e.clearcoatNormalMap,n(e.clearcoatNormalMap,t.clearcoatNormalMapTransform),t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),1===e.side&&t.clearcoatNormalScale.value.negate())),e.dispersion>0&&(t.dispersion.value=e.dispersion),e.iridescence>0&&(t.iridescence.value=e.iridescence,t.iridescenceIOR.value=e.iridescenceIOR,t.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(t.iridescenceMap.value=e.iridescenceMap,n(e.iridescenceMap,t.iridescenceMapTransform)),e.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=e.iridescenceThicknessMap,n(e.iridescenceThicknessMap,t.iridescenceThicknessMapTransform))),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=r.texture,t.transmissionSamplerSize.value.set(r.width,r.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap,n(e.transmissionMap,t.transmissionMapTransform)),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap,n(e.thicknessMap,t.thicknessMapTransform)),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),e.anisotropy>0&&(t.anisotropyVector.value.set(e.anisotropy*Math.cos(e.anisotropyRotation),e.anisotropy*Math.sin(e.anisotropyRotation)),e.anisotropyMap&&(t.anisotropyMap.value=e.anisotropyMap,n(e.anisotropyMap,t.anisotropyMapTransform))),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap,n(e.specularColorMap,t.specularColorMapTransform)),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap,n(e.specularIntensityMap,t.specularIntensityMapTransform))}(t,i,o)):i.isMeshMatcapMaterial?(r(t,i),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,i)):i.isMeshDepthMaterial?r(t,i):i.isMeshDistanceMaterial?(r(t,i),function(t,n){const r=e.get(n).light;t.referencePosition.value.setFromMatrixPosition(r.matrixWorld),t.nearDistance.value=r.shadow.camera.near,t.farDistance.value=r.shadow.camera.far}(t,i)):i.isMeshNormalMaterial?r(t,i):i.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform))}(t,i),i.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,i)):i.isPointsMaterial?function(t,e,r,i){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*r,t.scale.value=.5*i,e.map&&(t.map.value=e.map,n(e.map,t.uvTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,i,a,s):i.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,i):i.isShadowMaterial?(t.color.value.copy(i.color),t.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function po(t,e,n,r){let i={},a={},s=[];const o=t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);function l(t,e,n,r){const i=t.value,a=e+"_"+n;if(void 0===r[a])return r[a]="number"==typeof i||"boolean"==typeof i?i:i.clone(),!0;{const t=r[a];if("number"==typeof i||"boolean"==typeof i){if(t!==i)return r[a]=i,!0}else if(!1===t.equals(i))return t.copy(i),!0}return!1}function c(t){const e={boundary:0,storage:0};return"number"==typeof t||"boolean"==typeof t?(e.boundary=4,e.storage=4):t.isVector2?(e.boundary=8,e.storage=8):t.isVector3||t.isColor?(e.boundary=16,e.storage=12):t.isVector4?(e.boundary=16,e.storage=16):t.isMatrix3?(e.boundary=48,e.storage=48):t.isMatrix4?(e.boundary=64,e.storage=64):t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",t),e}function u(e){const n=e.target;n.removeEventListener("dispose",u);const r=s.indexOf(n.__bindingPointIndex);s.splice(r,1),t.deleteBuffer(i[n.id]),delete i[n.id],delete a[n.id]}return{bind:function(t,e){const n=e.program;r.uniformBlockBinding(t,n)},update:function(n,h){let d=i[n.id];void 0===d&&(function(t){const e=t.uniforms;let n=0;for(let t=0,r=e.length;t<r;t++){const r=Array.isArray(e[t])?e[t]:[e[t]];for(let t=0,e=r.length;t<e;t++){const e=r[t],i=Array.isArray(e.value)?e.value:[e.value];for(let t=0,r=i.length;t<r;t++){const r=c(i[t]),a=n%16,s=a%r.boundary,o=a+s;n+=s,0!==o&&16-o<r.storage&&(n+=16-o),e.__data=new Float32Array(r.storage/Float32Array.BYTES_PER_ELEMENT),e.__offset=n,n+=r.storage}}}const r=n%16;r>0&&(n+=16-r),t.__size=n,t.__cache={}}(n),d=function(e){const n=function(){for(let t=0;t<o;t++)if(-1===s.indexOf(t))return s.push(t),t;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=n;const r=t.createBuffer(),i=e.__size,a=e.usage;return t.bindBuffer(t.UNIFORM_BUFFER,r),t.bufferData(t.UNIFORM_BUFFER,i,a),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,n,r),r}(n),i[n.id]=d,n.addEventListener("dispose",u));const p=h.program;r.updateUBOMapping(n,p);const f=e.render.frame;a[n.id]!==f&&(function(e){const n=i[e.id],r=e.uniforms,a=e.__cache;t.bindBuffer(t.UNIFORM_BUFFER,n);for(let e=0,n=r.length;e<n;e++){const n=Array.isArray(r[e])?r[e]:[r[e]];for(let r=0,i=n.length;r<i;r++){const i=n[r];if(!0===l(i,e,r,a)){const e=i.__offset,n=Array.isArray(i.value)?i.value:[i.value];let r=0;for(let a=0;a<n.length;a++){const s=n[a],o=c(s);"number"==typeof s||"boolean"==typeof s?(i.__data[0]=s,t.bufferSubData(t.UNIFORM_BUFFER,e+r,i.__data)):s.isMatrix3?(i.__data[0]=s.elements[0],i.__data[1]=s.elements[1],i.__data[2]=s.elements[2],i.__data[3]=0,i.__data[4]=s.elements[3],i.__data[5]=s.elements[4],i.__data[6]=s.elements[5],i.__data[7]=0,i.__data[8]=s.elements[6],i.__data[9]=s.elements[7],i.__data[10]=s.elements[8],i.__data[11]=0):(s.toArray(i.__data,r),r+=o.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,e,i.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}(n),a[n.id]=f)},dispose:function(){for(const e in i)t.deleteBuffer(i[e]);s=[],i={},a={}}}}class fo{constructor(t={}){const{canvas:e=Re(),context:n=null,depth:r=!0,stencil:a=!1,alpha:s=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:h=!1,reverseDepthBuffer:d=!1}=t;let p;if(this.isWebGLRenderer=!0,null!==n){if("undefined"!=typeof WebGLRenderingContext&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=n.getContextAttributes().alpha}else p=s;const f=new Uint32Array(4),m=new Int32Array(4);let g=null,v=null;const _=[],y=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Yt,this.toneMapping=0,this.toneMappingExposure=1;const x=this;let b=!1,w=0,M=0,T=null,E=-1,S=null;const A=new qe,R=new qe;let C=null;const P=new wr(0);let I=0,L=e.width,D=e.height,O=1,N=null,U=null;const F=new qe(0,0,L,D),B=new qe(0,0,L,D);let k=!1;const z=new Ti;let H=!1,G=!1;const V=new Pn,W=new Pn,j=new Qe,q=new qe,$={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let K=!1;function J(){return null===T?O:1}let tt,at,st,ot,lt,ut,pt,ft,mt,gt,vt,_t,yt,xt,bt,wt,Mt,Tt,Et,St,At,Rt,Ct,Pt,It=n;function Lt(t,n){return e.getContext(t,n)}try{const t={alpha:!0,depth:r,stencil:a,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:u,failIfMajorPerformanceCaveat:h};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${i}`),e.addEventListener("webglcontextlost",Nt,!1),e.addEventListener("webglcontextrestored",Ut,!1),e.addEventListener("webglcontextcreationerror",Ft,!1),null===It){const e="webgl2";if(It=Lt(e,t),null===It)throw Lt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function Dt(){tt=new ra(It),tt.init(),Rt=new no(It,tt),at=new Fi(It,tt,t,Rt),st=new Qs(It,tt),at.reverseDepthBuffer&&d&&st.buffers.depth.setReversed(!0),ot=new sa(It),lt=new Bs,ut=new eo(It,tt,st,lt,at,Rt,ot),pt=new ki(x),ft=new na(x),mt=new Si(It),Ct=new Ni(It,mt),gt=new ia(It,mt,ot,Ct),vt=new la(It,gt,mt,ot),Et=new oa(It,at,ut),wt=new Bi(lt),_t=new Fs(x,pt,ft,tt,at,Ct,wt),yt=new ho(x,lt),xt=new Gs,bt=new Ys(tt),Tt=new Oi(x,pt,ft,st,vt,p,l),Mt=new Zs(x,vt,at),Pt=new po(It,ot,at,st),St=new Ui(It,tt,ot),At=new aa(It,tt,ot),ot.programs=_t.programs,x.capabilities=at,x.extensions=tt,x.properties=lt,x.renderLists=xt,x.shadowMap=Mt,x.state=st,x.info=ot}Dt();const Ot=new lo(x,It);function Nt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function Ut(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1;const t=ot.autoReset,e=Mt.enabled,n=Mt.autoUpdate,r=Mt.needsUpdate,i=Mt.type;Dt(),ot.autoReset=t,Mt.enabled=e,Mt.autoUpdate=n,Mt.needsUpdate=r,Mt.type=i}function Ft(t){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",t.statusMessage)}function Bt(t){const e=t.target;e.removeEventListener("dispose",Bt),function(t){(function(t){const e=lt.get(t).programs;void 0!==e&&(e.forEach((function(t){_t.releaseProgram(t)})),t.isShaderMaterial&&_t.releaseShaderCache(t))})(t),lt.remove(t)}(e)}function kt(t,e,n){!0===t.transparent&&2===t.side&&!1===t.forceSinglePass?(t.side=1,t.needsUpdate=!0,Zt(t,e,n),t.side=0,t.needsUpdate=!0,Zt(t,e,n),t.side=2):Zt(t,e,n)}this.xr=Ot,this.getContext=function(){return It},this.getContextAttributes=function(){return It.getContextAttributes()},this.forceContextLoss=function(){const t=tt.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=tt.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(t){void 0!==t&&(O=t,this.setSize(L,D,!1))},this.getSize=function(t){return t.set(L,D)},this.setSize=function(t,n,r=!0){Ot.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(L=t,D=n,e.width=Math.floor(t*O),e.height=Math.floor(n*O),!0===r&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(L*O,D*O).floor()},this.setDrawingBufferSize=function(t,n,r){L=t,D=n,O=r,e.width=Math.floor(t*r),e.height=Math.floor(n*r),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(A)},this.getViewport=function(t){return t.copy(F)},this.setViewport=function(t,e,n,r){t.isVector4?F.set(t.x,t.y,t.z,t.w):F.set(t,e,n,r),st.viewport(A.copy(F).multiplyScalar(O).round())},this.getScissor=function(t){return t.copy(B)},this.setScissor=function(t,e,n,r){t.isVector4?B.set(t.x,t.y,t.z,t.w):B.set(t,e,n,r),st.scissor(R.copy(B).multiplyScalar(O).round())},this.getScissorTest=function(){return k},this.setScissorTest=function(t){st.setScissorTest(k=t)},this.setOpaqueSort=function(t){N=t},this.setTransparentSort=function(t){U=t},this.getClearColor=function(t){return t.copy(Tt.getClearColor())},this.setClearColor=function(){Tt.setClearColor.apply(Tt,arguments)},this.getClearAlpha=function(){return Tt.getClearAlpha()},this.setClearAlpha=function(){Tt.setClearAlpha.apply(Tt,arguments)},this.clear=function(t=!0,e=!0,n=!0){let r=0;if(t){let t=!1;if(null!==T){const e=T.texture.format;t=e===dt||e===ht||e===ct}if(t){const t=T.texture.type,e=t===Y||t===Q||t===Z||t===it||t===nt||t===rt,n=Tt.getClearColor(),r=Tt.getClearAlpha(),i=n.r,a=n.g,s=n.b;e?(f[0]=i,f[1]=a,f[2]=s,f[3]=r,It.clearBufferuiv(It.COLOR,0,f)):(m[0]=i,m[1]=a,m[2]=s,m[3]=r,It.clearBufferiv(It.COLOR,0,m))}else r|=It.COLOR_BUFFER_BIT}e&&(r|=It.DEPTH_BUFFER_BIT),n&&(r|=It.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),It.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Nt,!1),e.removeEventListener("webglcontextrestored",Ut,!1),e.removeEventListener("webglcontextcreationerror",Ft,!1),xt.dispose(),bt.dispose(),lt.dispose(),pt.dispose(),ft.dispose(),vt.dispose(),Ct.dispose(),Pt.dispose(),_t.dispose(),Ot.dispose(),Ot.removeEventListener("sessionstart",Ht),Ot.removeEventListener("sessionend",Gt),Vt.stop()},this.renderBufferDirect=function(t,e,n,r,i,a){null===e&&(e=$);const s=i.isMesh&&i.matrixWorld.determinant()<0,o=function(t,e,n,r,i){!0!==e.isScene&&(e=$),ut.resetTextureUnits();const a=e.fog,s=r.isMeshStandardMaterial?e.environment:null,o=null===T?x.outputColorSpace:!0===T.isXRRenderTarget?T.texture.colorSpace:$t,l=(r.isMeshStandardMaterial?ft:pt).get(r.envMap||s),c=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,u=!!n.attributes.tangent&&(!!r.normalMap||r.anisotropy>0),h=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,p=!!n.morphAttributes.color;let f=0;r.toneMapped&&(null!==T&&!0!==T.isXRRenderTarget||(f=x.toneMapping));const m=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,g=void 0!==m?m.length:0,_=lt.get(r),y=v.state.lights;if(!0===H&&(!0===G||t!==S)){const e=t===S&&r.id===E;wt.setState(r,t,e)}let b=!1;r.version===_.__version?_.needsLights&&_.lightsStateVersion!==y.state.version||_.outputColorSpace!==o||i.isBatchedMesh&&!1===_.batching?b=!0:i.isBatchedMesh||!0!==_.batching?i.isBatchedMesh&&!0===_.batchingColor&&null===i.colorTexture||i.isBatchedMesh&&!1===_.batchingColor&&null!==i.colorTexture||i.isInstancedMesh&&!1===_.instancing?b=!0:i.isInstancedMesh||!0!==_.instancing?i.isSkinnedMesh&&!1===_.skinning?b=!0:i.isSkinnedMesh||!0!==_.skinning?i.isInstancedMesh&&!0===_.instancingColor&&null===i.instanceColor||i.isInstancedMesh&&!1===_.instancingColor&&null!==i.instanceColor||i.isInstancedMesh&&!0===_.instancingMorph&&null===i.morphTexture||i.isInstancedMesh&&!1===_.instancingMorph&&null!==i.morphTexture||_.envMap!==l||!0===r.fog&&_.fog!==a?b=!0:void 0===_.numClippingPlanes||_.numClippingPlanes===wt.numPlanes&&_.numIntersection===wt.numIntersection?(_.vertexAlphas!==c||_.vertexTangents!==u||_.morphTargets!==h||_.morphNormals!==d||_.morphColors!==p||_.toneMapping!==f||_.morphTargetsCount!==g)&&(b=!0):b=!0:b=!0:b=!0:b=!0:(b=!0,_.__version=r.version);let w=_.currentProgram;!0===b&&(w=Zt(r,e,i));let M=!1,A=!1,R=!1;const C=w.getUniforms(),P=_.uniforms;if(st.useProgram(w.program)&&(M=!0,A=!0,R=!0),r.id!==E&&(E=r.id,A=!0),M||S!==t){st.buffers.depth.getReversed()?(V.copy(t.projectionMatrix),function(t){const e=t.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}(V),function(t){const e=t.elements;-1===e[11]?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=1-e[14])}(V),C.setValue(It,"projectionMatrix",V)):C.setValue(It,"projectionMatrix",t.projectionMatrix),C.setValue(It,"viewMatrix",t.matrixWorldInverse);const e=C.map.cameraPosition;void 0!==e&&e.setValue(It,j.setFromMatrixPosition(t.matrixWorld)),at.logarithmicDepthBuffer&&C.setValue(It,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&C.setValue(It,"isOrthographic",!0===t.isOrthographicCamera),S!==t&&(S=t,A=!0,R=!0)}if(i.isSkinnedMesh){C.setOptional(It,i,"bindMatrix"),C.setOptional(It,i,"bindMatrixInverse");const t=i.skeleton;t&&(null===t.boneTexture&&t.computeBoneTexture(),C.setValue(It,"boneTexture",t.boneTexture,ut))}i.isBatchedMesh&&(C.setOptional(It,i,"batchingTexture"),C.setValue(It,"batchingTexture",i._matricesTexture,ut),C.setOptional(It,i,"batchingIdTexture"),C.setValue(It,"batchingIdTexture",i._indirectTexture,ut),C.setOptional(It,i,"batchingColorTexture"),null!==i._colorsTexture&&C.setValue(It,"batchingColorTexture",i._colorsTexture,ut));const I=n.morphAttributes;var L,N;if(void 0===I.position&&void 0===I.normal&&void 0===I.color||Et.update(i,n,w),(A||_.receiveShadow!==i.receiveShadow)&&(_.receiveShadow=i.receiveShadow,C.setValue(It,"receiveShadow",i.receiveShadow)),r.isMeshGouraudMaterial&&null!==r.envMap&&(P.envMap.value=l,P.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1),r.isMeshStandardMaterial&&null===r.envMap&&null!==e.environment&&(P.envMapIntensity.value=e.environmentIntensity),A&&(C.setValue(It,"toneMappingExposure",x.toneMappingExposure),_.needsLights&&(N=R,(L=P).ambientLightColor.needsUpdate=N,L.lightProbe.needsUpdate=N,L.directionalLights.needsUpdate=N,L.directionalLightShadows.needsUpdate=N,L.pointLights.needsUpdate=N,L.pointLightShadows.needsUpdate=N,L.spotLights.needsUpdate=N,L.spotLightShadows.needsUpdate=N,L.rectAreaLights.needsUpdate=N,L.hemisphereLights.needsUpdate=N),a&&!0===r.fog&&yt.refreshFogUniforms(P,a),yt.refreshMaterialUniforms(P,r,O,D,v.state.transmissionRenderTarget[t.id]),fs.upload(It,Jt(_),P,ut)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(fs.upload(It,Jt(_),P,ut),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&C.setValue(It,"center",i.center),C.setValue(It,"modelViewMatrix",i.modelViewMatrix),C.setValue(It,"normalMatrix",i.normalMatrix),C.setValue(It,"modelMatrix",i.matrixWorld),r.isShaderMaterial||r.isRawShaderMaterial){const t=r.uniformsGroups;for(let e=0,n=t.length;e<n;e++){const n=t[e];Pt.update(n,w),Pt.bind(n,w)}}return w}(t,e,n,r,i);st.setMaterial(r,s);let l=n.index,c=1;if(!0===r.wireframe){if(l=gt.getWireframeAttribute(n),void 0===l)return;c=2}const u=n.drawRange,h=n.attributes.position;let d=u.start*c,p=(u.start+u.count)*c;null!==a&&(d=Math.max(d,a.start*c),p=Math.min(p,(a.start+a.count)*c)),null!==l?(d=Math.max(d,0),p=Math.min(p,l.count)):null!=h&&(d=Math.max(d,0),p=Math.min(p,h.count));const f=p-d;if(f<0||f===1/0)return;let m;Ct.setup(i,r,o,n,l);let g=St;if(null!==l&&(m=mt.get(l),g=At,g.setIndex(m)),i.isMesh)!0===r.wireframe?(st.setLineWidth(r.wireframeLinewidth*J()),g.setMode(It.LINES)):g.setMode(It.TRIANGLES);else if(i.isLine){let t=r.linewidth;void 0===t&&(t=1),st.setLineWidth(t*J()),i.isLineSegments?g.setMode(It.LINES):i.isLineLoop?g.setMode(It.LINE_LOOP):g.setMode(It.LINE_STRIP)}else i.isPoints?g.setMode(It.POINTS):i.isSprite&&g.setMode(It.TRIANGLES);if(i.isBatchedMesh)if(null!==i._multiDrawInstances)g.renderMultiDrawInstances(i._multiDrawStarts,i._multiDrawCounts,i._multiDrawCount,i._multiDrawInstances);else if(tt.get("WEBGL_multi_draw"))g.renderMultiDraw(i._multiDrawStarts,i._multiDrawCounts,i._multiDrawCount);else{const t=i._multiDrawStarts,e=i._multiDrawCounts,n=i._multiDrawCount,a=l?mt.get(l).bytesPerElement:1,s=lt.get(r).currentProgram.getUniforms();for(let r=0;r<n;r++)s.setValue(It,"_gl_DrawID",r),g.render(t[r]/a,e[r])}else if(i.isInstancedMesh)g.renderInstances(d,f,i.count);else if(n.isInstancedBufferGeometry){const t=void 0!==n._maxInstanceCount?n._maxInstanceCount:1/0,e=Math.min(n.instanceCount,t);g.renderInstances(d,f,e)}else g.render(d,f)},this.compile=function(t,e,n=null){null===n&&(n=t),v=bt.get(n),v.init(e),y.push(v),n.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(v.pushLight(t),t.castShadow&&v.pushShadow(t))})),t!==n&&t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(v.pushLight(t),t.castShadow&&v.pushShadow(t))})),v.setupLights();const r=new Set;return t.traverse((function(t){if(!(t.isMesh||t.isPoints||t.isLine||t.isSprite))return;const e=t.material;if(e)if(Array.isArray(e))for(let i=0;i<e.length;i++){const a=e[i];kt(a,n,t),r.add(a)}else kt(e,n,t),r.add(e)})),y.pop(),v=null,r},this.compileAsync=function(t,e,n=null){const r=this.compile(t,e,n);return new Promise((e=>{function n(){r.forEach((function(t){lt.get(t).currentProgram.isReady()&&r.delete(t)})),0!==r.size?setTimeout(n,10):e(t)}null!==tt.get("KHR_parallel_shader_compile")?n():setTimeout(n,10)}))};let zt=null;function Ht(){Vt.stop()}function Gt(){Vt.start()}const Vt=new Ei;function Wt(t,e,n,r){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)v.pushLight(t),t.castShadow&&v.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||z.intersectsSprite(t)){r&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);const e=vt.update(t),i=t.material;i.visible&&g.push(t,e,i,n,q.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||z.intersectsObject(t))){const e=vt.update(t),i=t.material;if(r&&(void 0!==t.boundingSphere?(null===t.boundingSphere&&t.computeBoundingSphere(),q.copy(t.boundingSphere.center)):(null===e.boundingSphere&&e.computeBoundingSphere(),q.copy(e.boundingSphere.center)),q.applyMatrix4(t.matrixWorld).applyMatrix4(W)),Array.isArray(i)){const r=e.groups;for(let a=0,s=r.length;a<s;a++){const s=r[a],o=i[s.materialIndex];o&&o.visible&&g.push(t,e,o,n,q.z,s)}}else i.visible&&g.push(t,e,i,n,q.z,null)}const i=t.children;for(let t=0,a=i.length;t<a;t++)Wt(i[t],e,n,r)}function jt(t,e,n,r){const i=t.opaque,a=t.transmissive,s=t.transparent;v.setupLightsView(n),!0===H&&wt.setGlobalState(x.clippingPlanes,n),r&&st.viewport(A.copy(r)),i.length>0&&Xt(i,e,n),a.length>0&&Xt(a,e,n),s.length>0&&Xt(s,e,n),st.buffers.depth.setTest(!0),st.buffers.depth.setMask(!0),st.buffers.color.setMask(!0),st.setPolygonOffset(!1)}function qt(t,e,n,r){if(null!==(!0===n.isScene?n.overrideMaterial:null))return;void 0===v.state.transmissionRenderTarget[r.id]&&(v.state.transmissionRenderTarget[r.id]=new Ye(1,1,{generateMipmaps:!0,type:tt.has("EXT_color_buffer_half_float")||tt.has("EXT_color_buffer_float")?et:Y,minFilter:X,samples:4,stencilBuffer:a,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:Ie.workingColorSpace}));const i=v.state.transmissionRenderTarget[r.id],s=r.viewport||A;i.setSize(s.z,s.w);const o=x.getRenderTarget();x.setRenderTarget(i),x.getClearColor(P),I=x.getClearAlpha(),I<1&&x.setClearColor(16777215,.5),x.clear(),K&&Tt.render(n);const l=x.toneMapping;x.toneMapping=0;const c=r.viewport;if(void 0!==r.viewport&&(r.viewport=void 0),v.setupLightsView(r),!0===H&&wt.setGlobalState(x.clippingPlanes,r),Xt(t,n,r),ut.updateMultisampleRenderTarget(i),ut.updateRenderTargetMipmap(i),!1===tt.has("WEBGL_multisampled_render_to_texture")){let t=!1;for(let i=0,a=e.length;i<a;i++){const a=e[i],s=a.object,o=a.geometry,l=a.material,c=a.group;if(2===l.side&&s.layers.test(r.layers)){const e=l.side;l.side=1,l.needsUpdate=!0,Kt(s,n,r,o,l,c),l.side=e,l.needsUpdate=!0,t=!0}}!0===t&&(ut.updateMultisampleRenderTarget(i),ut.updateRenderTargetMipmap(i))}x.setRenderTarget(o),x.setClearColor(P,I),void 0!==c&&(r.viewport=c),x.toneMapping=l}function Xt(t,e,n){const r=!0===e.isScene?e.overrideMaterial:null;for(let i=0,a=t.length;i<a;i++){const a=t[i],s=a.object,o=a.geometry,l=null===r?a.material:r,c=a.group;s.layers.test(n.layers)&&Kt(s,e,n,o,l,c)}}function Kt(t,e,n,r,i,a){t.onBeforeRender(x,e,n,r,i,a),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),i.onBeforeRender(x,e,n,r,t,a),!0===i.transparent&&2===i.side&&!1===i.forceSinglePass?(i.side=1,i.needsUpdate=!0,x.renderBufferDirect(n,e,r,i,t,a),i.side=0,i.needsUpdate=!0,x.renderBufferDirect(n,e,r,i,t,a),i.side=2):x.renderBufferDirect(n,e,r,i,t,a),t.onAfterRender(x,e,n,r,i,a)}function Zt(t,e,n){!0!==e.isScene&&(e=$);const r=lt.get(t),i=v.state.lights,a=v.state.shadowsArray,s=i.state.version,o=_t.getParameters(t,i.state,a,e,n),l=_t.getProgramCacheKey(o);let c=r.programs;r.environment=t.isMeshStandardMaterial?e.environment:null,r.fog=e.fog,r.envMap=(t.isMeshStandardMaterial?ft:pt).get(t.envMap||r.environment),r.envMapRotation=null!==r.environment&&null===t.envMap?e.environmentRotation:t.envMapRotation,void 0===c&&(t.addEventListener("dispose",Bt),c=new Map,r.programs=c);let u=c.get(l);if(void 0!==u){if(r.currentProgram===u&&r.lightsStateVersion===s)return Qt(t,o),u}else o.uniforms=_t.getUniforms(t),t.onBeforeCompile(o,x),u=_t.acquireProgram(o,l),c.set(l,u),r.uniforms=o.uniforms;const h=r.uniforms;return(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(h.clippingPlanes=wt.uniform),Qt(t,o),r.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),r.lightsStateVersion=s,r.needsLights&&(h.ambientLightColor.value=i.state.ambient,h.lightProbe.value=i.state.probe,h.directionalLights.value=i.state.directional,h.directionalLightShadows.value=i.state.directionalShadow,h.spotLights.value=i.state.spot,h.spotLightShadows.value=i.state.spotShadow,h.rectAreaLights.value=i.state.rectArea,h.ltc_1.value=i.state.rectAreaLTC1,h.ltc_2.value=i.state.rectAreaLTC2,h.pointLights.value=i.state.point,h.pointLightShadows.value=i.state.pointShadow,h.hemisphereLights.value=i.state.hemi,h.directionalShadowMap.value=i.state.directionalShadowMap,h.directionalShadowMatrix.value=i.state.directionalShadowMatrix,h.spotShadowMap.value=i.state.spotShadowMap,h.spotLightMatrix.value=i.state.spotLightMatrix,h.spotLightMap.value=i.state.spotLightMap,h.pointShadowMap.value=i.state.pointShadowMap,h.pointShadowMatrix.value=i.state.pointShadowMatrix),r.currentProgram=u,r.uniformsList=null,u}function Jt(t){if(null===t.uniformsList){const e=t.currentProgram.getUniforms();t.uniformsList=fs.seqWithValue(e.seq,t.uniforms)}return t.uniformsList}function Qt(t,e){const n=lt.get(t);n.outputColorSpace=e.outputColorSpace,n.batching=e.batching,n.batchingColor=e.batchingColor,n.instancing=e.instancing,n.instancingColor=e.instancingColor,n.instancingMorph=e.instancingMorph,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphColors=e.morphColors,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping}Vt.setAnimationLoop((function(t){zt&&zt(t)})),"undefined"!=typeof self&&Vt.setContext(self),this.setAnimationLoop=function(t){zt=t,Ot.setAnimationLoop(t),null===t?Vt.stop():Vt.start()},Ot.addEventListener("sessionstart",Ht),Ot.addEventListener("sessionend",Gt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===b)return;if(!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Ot.enabled&&!0===Ot.isPresenting&&(!0===Ot.cameraAutoUpdate&&Ot.updateCamera(e),e=Ot.getCamera()),!0===t.isScene&&t.onBeforeRender(x,t,e,T),v=bt.get(t,y.length),v.init(e),y.push(v),W.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),z.setFromProjectionMatrix(W),G=this.localClippingEnabled,H=wt.init(this.clippingPlanes,G),g=xt.get(t,_.length),g.init(),_.push(g),!0===Ot.enabled&&!0===Ot.isPresenting){const t=x.xr.getDepthSensingMesh();null!==t&&Wt(t,e,-1/0,x.sortObjects)}Wt(t,e,0,x.sortObjects),g.finish(),!0===x.sortObjects&&g.sort(N,U),K=!1===Ot.enabled||!1===Ot.isPresenting||!1===Ot.hasDepthSensing(),K&&Tt.addToRenderList(g,t),this.info.render.frame++,!0===H&&wt.beginShadows();const n=v.state.shadowsArray;Mt.render(n,t,e),!0===H&&wt.endShadows(),!0===this.info.autoReset&&this.info.reset();const r=g.opaque,i=g.transmissive;if(v.setupLights(),e.isArrayCamera){const n=e.cameras;if(i.length>0)for(let e=0,a=n.length;e<a;e++)qt(r,i,t,n[e]);K&&Tt.render(t);for(let e=0,r=n.length;e<r;e++){const r=n[e];jt(g,t,r,r.viewport)}}else i.length>0&&qt(r,i,t,e),K&&Tt.render(t),jt(g,t,e);null!==T&&(ut.updateMultisampleRenderTarget(T),ut.updateRenderTargetMipmap(T)),!0===t.isScene&&t.onAfterRender(x,t,e),Ct.resetDefaultState(),E=-1,S=null,y.pop(),y.length>0?(v=y[y.length-1],!0===H&&wt.setGlobalState(x.clippingPlanes,v.state.camera)):v=null,_.pop(),g=_.length>0?_[_.length-1]:null},this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return M},this.getRenderTarget=function(){return T},this.setRenderTargetTextures=function(t,e,n){lt.get(t.texture).__webglTexture=e,lt.get(t.depthTexture).__webglTexture=n;const r=lt.get(t);r.__hasExternalTextures=!0,r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||!0===tt.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(t,e){const n=lt.get(t);n.__webglFramebuffer=e,n.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,n=0){T=t,w=e,M=n;let r=!0,i=null,a=!1,s=!1;if(t){const o=lt.get(t);if(void 0!==o.__useDefaultFramebuffer)st.bindFramebuffer(It.FRAMEBUFFER,null),r=!1;else if(void 0===o.__webglFramebuffer)ut.setupRenderTarget(t);else if(o.__hasExternalTextures)ut.rebindTextures(t,lt.get(t.texture).__webglTexture,lt.get(t.depthTexture).__webglTexture);else if(t.depthBuffer){const e=t.depthTexture;if(o.__boundDepthTexture!==e){if(null!==e&&lt.has(e)&&(t.width!==e.image.width||t.height!==e.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");ut.setupDepthRenderbuffer(t)}}const l=t.texture;(l.isData3DTexture||l.isDataArrayTexture||l.isCompressedArrayTexture)&&(s=!0);const c=lt.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=Array.isArray(c[e])?c[e][n]:c[e],a=!0):i=t.samples>0&&!1===ut.useMultisampledRTT(t)?lt.get(t).__webglMultisampledFramebuffer:Array.isArray(c)?c[n]:c,A.copy(t.viewport),R.copy(t.scissor),C=t.scissorTest}else A.copy(F).multiplyScalar(O).floor(),R.copy(B).multiplyScalar(O).floor(),C=k;if(st.bindFramebuffer(It.FRAMEBUFFER,i)&&r&&st.drawBuffers(t,i),st.viewport(A),st.scissor(R),st.setScissorTest(C),a){const r=lt.get(t.texture);It.framebufferTexture2D(It.FRAMEBUFFER,It.COLOR_ATTACHMENT0,It.TEXTURE_CUBE_MAP_POSITIVE_X+e,r.__webglTexture,n)}else if(s){const r=lt.get(t.texture),i=e||0;It.framebufferTextureLayer(It.FRAMEBUFFER,It.COLOR_ATTACHMENT0,r.__webglTexture,n||0,i)}E=-1},this.readRenderTargetPixels=function(t,e,n,r,i,a,s){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=lt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==s&&(o=o[s]),o){st.bindFramebuffer(It.FRAMEBUFFER,o);try{const s=t.texture,o=s.format,l=s.type;if(!at.textureFormatReadable(o))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!at.textureTypeReadable(l))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-r&&n>=0&&n<=t.height-i&&It.readPixels(e,n,r,i,Rt.convert(o),Rt.convert(l),a)}finally{const t=null!==T?lt.get(T).__webglFramebuffer:null;st.bindFramebuffer(It.FRAMEBUFFER,t)}}},this.readRenderTargetPixelsAsync=async function(t,e,n,r,i,a,s){if(!t||!t.isWebGLRenderTarget)throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=lt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==s&&(o=o[s]),o){const s=t.texture,l=s.format,c=s.type;if(!at.textureFormatReadable(l))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!at.textureTypeReadable(c))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(e>=0&&e<=t.width-r&&n>=0&&n<=t.height-i){st.bindFramebuffer(It.FRAMEBUFFER,o);const t=It.createBuffer();It.bindBuffer(It.PIXEL_PACK_BUFFER,t),It.bufferData(It.PIXEL_PACK_BUFFER,a.byteLength,It.STREAM_READ),It.readPixels(e,n,r,i,Rt.convert(l),Rt.convert(c),0);const s=null!==T?lt.get(T).__webglFramebuffer:null;st.bindFramebuffer(It.FRAMEBUFFER,s);const u=It.fenceSync(It.SYNC_GPU_COMMANDS_COMPLETE,0);return It.flush(),await function(t,e){return new Promise((function(n,r){setTimeout((function i(){switch(t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0)){case t.WAIT_FAILED:r();break;case t.TIMEOUT_EXPIRED:setTimeout(i,4);break;default:n()}}),4)}))}(It,u),It.bindBuffer(It.PIXEL_PACK_BUFFER,t),It.getBufferSubData(It.PIXEL_PACK_BUFFER,0,a),It.deleteBuffer(t),It.deleteSync(u),a}throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(t,e=null,n=0){!0!==t.isTexture&&(Pe("WebGLRenderer: copyFramebufferToTexture function signature has changed."),e=arguments[0]||null,t=arguments[1]);const r=Math.pow(2,-n),i=Math.floor(t.image.width*r),a=Math.floor(t.image.height*r),s=null!==e?e.x:0,o=null!==e?e.y:0;ut.setTexture2D(t,0),It.copyTexSubImage2D(It.TEXTURE_2D,n,0,0,s,o,i,a),st.unbindTexture()},this.copyTextureToTexture=function(t,e,n=null,r=null,i=0){let a,s,o,l,c,u,h,d,p;!0!==t.isTexture&&(Pe("WebGLRenderer: copyTextureToTexture function signature has changed."),r=arguments[0]||null,t=arguments[1],e=arguments[2],i=arguments[3]||0,n=null);const f=t.isCompressedTexture?t.mipmaps[i]:t.image;null!==n?(a=n.max.x-n.min.x,s=n.max.y-n.min.y,o=n.isBox3?n.max.z-n.min.z:1,l=n.min.x,c=n.min.y,u=n.isBox3?n.min.z:0):(a=f.width,s=f.height,o=f.depth||1,l=0,c=0,u=0),null!==r?(h=r.x,d=r.y,p=r.z):(h=0,d=0,p=0);const m=Rt.convert(e.format),g=Rt.convert(e.type);let v;e.isData3DTexture?(ut.setTexture3D(e,0),v=It.TEXTURE_3D):e.isDataArrayTexture||e.isCompressedArrayTexture?(ut.setTexture2DArray(e,0),v=It.TEXTURE_2D_ARRAY):(ut.setTexture2D(e,0),v=It.TEXTURE_2D),It.pixelStorei(It.UNPACK_FLIP_Y_WEBGL,e.flipY),It.pixelStorei(It.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),It.pixelStorei(It.UNPACK_ALIGNMENT,e.unpackAlignment);const _=It.getParameter(It.UNPACK_ROW_LENGTH),y=It.getParameter(It.UNPACK_IMAGE_HEIGHT),x=It.getParameter(It.UNPACK_SKIP_PIXELS),b=It.getParameter(It.UNPACK_SKIP_ROWS),w=It.getParameter(It.UNPACK_SKIP_IMAGES);It.pixelStorei(It.UNPACK_ROW_LENGTH,f.width),It.pixelStorei(It.UNPACK_IMAGE_HEIGHT,f.height),It.pixelStorei(It.UNPACK_SKIP_PIXELS,l),It.pixelStorei(It.UNPACK_SKIP_ROWS,c),It.pixelStorei(It.UNPACK_SKIP_IMAGES,u);const M=t.isDataArrayTexture||t.isData3DTexture,T=e.isDataArrayTexture||e.isData3DTexture;if(t.isRenderTargetTexture||t.isDepthTexture){const n=lt.get(t),r=lt.get(e),f=lt.get(n.__renderTarget),m=lt.get(r.__renderTarget);st.bindFramebuffer(It.READ_FRAMEBUFFER,f.__webglFramebuffer),st.bindFramebuffer(It.DRAW_FRAMEBUFFER,m.__webglFramebuffer);for(let n=0;n<o;n++)M&&It.framebufferTextureLayer(It.READ_FRAMEBUFFER,It.COLOR_ATTACHMENT0,lt.get(t).__webglTexture,i,u+n),t.isDepthTexture?(T&&It.framebufferTextureLayer(It.DRAW_FRAMEBUFFER,It.COLOR_ATTACHMENT0,lt.get(e).__webglTexture,i,p+n),It.blitFramebuffer(l,c,a,s,h,d,a,s,It.DEPTH_BUFFER_BIT,It.NEAREST)):T?It.copyTexSubImage3D(v,i,h,d,p+n,l,c,a,s):It.copyTexSubImage2D(v,i,h,d,p+n,l,c,a,s);st.bindFramebuffer(It.READ_FRAMEBUFFER,null),st.bindFramebuffer(It.DRAW_FRAMEBUFFER,null)}else T?t.isDataTexture||t.isData3DTexture?It.texSubImage3D(v,i,h,d,p,a,s,o,m,g,f.data):e.isCompressedArrayTexture?It.compressedTexSubImage3D(v,i,h,d,p,a,s,o,m,f.data):It.texSubImage3D(v,i,h,d,p,a,s,o,m,g,f):t.isDataTexture?It.texSubImage2D(It.TEXTURE_2D,i,h,d,a,s,m,g,f.data):t.isCompressedTexture?It.compressedTexSubImage2D(It.TEXTURE_2D,i,h,d,f.width,f.height,m,f.data):It.texSubImage2D(It.TEXTURE_2D,i,h,d,a,s,m,g,f);It.pixelStorei(It.UNPACK_ROW_LENGTH,_),It.pixelStorei(It.UNPACK_IMAGE_HEIGHT,y),It.pixelStorei(It.UNPACK_SKIP_PIXELS,x),It.pixelStorei(It.UNPACK_SKIP_ROWS,b),It.pixelStorei(It.UNPACK_SKIP_IMAGES,w),0===i&&e.generateMipmaps&&It.generateMipmap(v),st.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n=null,r=null,i=0){return!0!==t.isTexture&&(Pe("WebGLRenderer: copyTextureToTexture3D function signature has changed."),n=arguments[0]||null,r=arguments[1]||null,t=arguments[2],e=arguments[3],i=arguments[4]||0),Pe('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(t,e,n,r,i)},this.initRenderTarget=function(t){void 0===lt.get(t).__webglFramebuffer&&ut.setupRenderTarget(t)},this.initTexture=function(t){t.isCubeTexture?ut.setTextureCube(t,0):t.isData3DTexture?ut.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?ut.setTexture2DArray(t,0):ut.setTexture2D(t,0),st.unbindTexture()},this.resetState=function(){w=0,M=0,T=null,st.reset(),Ct.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return ce}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorspace=Ie._getDrawingBufferColorSpace(t),e.unpackColorSpace=Ie._getUnpackColorSpace()}}class mo extends rr{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new zn,this.environmentIntensity=1,this.environmentRotation=new zn,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class go{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=oe,this.updateRanges=[],this.version=0,this.uuid=me()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let r=0,i=this.stride;r<i;r++)this.array[t+r]=e.array[n+r];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=me()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=me()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const vo=new Qe;class _o{constructor(t,e,n,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)vo.fromBufferAttribute(this,e),vo.applyMatrix4(t),this.setXYZ(e,vo.x,vo.y,vo.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)vo.fromBufferAttribute(this,e),vo.applyNormalMatrix(t),this.setXYZ(e,vo.x,vo.y,vo.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)vo.fromBufferAttribute(this,e),vo.transformDirection(t),this.setXYZ(e,vo.x,vo.y,vo.z);return this}getComponent(t,e){let n=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(n=ye(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=xe(n,this.array)),this.data.array[t*this.data.stride+this.offset+e]=n,this}setX(t,e){return this.normalized&&(e=xe(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=xe(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=xe(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=xe(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=ye(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=ye(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=ye(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=ye(e,this.array)),e}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=xe(e,this.array),n=xe(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=xe(e,this.array),n=xe(n,this.array),r=xe(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this}setXYZW(t,e,n,r,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=xe(e,this.array),n=xe(n,this.array),r=xe(r,this.array),i=xe(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this.data.array[t+3]=i,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new Lr(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new _o(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const yo=new Qe,xo=new qe,bo=new qe,wo=new Qe,Mo=new Pn,To=new Qe,Eo=new bn,So=new Pn,Ao=new Cn;class Ro extends ei{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=O,this.bindMatrix=new Pn,this.bindMatrixInverse=new Pn,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new nn),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,To),this.boundingBox.expandByPoint(To)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new bn),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,To),this.boundingSphere.expandByPoint(To)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const n=this.material,r=this.matrixWorld;void 0!==n&&(null===this.boundingSphere&&this.computeBoundingSphere(),Eo.copy(this.boundingSphere),Eo.applyMatrix4(r),!1!==t.ray.intersectsSphere(Eo)&&(So.copy(r).invert(),Ao.copy(t.ray).applyMatrix4(So),null!==this.boundingBox&&!1===Ao.intersectsBox(this.boundingBox)||this._computeIntersections(t,e,Ao)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new qe,e=this.geometry.attributes.skinWeight;for(let n=0,r=e.count;n<r;n++){t.fromBufferAttribute(e,n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===O?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const n=this.skeleton,r=this.geometry;xo.fromBufferAttribute(r.attributes.skinIndex,t),bo.fromBufferAttribute(r.attributes.skinWeight,t),yo.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const r=bo.getComponent(t);if(0!==r){const i=xo.getComponent(t);Mo.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),e.addScaledVector(wo.copy(yo).applyMatrix4(Mo),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}class Co extends rr{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Po extends je{constructor(t=null,e=1,n=1,r,i,a,s,o,l=1003,c=1003,u,h){super(null,a,s,o,l,c,r,i,u,h),this.isDataTexture=!0,this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Io=new Pn,Lo=new Pn;class Do{constructor(t=[],e=[]){this.uuid=me(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Pn)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Pn;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let r=0,i=t.length;r<i;r++){const i=t[r]?t[r].matrixWorld:Lo;Io.multiplyMatrices(i,e[r]),Io.toArray(n,16*r)}null!==r&&(r.needsUpdate=!0)}clone(){return new Do(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new Po(e,t,t,at,tt);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,r=t.bones.length;n<r;n++){const r=t.bones[n];let i=e[r];void 0===i&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),i=new Co),this.bones.push(i),this.boneInverses.push((new Pn).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let r=0,i=e.length;r<i;r++){const i=e[r];t.bones.push(i.uuid);const a=n[r];t.boneInverses.push(a.toArray())}return t}}class Oo extends Lr{constructor(t,e,n,r=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const No=new Pn,Uo=new Pn,Fo=[],Bo=new nn,ko=new Pn,zo=new ei,Ho=new bn;class Go extends ei{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Oo(new Float32Array(16*n),16),this.instanceColor=null,this.morphTexture=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let t=0;t<n;t++)this.setMatrixAt(t,ko)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new nn),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,No),Bo.copy(t.boundingBox).applyMatrix4(No),this.boundingBox.union(Bo)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new bn),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,No),Ho.copy(t.boundingSphere).applyMatrix4(No),this.boundingSphere.union(Ho)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.morphTexture&&(this.morphTexture=t.morphTexture.clone()),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}getMorphAt(t,e){const n=e.morphTargetInfluences,r=this.morphTexture.source.data.data,i=t*(n.length+1)+1;for(let t=0;t<n.length;t++)n[t]=r[i+t]}raycast(t,e){const n=this.matrixWorld,r=this.count;if(zo.geometry=this.geometry,zo.material=this.material,void 0!==zo.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),Ho.copy(this.boundingSphere),Ho.applyMatrix4(n),!1!==t.ray.intersectsSphere(Ho)))for(let i=0;i<r;i++){this.getMatrixAt(i,No),Uo.multiplyMatrices(n,No),zo.matrixWorld=Uo,zo.raycast(t,Fo);for(let t=0,n=Fo.length;t<n;t++){const n=Fo[t];n.instanceId=i,n.object=this,e.push(n)}Fo.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new Oo(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}setMorphAt(t,e){const n=e.morphTargetInfluences,r=n.length+1;null===this.morphTexture&&(this.morphTexture=new Po(new Float32Array(r*this.count),r,this.count,lt,tt));const i=this.morphTexture.source.data.data;let a=0;for(let t=0;t<n.length;t++)a+=n[t];const s=this.geometry.morphTargetsRelative?1:1-a,o=r*t;i[o]=s,i.set(n,o+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null),this}}class Vo extends Er{static get type(){return"LineBasicMaterial"}constructor(t){super(),this.isLineBasicMaterial=!0,this.color=new wr(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const Wo=new Qe,jo=new Qe,qo=new Pn,Xo=new Cn,Yo=new bn,$o=new Qe,Ko=new Qe;class Zo extends rr{constructor(t=new Vr,e=new Vo){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,r=e.count;t<r;t++)Wo.fromBufferAttribute(e,t-1),jo.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=Wo.distanceTo(jo);t.setAttribute("lineDistance",new Nr(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Line.threshold,a=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Yo.copy(n.boundingSphere),Yo.applyMatrix4(r),Yo.radius+=i,!1===t.ray.intersectsSphere(Yo))return;qo.copy(r).invert(),Xo.copy(t.ray).applyMatrix4(qo);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,l=this.isLineSegments?2:1,c=n.index,u=n.attributes.position;if(null!==c){const n=Math.max(0,a.start),r=Math.min(c.count,a.start+a.count);for(let i=n,a=r-1;i<a;i+=l){const n=c.getX(i),r=c.getX(i+1),a=Jo(this,t,Xo,o,n,r);a&&e.push(a)}if(this.isLineLoop){const i=c.getX(r-1),a=c.getX(n),s=Jo(this,t,Xo,o,i,a);s&&e.push(s)}}else{const n=Math.max(0,a.start),r=Math.min(u.count,a.start+a.count);for(let i=n,a=r-1;i<a;i+=l){const n=Jo(this,t,Xo,o,i,i+1);n&&e.push(n)}if(this.isLineLoop){const i=Jo(this,t,Xo,o,r-1,n);i&&e.push(i)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function Jo(t,e,n,r,i,a){const s=t.geometry.attributes.position;if(Wo.fromBufferAttribute(s,i),jo.fromBufferAttribute(s,a),n.distanceSqToSegment(Wo,jo,$o,Ko)>r)return;$o.applyMatrix4(t.matrixWorld);const o=e.ray.origin.distanceTo($o);return o<e.near||o>e.far?void 0:{distance:o,point:Ko.clone().applyMatrix4(t.matrixWorld),index:i,face:null,faceIndex:null,barycoord:null,object:t}}const Qo=new Qe,tl=new Qe;class el extends Zo{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,r=e.count;t<r;t+=2)Qo.fromBufferAttribute(e,t),tl.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+Qo.distanceTo(tl);t.setAttribute("lineDistance",new Nr(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class nl extends Zo{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class rl extends Er{static get type(){return"PointsMaterial"}constructor(t){super(),this.isPointsMaterial=!0,this.color=new wr(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const il=new Pn,al=new Cn,sl=new bn,ol=new Qe;class ll extends rr{constructor(t=new Vr,e=new rl){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Points.threshold,a=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),sl.copy(n.boundingSphere),sl.applyMatrix4(r),sl.radius+=i,!1===t.ray.intersectsSphere(sl))return;il.copy(r).invert(),al.copy(t.ray).applyMatrix4(il);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,l=n.index,c=n.attributes.position;if(null!==l)for(let n=Math.max(0,a.start),i=Math.min(l.count,a.start+a.count);n<i;n++){const i=l.getX(n);ol.fromBufferAttribute(c,i),cl(ol,i,o,r,t,e,this)}else for(let n=Math.max(0,a.start),i=Math.min(c.count,a.start+a.count);n<i;n++)ol.fromBufferAttribute(c,n),cl(ol,n,o,r,t,e,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function cl(t,e,n,r,i,a,s){const o=al.distanceSqToPoint(t);if(o<n){const n=new Qe;al.closestPointToPoint(t,n),n.applyMatrix4(r);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;a.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,faceIndex:null,barycoord:null,object:s})}}class ul extends Vr{constructor(t=1,e=1,n=1,r=32,i=1,a=!1,s=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:r,heightSegments:i,openEnded:a,thetaStart:s,thetaLength:o};const l=this;r=Math.floor(r),i=Math.floor(i);const c=[],u=[],h=[],d=[];let p=0;const f=[],m=n/2;let g=0;function v(n){const i=p,a=new Me,f=new Qe;let v=0;const _=!0===n?t:e,y=!0===n?1:-1;for(let t=1;t<=r;t++)u.push(0,m*y,0),h.push(0,y,0),d.push(.5,.5),p++;const x=p;for(let t=0;t<=r;t++){const e=t/r*o+s,n=Math.cos(e),i=Math.sin(e);f.x=_*i,f.y=m*y,f.z=_*n,u.push(f.x,f.y,f.z),h.push(0,y,0),a.x=.5*n+.5,a.y=.5*i*y+.5,d.push(a.x,a.y),p++}for(let t=0;t<r;t++){const e=i+t,r=x+t;!0===n?c.push(r,r+1,e):c.push(r+1,r,e),v+=3}l.addGroup(g,v,!0===n?1:2),g+=v}!function(){const a=new Qe,v=new Qe;let _=0;const y=(e-t)/n;for(let l=0;l<=i;l++){const c=[],g=l/i,_=g*(e-t)+t;for(let t=0;t<=r;t++){const e=t/r,i=e*o+s,l=Math.sin(i),f=Math.cos(i);v.x=_*l,v.y=-g*n+m,v.z=_*f,u.push(v.x,v.y,v.z),a.set(l,y,f).normalize(),h.push(a.x,a.y,a.z),d.push(e,1-g),c.push(p++)}f.push(c)}for(let n=0;n<r;n++)for(let r=0;r<i;r++){const a=f[r][n],s=f[r+1][n],o=f[r+1][n+1],l=f[r][n+1];(t>0||0!==r)&&(c.push(a,s,l),_+=3),(e>0||r!==i-1)&&(c.push(s,o,l),_+=3)}l.addGroup(g,_,0),g+=_}(),!1===a&&(t>0&&v(!0),e>0&&v(!1)),this.setIndex(c),this.setAttribute("position",new Nr(u,3)),this.setAttribute("normal",new Nr(h,3)),this.setAttribute("uv",new Nr(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ul(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class hl extends Vr{constructor(t=[],e=[],n=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:r};const i=[],a=[];function s(t,e,n,r){const i=r+1,a=[];for(let r=0;r<=i;r++){a[r]=[];const s=t.clone().lerp(n,r/i),o=e.clone().lerp(n,r/i),l=i-r;for(let t=0;t<=l;t++)a[r][t]=0===t&&r===i?s:s.clone().lerp(o,t/l)}for(let t=0;t<i;t++)for(let e=0;e<2*(i-t)-1;e++){const n=Math.floor(e/2);e%2==0?(o(a[t][n+1]),o(a[t+1][n]),o(a[t][n])):(o(a[t][n+1]),o(a[t+1][n+1]),o(a[t+1][n]))}}function o(t){i.push(t.x,t.y,t.z)}function l(e,n){const r=3*e;n.x=t[r+0],n.y=t[r+1],n.z=t[r+2]}function c(t,e,n,r){r<0&&1===t.x&&(a[e]=t.x-1),0===n.x&&0===n.z&&(a[e]=r/2/Math.PI+.5)}function u(t){return Math.atan2(t.z,-t.x)}!function(t){const n=new Qe,r=new Qe,i=new Qe;for(let a=0;a<e.length;a+=3)l(e[a+0],n),l(e[a+1],r),l(e[a+2],i),s(n,r,i,t)}(r),function(t){const e=new Qe;for(let n=0;n<i.length;n+=3)e.x=i[n+0],e.y=i[n+1],e.z=i[n+2],e.normalize().multiplyScalar(t),i[n+0]=e.x,i[n+1]=e.y,i[n+2]=e.z}(n),function(){const t=new Qe;for(let n=0;n<i.length;n+=3){t.x=i[n+0],t.y=i[n+1],t.z=i[n+2];const r=u(t)/2/Math.PI+.5,s=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);a.push(r,1-s)}var e;(function(){const t=new Qe,e=new Qe,n=new Qe,r=new Qe,s=new Me,o=new Me,l=new Me;for(let h=0,d=0;h<i.length;h+=9,d+=6){t.set(i[h+0],i[h+1],i[h+2]),e.set(i[h+3],i[h+4],i[h+5]),n.set(i[h+6],i[h+7],i[h+8]),s.set(a[d+0],a[d+1]),o.set(a[d+2],a[d+3]),l.set(a[d+4],a[d+5]),r.copy(t).add(e).add(n).divideScalar(3);const p=u(r);c(s,d+0,t,p),c(o,d+2,e,p),c(l,d+4,n,p)}})(),function(){for(let t=0;t<a.length;t+=6){const e=a[t+0],n=a[t+2],r=a[t+4],i=Math.max(e,n,r),s=Math.min(e,n,r);i>.9&&s<.1&&(e<.2&&(a[t+0]+=1),n<.2&&(a[t+2]+=1),r<.2&&(a[t+4]+=1))}}()}(),this.setAttribute("position",new Nr(i,3)),this.setAttribute("normal",new Nr(i.slice(),3)),this.setAttribute("uv",new Nr(a,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new hl(t.vertices,t.indices,t.radius,t.details)}}class dl extends hl{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new dl(t.radius,t.detail)}}class pl extends Vr{constructor(t=1,e=32,n=16,r=0,i=2*Math.PI,a=0,s=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:r,phiLength:i,thetaStart:a,thetaLength:s},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const o=Math.min(a+s,Math.PI);let l=0;const c=[],u=new Qe,h=new Qe,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],v=d/n;let _=0;0===d&&0===a?_=.5/e:d===n&&o===Math.PI&&(_=-.5/e);for(let n=0;n<=e;n++){const o=n/e;u.x=-t*Math.cos(r+o*i)*Math.sin(a+v*s),u.y=t*Math.cos(a+v*s),u.z=t*Math.sin(r+o*i)*Math.sin(a+v*s),p.push(u.x,u.y,u.z),h.copy(u).normalize(),f.push(h.x,h.y,h.z),m.push(o+_,1-v),g.push(l++)}c.push(g)}for(let t=0;t<n;t++)for(let r=0;r<e;r++){const e=c[t][r+1],i=c[t][r],s=c[t+1][r],l=c[t+1][r+1];(0!==t||a>0)&&d.push(e,i,l),(t!==n-1||o<Math.PI)&&d.push(i,s,l)}this.setIndex(d),this.setAttribute("position",new Nr(p,3)),this.setAttribute("normal",new Nr(f,3)),this.setAttribute("uv",new Nr(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new pl(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class fl extends Vr{constructor(t=1,e=.4,n=12,r=48,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:r,arc:i},n=Math.floor(n),r=Math.floor(r);const a=[],s=[],o=[],l=[],c=new Qe,u=new Qe,h=new Qe;for(let a=0;a<=n;a++)for(let d=0;d<=r;d++){const p=d/r*i,f=a/n*Math.PI*2;u.x=(t+e*Math.cos(f))*Math.cos(p),u.y=(t+e*Math.cos(f))*Math.sin(p),u.z=e*Math.sin(f),s.push(u.x,u.y,u.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),h.subVectors(u,c).normalize(),o.push(h.x,h.y,h.z),l.push(d/r),l.push(a/n)}for(let t=1;t<=n;t++)for(let e=1;e<=r;e++){const n=(r+1)*t+e-1,i=(r+1)*(t-1)+e-1,s=(r+1)*(t-1)+e,o=(r+1)*t+e;a.push(n,i,o),a.push(i,s,o)}this.setIndex(a),this.setAttribute("position",new Nr(s,3)),this.setAttribute("normal",new Nr(o,3)),this.setAttribute("uv",new Nr(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new fl(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class ml extends Er{static get type(){return"MeshStandardMaterial"}constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.color=new wr(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wr(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new zn,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class gl extends ml{static get type(){return"MeshPhysicalMaterial"}constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Me(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ge(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new wr(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new wr(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new wr(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class vl extends Er{static get type(){return"MeshLambertMaterial"}constructor(t){super(),this.isMeshLambertMaterial=!0,this.color=new wr(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wr(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Me(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new zn,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}function _l(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)}function yl(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n}function xl(t,e,n){const r=t.length,i=new t.constructor(r);for(let a=0,s=0;s!==r;++a){const r=n[a]*e;for(let n=0;n!==e;++n)i[s++]=t[r+n]}return i}function bl(t,e,n,r){let i=1,a=t[0];for(;void 0!==a&&void 0===a[r];)a=t[i++];if(void 0===a)return;let s=a[r];if(void 0!==s)if(Array.isArray(s))do{s=a[r],void 0!==s&&(e.push(a.time),n.push.apply(n,s)),a=t[i++]}while(void 0!==a);else if(void 0!==s.toArray)do{s=a[r],void 0!==s&&(e.push(a.time),s.toArray(n,n.length)),a=t[i++]}while(void 0!==a);else do{s=a[r],void 0!==s&&(e.push(a.time),n.push(s)),a=t[i++]}while(void 0!==a)}class wl{constructor(t,e,n,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,r=e[n],i=e[n-1];t:{e:{let a;n:{r:if(!(t<r)){for(let a=n+2;;){if(void 0===r){if(t<i)break r;return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===a)break;if(i=r,r=e[++n],t<r)break e}a=e.length;break n}if(t>=i)break t;{const s=e[1];t<s&&(n=2,i=s);for(let a=n-2;;){if(void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(n===a)break;if(r=i,i=e[--n-1],t>=i)break e}a=n,n=0}}for(;n<a;){const r=n+a>>>1;t<e[r]?a=r:n=r+1}if(r=e[n],i=e[n-1],void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===r)return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,t,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=t*r;for(let t=0;t!==r;++t)e[t]=n[i+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Ml extends wl{constructor(t,e,n,r){super(t,e,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(t,e,n){const r=this.parameterPositions;let i=t-2,a=t+1,s=r[i],o=r[a];if(void 0===s)switch(this.getSettings_().endingStart){case 2401:i=t,s=2*e-n;break;case 2402:i=r.length-2,s=e+r[i]-r[i+1];break;default:i=t,s=n}if(void 0===o)switch(this.getSettings_().endingEnd){case 2401:a=t,o=2*n-e;break;case 2402:a=1,o=n+r[1]-r[0];break;default:a=t-1,o=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-s),this._weightNext=l/(o-n),this._offsetPrev=i*c,this._offsetNext=a*c}interpolate_(t,e,n,r){const i=this.resultBuffer,a=this.sampleValues,s=this.valueSize,o=t*s,l=o-s,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-e)/(r-e),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,v=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,_=(-1-d)*m+(1.5+d)*f+.5*p,y=d*m-d*f;for(let t=0;t!==s;++t)i[t]=g*a[c+t]+v*a[l+t]+_*a[o+t]+y*a[u+t];return i}}class Tl extends wl{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const i=this.resultBuffer,a=this.sampleValues,s=this.valueSize,o=t*s,l=o-s,c=(n-e)/(r-e),u=1-c;for(let t=0;t!==s;++t)i[t]=a[l+t]*u+a[o+t]*c;return i}}class El extends wl{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t){return this.copySampleValue_(t-1)}}class Sl{constructor(t,e,n,r){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=_l(e,this.TimeBufferType),this.values=_l(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:_l(t.times,Array),values:_l(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new El(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Tl(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Ml(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Wt:e=this.InterpolantFactoryMethodDiscrete;break;case jt:e=this.InterpolantFactoryMethodLinear;break;case qt:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Wt;case this.InterpolantFactoryMethodLinear:return jt;case this.InterpolantFactoryMethodSmooth:return qt}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this}trim(t,e){const n=this.times,r=n.length;let i=0,a=r-1;for(;i!==r&&n[i]<t;)++i;for(;-1!==a&&n[a]>e;)--a;if(++a,0!==i||a!==r){i>=a&&(a=Math.max(a,1),i=a-1);const t=this.getValueSize();this.times=n.slice(i,a),this.values=this.values.slice(i*t,a*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,i=n.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let e=0;e!==i;e++){const r=n[e];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,r),t=!1;break}if(null!==a&&a>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,r,a),t=!1;break}a=r}if(void 0!==r&&(s=r,ArrayBuffer.isView(s)&&!(s instanceof DataView)))for(let e=0,n=r.length;e!==n;++e){const n=r[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}var s;return t}optimize(){const t=this.times.slice(),e=this.values.slice(),n=this.getValueSize(),r=this.getInterpolation()===qt,i=t.length-1;let a=1;for(let s=1;s<i;++s){let i=!1;const o=t[s];if(o!==t[s+1]&&(1!==s||o!==t[0]))if(r)i=!0;else{const t=s*n,r=t-n,a=t+n;for(let s=0;s!==n;++s){const n=e[t+s];if(n!==e[r+s]||n!==e[a+s]){i=!0;break}}}if(i){if(s!==a){t[a]=t[s];const r=s*n,i=a*n;for(let t=0;t!==n;++t)e[i+t]=e[r+t]}++a}}if(i>0){t[a]=t[i];for(let t=i*n,r=a*n,s=0;s!==n;++s)e[r+s]=e[t+s];++a}return a!==t.length?(this.times=t.slice(0,a),this.values=e.slice(0,a*n)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}Sl.prototype.TimeBufferType=Float32Array,Sl.prototype.ValueBufferType=Float32Array,Sl.prototype.DefaultInterpolation=jt;class Al extends Sl{constructor(t,e,n){super(t,e,n)}}Al.prototype.ValueTypeName="bool",Al.prototype.ValueBufferType=Array,Al.prototype.DefaultInterpolation=Wt,Al.prototype.InterpolantFactoryMethodLinear=void 0,Al.prototype.InterpolantFactoryMethodSmooth=void 0;class Rl extends Sl{}Rl.prototype.ValueTypeName="color";class Cl extends Sl{}Cl.prototype.ValueTypeName="number";class Pl extends wl{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const i=this.resultBuffer,a=this.sampleValues,s=this.valueSize,o=(n-e)/(r-e);let l=t*s;for(let t=l+s;l!==t;l+=4)Je.slerpFlat(i,0,a,l-s,a,l,o);return i}}class Il extends Sl{InterpolantFactoryMethodLinear(t){return new Pl(this.times,this.values,this.getValueSize(),t)}}Il.prototype.ValueTypeName="quaternion",Il.prototype.InterpolantFactoryMethodSmooth=void 0;class Ll extends Sl{constructor(t,e,n){super(t,e,n)}}Ll.prototype.ValueTypeName="string",Ll.prototype.ValueBufferType=Array,Ll.prototype.DefaultInterpolation=Wt,Ll.prototype.InterpolantFactoryMethodLinear=void 0,Ll.prototype.InterpolantFactoryMethodSmooth=void 0;class Dl extends Sl{}Dl.prototype.ValueTypeName="vector";class Ol{constructor(t="",e=-1,n=[],r=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=me(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let t=0,i=n.length;t!==i;++t)e.push(Nl(n[t]).scale(r));const i=new this(t.name,t.duration,e,t.blendMode);return i.uuid=t.uuid,i}static toJSON(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,r=n.length;t!==r;++t)e.push(Sl.toJSON(n[t]));return r}static CreateFromMorphTargetSequence(t,e,n,r){const i=e.length,a=[];for(let t=0;t<i;t++){let s=[],o=[];s.push((t+i-1)%i,t,(t+1)%i),o.push(0,1,0);const l=yl(s);s=xl(s,1,l),o=xl(o,1,l),r||0!==s[0]||(s.push(i),o.push(o[0])),a.push(new Cl(".morphTargetInfluences["+e[t].name+"]",s,o).scale(1/n))}return new this(t,-1,a)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const r={},i=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],a=n.name.match(i);if(a&&a.length>1){const t=a[1];let e=r[t];e||(r[t]=e=[]),e.push(n)}}const a=[];for(const t in r)a.push(this.CreateFromMorphTargetSequence(t,r[t],e,n));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,r,i){if(0!==n.length){const a=[],s=[];bl(n,a,s,r),0!==a.length&&i.push(new t(e,a,s))}},r=[],i=t.name||"default",a=t.fps||30,s=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const i=l[t].keys;if(i&&0!==i.length)if(i[0].morphTargets){const t={};let e;for(e=0;e<i.length;e++)if(i[e].morphTargets)for(let n=0;n<i[e].morphTargets.length;n++)t[i[e].morphTargets[n]]=-1;for(const n in t){const t=[],a=[];for(let r=0;r!==i[e].morphTargets.length;++r){const r=i[e];t.push(r.time),a.push(r.morphTarget===n?1:0)}r.push(new Cl(".morphTargetInfluence["+n+"]",t,a))}o=t.length*a}else{const a=".bones["+e[t].name+"]";n(Dl,a+".position",i,"pos",r),n(Il,a+".quaternion",i,"rot",r),n(Dl,a+".scale",i,"scl",r)}}return 0===r.length?null:new this(i,o,r,s)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Nl(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Cl;case"vector":case"vector2":case"vector3":case"vector4":return Dl;case"color":return Rl;case"quaternion":return Il;case"bool":case"boolean":return Al;case"string":return Ll}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];bl(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const Ul={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class Fl{constructor(t,e,n){const r=this;let i,a=!1,s=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===a&&void 0!==r.onStart&&r.onStart(t,s,o),a=!0},this.itemEnd=function(t){s++,void 0!==r.onProgress&&r.onProgress(t,s,o),s===o&&(a=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(t){void 0!==r.onError&&r.onError(t)},this.resolveURL=function(t){return i?i(t):t},this.setURLModifier=function(t){return i=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],r=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return r}return null}}}const Bl=new Fl;class kl{constructor(t){this.manager=void 0!==t?t:Bl,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(r,i){n.load(t,r,e,i)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}kl.DEFAULT_MATERIAL_NAME="__DEFAULT";const zl={};class Hl extends Error{constructor(t,e){super(t),this.response=e}}class Gl extends kl{constructor(t){super(t)}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=Ul.get(t);if(void 0!==i)return this.manager.itemStart(t),setTimeout((()=>{e&&e(i),this.manager.itemEnd(t)}),0),i;if(void 0!==zl[t])return void zl[t].push({onLoad:e,onProgress:n,onError:r});zl[t]=[],zl[t].push({onLoad:e,onProgress:n,onError:r});const a=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),s=this.mimeType,o=this.responseType;fetch(a).then((e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const n=zl[t],r=e.body.getReader(),i=e.headers.get("X-File-Size")||e.headers.get("Content-Length"),a=i?parseInt(i):0,s=0!==a;let o=0;const l=new ReadableStream({start(t){!function e(){r.read().then((({done:r,value:i})=>{if(r)t.close();else{o+=i.byteLength;const r=new ProgressEvent("progress",{lengthComputable:s,loaded:o,total:a});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(r)}t.enqueue(i),e()}}),(e=>{t.error(e)}))}()}});return new Response(l)}throw new Hl(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)})).then((t=>{switch(o){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,s)));case"json":return t.json();default:if(void 0===s)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(s),n=e&&e[1]?e[1].toLowerCase():void 0,r=new TextDecoder(n);return t.arrayBuffer().then((t=>r.decode(t)))}}})).then((e=>{Ul.add(t,e);const n=zl[t];delete zl[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onLoad&&r.onLoad(e)}})).catch((e=>{const n=zl[t];if(void 0===n)throw this.manager.itemError(t),e;delete zl[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onError&&r.onError(e)}this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Vl extends kl{constructor(t){super(t)}load(t,e,n,r){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,a=Ul.get(t);if(void 0!==a)return i.manager.itemStart(t),setTimeout((function(){e&&e(a),i.manager.itemEnd(t)}),0),a;const s=Ae("img");function o(){c(),Ul.add(t,this),e&&e(this),i.manager.itemEnd(t)}function l(e){c(),r&&r(e),i.manager.itemError(t),i.manager.itemEnd(t)}function c(){s.removeEventListener("load",o,!1),s.removeEventListener("error",l,!1)}return s.addEventListener("load",o,!1),s.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(s.crossOrigin=this.crossOrigin),i.manager.itemStart(t),s.src=t,s}}class Wl extends kl{constructor(t){super(t)}load(t,e,n,r){const i=this,a=new Po,s=new Gl(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(i.withCredentials),s.load(t,(function(t){let n;try{n=i.parse(t)}catch(t){if(void 0===r)return void console.error(t);r(t)}void 0!==n.image?a.image=n.image:void 0!==n.data&&(a.image.width=n.width,a.image.height=n.height,a.image.data=n.data),a.wrapS=void 0!==n.wrapS?n.wrapS:z,a.wrapT=void 0!==n.wrapT?n.wrapT:z,a.magFilter=void 0!==n.magFilter?n.magFilter:j,a.minFilter=void 0!==n.minFilter?n.minFilter:j,a.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.colorSpace&&(a.colorSpace=n.colorSpace),void 0!==n.flipY&&(a.flipY=n.flipY),void 0!==n.format&&(a.format=n.format),void 0!==n.type&&(a.type=n.type),void 0!==n.mipmaps&&(a.mipmaps=n.mipmaps,a.minFilter=X),1===n.mipmapCount&&(a.minFilter=j),void 0!==n.generateMipmaps&&(a.generateMipmaps=n.generateMipmaps),a.needsUpdate=!0,e&&e(a,n)}),n,r),a}}class jl extends kl{constructor(t){super(t)}load(t,e,n,r){const i=new je,a=new Vl(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,(function(t){i.image=t,i.needsUpdate=!0,void 0!==e&&e(i)}),n,r),i}}class ql extends rr{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new wr(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),void 0!==this.target&&(e.object.target=this.target.uuid),e}}const Xl=new Pn,Yl=new Qe,$l=new Qe;class Kl{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Me(512,512),this.map=null,this.mapPass=null,this.matrix=new Pn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ti,this._frameExtents=new Me(1,1),this._viewportCount=1,this._viewports=[new qe(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Yl.setFromMatrixPosition(t.matrixWorld),e.position.copy(Yl),$l.setFromMatrixPosition(t.target.matrixWorld),e.lookAt($l),e.updateMatrixWorld(),Xl.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Xl),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(Xl)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 1!==this.intensity&&(t.intensity=this.intensity),0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Zl extends Kl{constructor(){super(new pi(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,n=2*fe*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=t.distance||e.far;n===e.fov&&r===e.aspect&&i===e.far||(e.fov=n,e.aspect=r,e.far=i,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Jl extends ql{constructor(t,e,n=0,r=Math.PI/3,i=0,a=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(rr.DEFAULT_UP),this.updateMatrix(),this.target=new rr,this.distance=n,this.angle=r,this.penumbra=i,this.decay=a,this.map=null,this.shadow=new Zl}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Ql=new Pn,tc=new Qe,ec=new Qe;class nc extends Kl{constructor(){super(new pi(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Me(4,2),this._viewportCount=6,this._viewports=[new qe(2,1,1,1),new qe(0,1,1,1),new qe(3,1,1,1),new qe(1,1,1,1),new qe(3,0,1,1),new qe(1,0,1,1)],this._cubeDirections=[new Qe(1,0,0),new Qe(-1,0,0),new Qe(0,0,1),new Qe(0,0,-1),new Qe(0,1,0),new Qe(0,-1,0)],this._cubeUps=[new Qe(0,1,0),new Qe(0,1,0),new Qe(0,1,0),new Qe(0,1,0),new Qe(0,0,1),new Qe(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,r=this.matrix,i=t.distance||n.far;i!==n.far&&(n.far=i,n.updateProjectionMatrix()),tc.setFromMatrixPosition(t.matrixWorld),n.position.copy(tc),ec.copy(n.position),ec.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(ec),n.updateMatrixWorld(),r.makeTranslation(-tc.x,-tc.y,-tc.z),Ql.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ql)}}class rc extends ql{constructor(t,e,n=0,r=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new nc}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class ic extends Kl{constructor(){super(new zi(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class ac extends ql{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(rr.DEFAULT_UP),this.updateMatrix(),this.target=new rr,this.shadow=new ic}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class sc{static decodeText(t){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),"undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class oc extends kl{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,a=Ul.get(t);if(void 0!==a)return i.manager.itemStart(t),a.then?void a.then((n=>{e&&e(n),i.manager.itemEnd(t)})).catch((t=>{r&&r(t)})):(setTimeout((function(){e&&e(a),i.manager.itemEnd(t)}),0),a);const s={};s.credentials="anonymous"===this.crossOrigin?"same-origin":"include",s.headers=this.requestHeader;const o=fetch(t,s).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(i.options,{colorSpaceConversion:"none"}))})).then((function(n){return Ul.add(t,n),e&&e(n),i.manager.itemEnd(t),n})).catch((function(e){r&&r(e),Ul.remove(t),i.manager.itemError(t),i.manager.itemEnd(t)}));Ul.add(t,o),i.manager.itemStart(t)}}class lc{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=cc(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=cc();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function cc(){return performance.now()}const uc="\\[\\]\\.:\\/",hc=new RegExp("["+uc+"]","g"),dc="[^"+uc+"]",pc="[^"+uc.replace("\\.","")+"]",fc=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",dc)+/(WCOD+)?/.source.replace("WCOD",pc)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",dc)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",dc)+"$"),mc=["material","materials","bones","map"];class gc{constructor(t,e,n){this.path=e,this.parsedPath=n||gc.parseTrackName(e),this.node=gc.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new gc.Composite(t,e,n):new gc(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(hc,"")}static parseTrackName(t){const e=fc.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const t=n.nodeName.substring(r+1);-1!==mc.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let r=0;r<t.length;r++){const i=t[r];if(i.name===e||i.uuid===e)return i;const a=n(i.children);if(a)return a}return null},r=n(t.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)t[e++]=n[r]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,r=e.propertyName;let i=e.propertyIndex;if(t||(t=gc.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");if(n){let r=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===r){r=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);t=t.material.map;break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==r){if(void 0===t[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[r]}}const a=t[r];if(void 0===a){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",t)}let s=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?s=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(s=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===r){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[i]&&(i=t.morphTargetDictionary[i])}o=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=i}else void 0!==a.fromArray&&void 0!==a.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(o=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=r;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][s]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}gc.Composite=class{constructor(t,e,n){const r=n||gc.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},gc.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},gc.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},gc.prototype.GetterByBindingType=[gc.prototype._getValue_direct,gc.prototype._getValue_array,gc.prototype._getValue_arrayElement,gc.prototype._getValue_toArray],gc.prototype.SetterByBindingTypeAndVersioning=[[gc.prototype._setValue_direct,gc.prototype._setValue_direct_setNeedsUpdate,gc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[gc.prototype._setValue_array,gc.prototype._setValue_array_setNeedsUpdate,gc.prototype._setValue_array_setMatrixWorldNeedsUpdate],[gc.prototype._setValue_arrayElement,gc.prototype._setValue_arrayElement_setNeedsUpdate,gc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[gc.prototype._setValue_fromArray,gc.prototype._setValue_fromArray_setNeedsUpdate,gc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]],new Float32Array(1);const vc=new Pn;function _c(t,e){return t.distance-e.distance}function yc(t,e,n,r){let i=!0;if(t.layers.test(e.layers)&&!1===t.raycast(e,n)&&(i=!1),!0===i&&!0===r){const r=t.children;for(let t=0,i=r.length;t<i;t++)yc(r[t],e,n,!0)}}class xc{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(ge(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}const bc=new Qe,wc=new Qe;class Mc{constructor(t=new Qe,e=new Qe){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){bc.subVectors(t,this.start),wc.subVectors(this.end,this.start);const n=wc.dot(wc);let r=wc.dot(bc)/n;return e&&(r=ge(r,0,1)),r}closestPointToPoint(t,e,n){const r=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}class Tc extends he{constructor(t,e=null){super(),this.object=t,this.domElement=e,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:i}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=i);class Ec{createThreeGeometry(t){const e=new Vr;if(e.setIndex(new Or(t.indices,1)),e.setAttribute("position",new Nr(t.vertices,3)),e.setAttribute("normal",new Nr(t.normals,3)),e.setAttribute("uv",new Nr(t.uvCoords,2)),e.scale(.001,.001,.001),e.rotateX(-Math.PI/2),e.attributes.uv&&t.uvTransform&&!(0,r.isUVIdentityMatrix)(t.uvTransform)){const n=Cc(t.uvTransform);e.attributes.uv.applyMatrix4(n)}return e}}const Sc=t=>new Qe(t[0]/1e3,t[2]/1e3,t[1]/-1e3),Ac=t=>new Qe(t.x/1e3,t.z/1e3,t.y/-1e3),Rc=t=>{let n=new Pn,r=(0,e.convertCObject)(t);return n.fromArray(r),n.transpose(),(t=>{let e=new Pn;e.set(1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1),e.scale(new Qe(.001,.001,.001));let n=new Pn;return n.set(1,0,0,0,0,0,-1,0,0,1,0,0,0,0,0,1),n.scale(new Qe(1e3,1e3,1e3)),e.multiply(t).multiply(n)})(n)},Cc=t=>{const e=new Pn;return e.set(t[0],t[2],0,t[4],t[1],t[3],0,t[5],0,0,1,0,0,0,0,1),e};const Pc=(t,e)=>void 0===t?e:t;class Ic{constructor(){this.textureLoader=new jl}get textureLoaderInstance(){return this.textureLoader}createThreeMaterial(t,e){const n=new gl,r=Lc(n,e);if(e.diffuseMap){const i=t=>{this.setTextureProperties(t,e.diffuseMap),n.map=t};this.loadAndSetTexture(i,e.diffuseMap.url,n.color),n.transparent=e.diffuseMapHasAlpha;const a=!r&&t.includes("glow");e.diffuseMapHasAlpha&&a&&(n.emissiveIntensity=1,n.emissive=new wr(16777215),n.emissiveMap=n.map)}if(e.normalMap){const t=t=>{this.setTextureProperties(t,e.normalMap),n.normalMap=t,n.normalMapType=0};this.loadAndSetTexture(t,e.normalMap.url)}if(e.ormMap){const t=t=>{this.setTextureProperties(t,e.ormMap),n.aoMap=t,n.roughnessMap=t,n.metalnessMap=t};this.loadAndSetTexture(t,e.ormMap.url)}if(e.emrgbMap){const t=t=>{this.setTextureProperties(t,e.emrgbMap),n.emissiveMap=t};this.loadAndSetTexture(t,e.emrgbMap.url)}if(e.ccrgMap){const t=t=>{this.setTextureProperties(t,e.ccrgMap),n.clearcoatRoughnessMap=t};this.loadAndSetTexture(t,e.ccrgMap.url)}if(e.ccxyzMap){const t=t=>{this.setTextureProperties(t,e.ccxyzMap),n.clearcoatNormalMap=t};this.loadAndSetTexture(t,e.ccxyzMap.url)}if(e.shrgbaMap){const t=t=>{this.setTextureProperties(t,e.shrgbaMap),n.sheenRoughnessMap=t};this.loadAndSetTexture(t,e.shrgbaMap.url)}if(e.sprgbaMap){const t=t=>{this.setTextureProperties(t,e.sprgbaMap),n.sheenColorMap=t};this.loadAndSetTexture(t,e.sprgbaMap.url)}if(e.ttrgMap){const t=t=>{this.setTextureProperties(t,e.ttrgMap),n.thicknessMap=t,n.transmissionMap=t};this.loadAndSetTexture(t,e.ttrgMap.url)}return void 0!==e.shading.transmissionIOR&&(n.ior=1+e.shading.transmissionIOR),n.envMapIntensity=2,n}setTextureProperties(t,e){if(t.anisotropy=16,t.wrapS=k,t.wrapT=k,e){let n=0===e.mmWidth?1e3:e.mmWidth,r=0===e.mmHeight?1e3:e.mmHeight;t.repeat.set(1/n,1/r)}}loadAndSetTexture(t,e,n){return r=this,i=void 0,s=function*(){if(n&&t(this.createUniformColorTexture(n)),e){const n=yield this.textureLoader.loadAsync(e);t(n)}},new((a=void 0)||(a=Promise))((function(t,e){function n(t){try{l(s.next(t))}catch(t){e(t)}}function o(t){try{l(s.throw(t))}catch(t){e(t)}}function l(e){var r;e.done?t(e.value):(r=e.value,r instanceof a?r:new a((function(t){t(r)}))).then(n,o)}l((s=s.apply(r,i||[])).next())}));var r,i,a,s}createUniformColorTexture(t){const e=new Uint8Array([Math.floor(255*t.r),Math.floor(255*t.g),Math.floor(255*t.b),255]),n=new Po(e,1,1);return n.needsUpdate=!0,n}}const Lc=(t,e)=>{var n;const r="2"===e.shading.version||(null===(n=e.shading.version)||void 0===n?void 0:n.startsWith("2."));return t=r?Oc(t,e):Dc(t,e),null!=r&&r},Dc=(t,e)=>{void 0!==e.shading.metallic&&(t.metalness=1===e.shading.metallic?1:.5,t.reflectivity=Pc(e.shading.metallic,.5));let n=!1;return e.shading.transmission&&e.shading.transmission>0?(t.opacity=1-e.shading.transmission,t.transparent=!0,t.depthWrite=!1,t.metalness=0,n=!0):void 0!==e.shading.alpha&&e.shading.alpha<1&&(t.transparent=e.shading.alpha<1,t.opacity=e.shading.alpha,t.depthWrite=e.shading.alpha>=1,t.metalness=.5*Math.max(0,e.shading.alpha),n=!0),t.aoMapIntensity=Pc(e.shading.occlusion,1),t.roughness=Pc(e.shading.roughness,.5),t.alphaTest=Pc(e.shading.alphaCutoff,0),Nc(t.color,e.shading.basecolor),n||e.shading.doubleSided?t.side=2:t.side=0,t},Oc=(t,e)=>{var n,r,i,a,s,o,l,c,u,h,d,p,f;let m=!1;return void 0!==e.shading.alpha&&e.shading.alpha<1?(t.transparent=!0,t.opacity=e.shading.alpha,t.depthWrite=!1,m=!0):(t.transparent=!1,t.opacity=1,t.depthWrite=!0),t.alphaTest=null!==(n=e.shading.alphaCutoff)&&void 0!==n?n:0,Nc(t.color,e.shading.basecolor),t.transmission=null!==(r=e.shading.transmission)&&void 0!==r?r:0,t.metalness=null!==(i=e.shading.metallic)&&void 0!==i?i:0,Nc(t.specularColor,e.shading.specularColor),t.specularIntensity=null!==(a=e.shading.specularity)&&void 0!==a?a:0,t.roughness=null!==(s=e.shading.roughness)&&void 0!==s?s:0,t.aoMapIntensity=null!==(o=e.shading.occlusion)&&void 0!==o?o:1,Nc(t.emissive,e.shading.emissiveColor),t.emissiveIntensity=null!==(l=e.shading.emissiveIntensity)&&void 0!==l?l:1,t.clearcoat=null!==(c=e.shading.clearcoatIntensity)&&void 0!==c?c:0,t.clearcoatRoughness=null!==(u=e.shading.clearcoatRoughness)&&void 0!==u?u:0,t.clearcoatNormalScale.setScalar(null!==(h=e.shading.clearcoatNormalScale)&&void 0!==h?h:1),Nc(t.sheenColor,e.shading.sheenColor),t.sheen=null!==(d=e.shading.sheenIntensity)&&void 0!==d?d:1,t.sheenRoughness=null!==(p=e.shading.sheenRoughness)&&void 0!==p?p:1,t.thickness=null!==(f=e.shading.thicknessFactor)&&void 0!==f?f:0,Nc(t.attenuationColor,e.shading.attenuationColor),e.shading.attenuationDistance&&(t.attenuationDistance=e.shading.attenuationDistance),t.side=m||e.shading.doubleSided?2:0,t},Nc=(t,e)=>{if(void 0!==e){const n=new wr(e.r,e.g,e.b);t.copy(n.convertSRGBToLinear())}},Uc=t=>{const e=new io;return t.forEach((t=>{const n=new ei(t.geometry,t.material);t.transform&&n.applyMatrix4(t.transform),n.castShadow=!t.environment,n.receiveShadow=!0,e.add(n)})),e};class Fc{constructor(t,e){this._materialFactory=null!=t?t:new Ic,this._geometryFactory=null!=e?e:new Ec}constructThreeMesh(t){const e=new vl({color:8421504,side:2}),n=[],r=t.materialProperties.map((t=>{const e=this._materialFactory.createThreeMaterial(t.specification.id,t.properties);return e.userData=Object.assign(Object.assign({},e.userData),t.properties),e.name=t.specification.id,n.push({materialId:t.specification.id,material:e}),{material:e,properties:t.properties,specification:t.specification}})),i=t.meshData.meshes.map((t=>({geometry:this._geometryFactory.createThreeGeometry(t),specification:t}))),a=[];return i.forEach((n=>{var i;const s=t.planComponents.find((t=>t.id===n.specification.runtimeComponentId)),o=this.calculateThreeTransformation(s,n.specification),l=r.find((t=>t.specification.id===n.specification.materialId)),c=this.updateMaterialProperties(null!==(i=null==l?void 0:l.material)&&void 0!==i?i:e,n.specification.materialAttributes);a.push({geometry:n.geometry,material:c,transform:o,materialId:n.specification.materialId,environment:n.specification.environmentGeometry})})),{geometryAndMaterial:a,materials:n}}updateMaterialProperties(t,e){if(e&&Object.keys(e).length>0&&t instanceof ml){const n=t.clone();return n.userData.materialAttributes=e,this._updateStandardMaterialProperties(n,e),n instanceof gl&&this._updatePhysicalMaterialProperties(n,e),n.transparent=n.opacity<1,n}return t}_updateStandardMaterialProperties(t,e){e.color&&(t.color=new wr(e.color)),e.alpha&&(t.opacity=parseFloat(e.alpha)),e.roughness&&(t.roughness=parseFloat(e.roughness)),e.metallic&&(t.metalness=parseFloat(e.metallic)),e.normalScale&&t.normalScale.setScalar(parseFloat(e.normalScale)),e.alphaCutoff&&(t.alphaTest=parseFloat(e.alphaCutoff)),e.doubleSided&&(t.side=e.doubleSided?2:0),e.occlusion&&(t.aoMapIntensity=parseFloat(e.occlusion)),e.emissiveColor&&(t.emissive=new wr(e.emissiveColor)),e.emissiveIntensity&&(t.emissiveIntensity=parseFloat(e.emissiveIntensity))}_updatePhysicalMaterialProperties(t,e){e.transmission&&(t.transmission=parseFloat(e.transmission)),e.specularColor&&(t.specularColor=new wr(e.specularColor)),e.specularity&&(t.specularIntensity=parseFloat(e.specularity)),e.clearcoatIntensity&&(t.clearcoat=parseFloat(e.clearcoatIntensity)),e.clearcoatRoughness&&(t.clearcoatRoughness=parseFloat(e.clearcoatRoughness)),e.clearcoatNormalScale&&t.clearcoatNormalScale.setScalar(parseFloat(e.clearcoatNormalScale)),e.sheenColor&&(t.sheenColor=new wr(e.sheenColor)),e.sheenIntensity&&(t.sheen=parseFloat(e.sheenIntensity)),e.sheenRoughness&&(t.sheenRoughness=parseFloat(e.sheenRoughness)),e.thicknessFactor&&(t.thickness=parseFloat(e.thicknessFactor)),e.attenuationColor&&(t.attenuationColor=new wr(e.attenuationColor)),e.attenuationDistance&&(t.attenuationDistance=parseFloat(e.attenuationDistance))}calculateThreeTransformation(t,e){let n=new Pn;if(t){const e=new Float32Array(t.planComponent.globalTransform.m);n=Rc(e)}if(e.transform){const t=Rc(e.transform);n.multiply(t)}return n}}class Bc extends kl{loadAsync(e,n){return r=this,i=void 0,s=function*(){const r=yield t.p.newGeometryConstructor({},null!=n?n:{locateFile(t,e){const n=(t.endsWith(".wasm")?"./":e)+t;return console.log("loading file: "+n),n}}),i=yield r.constructMesh(e),a=(new Fc).constructThreeMesh(i);return{scene:Uc(a.geometryAndMaterial)}},new((a=void 0)||(a=Promise))((function(t,e){function n(t){try{l(s.next(t))}catch(t){e(t)}}function o(t){try{l(s.throw(t))}catch(t){e(t)}}function l(e){var r;e.done?t(e.value):(r=e.value,r instanceof a?r:new a((function(t){t(r)}))).then(n,o)}l((s=s.apply(r,i||[])).next())}));var r,i,a,s}}var kc=n(905),zc=n(149);function Hc(t,e){if(0===e)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(2===e||1===e){let n=t.getIndex();if(null===n){const e=[],r=t.getAttribute("position");if(void 0===r)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<r.count;t++)e.push(t);t.setIndex(e),n=t.getIndex()}const r=n.count-2,i=[];if(2===e)for(let t=1;t<=r;t++)i.push(n.getX(0)),i.push(n.getX(t)),i.push(n.getX(t+1));else for(let t=0;t<r;t++)t%2==0?(i.push(n.getX(t)),i.push(n.getX(t+1)),i.push(n.getX(t+2))):(i.push(n.getX(t+2)),i.push(n.getX(t+1)),i.push(n.getX(t)));i.length/3!==r&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=t.clone();return a.setIndex(i),a.clearGroups(),a}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}class Gc extends kl{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(t){return new Yc(t)})),this.register((function(t){return new $c(t)})),this.register((function(t){return new iu(t)})),this.register((function(t){return new au(t)})),this.register((function(t){return new su(t)})),this.register((function(t){return new Zc(t)})),this.register((function(t){return new Jc(t)})),this.register((function(t){return new Qc(t)})),this.register((function(t){return new tu(t)})),this.register((function(t){return new Xc(t)})),this.register((function(t){return new eu(t)})),this.register((function(t){return new Kc(t)})),this.register((function(t){return new ru(t)})),this.register((function(t){return new nu(t)})),this.register((function(t){return new jc(t)})),this.register((function(t){return new ou(t)})),this.register((function(t){return new lu(t)}))}load(t,e,n,r){const i=this;let a;if(""!==this.resourcePath)a=this.resourcePath;else if(""!==this.path){const e=sc.extractUrlBase(t);a=sc.resolveURL(e,this.path)}else a=sc.extractUrlBase(t);this.manager.itemStart(t);const s=function(e){r?r(e):console.error(e),i.manager.itemError(t),i.manager.itemEnd(t)},o=new Gl(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,(function(n){try{i.parse(n,a,(function(n){e(n),i.manager.itemEnd(t)}),s)}catch(t){s(t)}}),n,s)}setDRACOLoader(t){return this.dracoLoader=t,this}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,r){let i;const a={},s={},o=new TextDecoder;if("string"==typeof t)i=JSON.parse(t);else if(t instanceof ArrayBuffer)if(o.decode(new Uint8Array(t,0,4))===cu){try{a[Wc.KHR_BINARY_GLTF]=new uu(t)}catch(t){return void(r&&r(t))}i=JSON.parse(a[Wc.KHR_BINARY_GLTF].content)}else i=JSON.parse(o.decode(t));else i=t;if(void 0===i.asset||i.asset.version[0]<2)return void(r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new Lu(i,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let t=0;t<this.pluginCallbacks.length;t++){const e=this.pluginCallbacks[t](l);e.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),s[e.name]=e,a[e.name]=!0}if(i.extensionsUsed)for(let t=0;t<i.extensionsUsed.length;++t){const e=i.extensionsUsed[t],n=i.extensionsRequired||[];switch(e){case Wc.KHR_MATERIALS_UNLIT:a[e]=new qc;break;case Wc.KHR_DRACO_MESH_COMPRESSION:a[e]=new hu(i,this.dracoLoader);break;case Wc.KHR_TEXTURE_TRANSFORM:a[e]=new du;break;case Wc.KHR_MESH_QUANTIZATION:a[e]=new pu;break;default:n.indexOf(e)>=0&&void 0===s[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}l.setExtensions(a),l.setPlugins(s),l.parse(n,r)}parseAsync(t,e){const n=this;return new Promise((function(r,i){n.parse(t,e,r,i)}))}}function Vc(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const Wc={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class jc{constructor(t){this.parser=t,this.name=Wc.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,r=e.length;n<r;n++){const r=e[n];r.extensions&&r.extensions[this.name]&&void 0!==r.extensions[this.name].light&&t._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(t){const e=this.parser,n="light:"+t;let r=e.cache.get(n);if(r)return r;const i=e.json,a=((i.extensions&&i.extensions[this.name]||{}).lights||[])[t];let s;const o=new wr(16777215);void 0!==a.color&&o.setRGB(a.color[0],a.color[1],a.color[2],$t);const l=void 0!==a.range?a.range:0;switch(a.type){case"directional":s=new ac(o),s.target.position.set(0,0,-1),s.add(s.target);break;case"point":s=new rc(o),s.distance=l;break;case"spot":s=new Jl(o),s.distance=l,a.spot=a.spot||{},a.spot.innerConeAngle=void 0!==a.spot.innerConeAngle?a.spot.innerConeAngle:0,a.spot.outerConeAngle=void 0!==a.spot.outerConeAngle?a.spot.outerConeAngle:Math.PI/4,s.angle=a.spot.outerConeAngle,s.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,s.target.position.set(0,0,-1),s.add(s.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return s.position.set(0,0,0),s.decay=2,Su(s,a),void 0!==a.intensity&&(s.intensity=a.intensity),s.name=e.createUniqueName(a.name||"light_"+t),r=Promise.resolve(s),e.cache.add(n,r),r}getDependency(t,e){if("light"===t)return this._loadLight(e)}createNodeAttachment(t){const e=this,n=this.parser,r=n.json.nodes[t],i=(r.extensions&&r.extensions[this.name]||{}).light;return void 0===i?null:this._loadLight(i).then((function(t){return n._getNodeRef(e.cache,i,t)}))}}class qc{constructor(){this.name=Wc.KHR_MATERIALS_UNLIT}getMaterialType(){return Sr}extendParams(t,e,n){const r=[];t.color=new wr(1,1,1),t.opacity=1;const i=e.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const e=i.baseColorFactor;t.color.setRGB(e[0],e[1],e[2],$t),t.opacity=e[3]}void 0!==i.baseColorTexture&&r.push(n.assignTexture(t,"map",i.baseColorTexture,Yt))}return Promise.all(r)}}class Xc{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,e){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name].emissiveStrength;return void 0!==r&&(e.emissiveIntensity=r),Promise.resolve()}}class Yc{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],a=r.extensions[this.name];if(void 0!==a.clearcoatFactor&&(e.clearcoat=a.clearcoatFactor),void 0!==a.clearcoatTexture&&i.push(n.assignTexture(e,"clearcoatMap",a.clearcoatTexture)),void 0!==a.clearcoatRoughnessFactor&&(e.clearcoatRoughness=a.clearcoatRoughnessFactor),void 0!==a.clearcoatRoughnessTexture&&i.push(n.assignTexture(e,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),void 0!==a.clearcoatNormalTexture&&(i.push(n.assignTexture(e,"clearcoatNormalMap",a.clearcoatNormalTexture)),void 0!==a.clearcoatNormalTexture.scale)){const t=a.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new Me(t,t)}return Promise.all(i)}}class $c{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_DISPERSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return e.dispersion=void 0!==r.dispersion?r.dispersion:0,Promise.resolve()}}class Kc{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],a=r.extensions[this.name];return void 0!==a.iridescenceFactor&&(e.iridescence=a.iridescenceFactor),void 0!==a.iridescenceTexture&&i.push(n.assignTexture(e,"iridescenceMap",a.iridescenceTexture)),void 0!==a.iridescenceIor&&(e.iridescenceIOR=a.iridescenceIor),void 0===e.iridescenceThicknessRange&&(e.iridescenceThicknessRange=[100,400]),void 0!==a.iridescenceThicknessMinimum&&(e.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),void 0!==a.iridescenceThicknessMaximum&&(e.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),void 0!==a.iridescenceThicknessTexture&&i.push(n.assignTexture(e,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(i)}}class Zc{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[];e.sheenColor=new wr(0,0,0),e.sheenRoughness=0,e.sheen=1;const a=r.extensions[this.name];if(void 0!==a.sheenColorFactor){const t=a.sheenColorFactor;e.sheenColor.setRGB(t[0],t[1],t[2],$t)}return void 0!==a.sheenRoughnessFactor&&(e.sheenRoughness=a.sheenRoughnessFactor),void 0!==a.sheenColorTexture&&i.push(n.assignTexture(e,"sheenColorMap",a.sheenColorTexture,Yt)),void 0!==a.sheenRoughnessTexture&&i.push(n.assignTexture(e,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(i)}}class Jc{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],a=r.extensions[this.name];return void 0!==a.transmissionFactor&&(e.transmission=a.transmissionFactor),void 0!==a.transmissionTexture&&i.push(n.assignTexture(e,"transmissionMap",a.transmissionTexture)),Promise.all(i)}}class Qc{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],a=r.extensions[this.name];e.thickness=void 0!==a.thicknessFactor?a.thicknessFactor:0,void 0!==a.thicknessTexture&&i.push(n.assignTexture(e,"thicknessMap",a.thicknessTexture)),e.attenuationDistance=a.attenuationDistance||1/0;const s=a.attenuationColor||[1,1,1];return e.attenuationColor=(new wr).setRGB(s[0],s[1],s[2],$t),Promise.all(i)}}class tu{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return e.ior=void 0!==r.ior?r.ior:1.5,Promise.resolve()}}class eu{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],a=r.extensions[this.name];e.specularIntensity=void 0!==a.specularFactor?a.specularFactor:1,void 0!==a.specularTexture&&i.push(n.assignTexture(e,"specularIntensityMap",a.specularTexture));const s=a.specularColorFactor||[1,1,1];return e.specularColor=(new wr).setRGB(s[0],s[1],s[2],$t),void 0!==a.specularColorTexture&&i.push(n.assignTexture(e,"specularColorMap",a.specularColorTexture,Yt)),Promise.all(i)}}class nu{constructor(t){this.parser=t,this.name=Wc.EXT_MATERIALS_BUMP}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],a=r.extensions[this.name];return e.bumpScale=void 0!==a.bumpFactor?a.bumpFactor:1,void 0!==a.bumpTexture&&i.push(n.assignTexture(e,"bumpMap",a.bumpTexture)),Promise.all(i)}}class ru{constructor(t){this.parser=t,this.name=Wc.KHR_MATERIALS_ANISOTROPY}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?gl:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],a=r.extensions[this.name];return void 0!==a.anisotropyStrength&&(e.anisotropy=a.anisotropyStrength),void 0!==a.anisotropyRotation&&(e.anisotropyRotation=a.anisotropyRotation),void 0!==a.anisotropyTexture&&i.push(n.assignTexture(e,"anisotropyMap",a.anisotropyTexture)),Promise.all(i)}}class iu{constructor(t){this.parser=t,this.name=Wc.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,n=e.json,r=n.textures[t];if(!r.extensions||!r.extensions[this.name])return null;const i=r.extensions[this.name],a=e.options.ktx2Loader;if(!a){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,i.source,a)}}class au{constructor(t){this.parser=t,this.name=Wc.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,r=n.json,i=r.textures[t];if(!i.extensions||!i.extensions[e])return null;const a=i.extensions[e],s=r.images[a.source];let o=n.textureLoader;if(s.uri){const t=n.options.manager.getHandler(s.uri);null!==t&&(o=t)}return this.detectSupport().then((function(i){if(i)return n.loadTextureImage(t,a.source,o);if(r.extensionsRequired&&r.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(1===e.height)}}))),this.isSupported}}class su{constructor(t){this.parser=t,this.name=Wc.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,r=n.json,i=r.textures[t];if(!i.extensions||!i.extensions[e])return null;const a=i.extensions[e],s=r.images[a.source];let o=n.textureLoader;if(s.uri){const t=n.options.manager.getHandler(s.uri);null!==t&&(o=t)}return this.detectSupport().then((function(i){if(i)return n.loadTextureImage(t,a.source,o);if(r.extensionsRequired&&r.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const e=new Image;e.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",e.onload=e.onerror=function(){t(1===e.height)}}))),this.isSupported}}class ou{constructor(t){this.name=Wc.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,n=e.bufferViews[t];if(n.extensions&&n.extensions[this.name]){const t=n.extensions[this.name],r=this.parser.getDependency("buffer",t.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then((function(e){const n=t.byteOffset||0,r=t.byteLength||0,a=t.count,s=t.byteStride,o=new Uint8Array(e,n,r);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(a,s,o,t.mode,t.filter).then((function(t){return t.buffer})):i.ready.then((function(){const e=new ArrayBuffer(a*s);return i.decodeGltfBuffer(new Uint8Array(e),a,s,o,t.mode,t.filter),e}))}))}return null}}class lu{constructor(t){this.name=Wc.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const e=this.parser.json,n=e.nodes[t];if(!n.extensions||!n.extensions[this.name]||void 0===n.mesh)return null;const r=e.meshes[n.mesh];for(const t of r.primitives)if(t.mode!==vu.TRIANGLES&&t.mode!==vu.TRIANGLE_STRIP&&t.mode!==vu.TRIANGLE_FAN&&void 0!==t.mode)return null;const i=n.extensions[this.name].attributes,a=[],s={};for(const t in i)a.push(this.parser.getDependency("accessor",i[t]).then((e=>(s[t]=e,s[t]))));return a.length<1?null:(a.push(this.parser.createNodeMesh(t)),Promise.all(a).then((t=>{const e=t.pop(),n=e.isGroup?e.children:[e],r=t[0].count,i=[];for(const t of n){const e=new Pn,n=new Qe,a=new Je,o=new Qe(1,1,1),l=new Go(t.geometry,t.material,r);for(let t=0;t<r;t++)s.TRANSLATION&&n.fromBufferAttribute(s.TRANSLATION,t),s.ROTATION&&a.fromBufferAttribute(s.ROTATION,t),s.SCALE&&o.fromBufferAttribute(s.SCALE,t),l.setMatrixAt(t,e.compose(n,a,o));for(const e in s)if("_COLOR_0"===e){const t=s[e];l.instanceColor=new Oo(t.array,t.itemSize,t.normalized)}else"TRANSLATION"!==e&&"ROTATION"!==e&&"SCALE"!==e&&t.geometry.setAttribute(e,s[e]);rr.prototype.copy.call(l,t),this.parser.assignFinalMaterial(l),i.push(l)}return e.isGroup?(e.clear(),e.add(...i),e):i[0]})))}}const cu="glTF";class uu{constructor(t){this.name=Wc.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==cu)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-12,i=new DataView(t,12);let a=0;for(;a<r;){const e=i.getUint32(a,!0);a+=4;const r=i.getUint32(a,!0);if(a+=4,1313821514===r){const r=new Uint8Array(t,12+a,e);this.content=n.decode(r)}else if(5130562===r){const n=12+a;this.body=t.slice(n,n+e)}a+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class hu{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Wc.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const n=this.json,r=this.dracoLoader,i=t.extensions[this.name].bufferView,a=t.extensions[this.name].attributes,s={},o={},l={};for(const t in a){const e=wu[t]||t.toLowerCase();s[e]=a[t]}for(const e in t.attributes){const r=wu[e]||e.toLowerCase();if(void 0!==a[e]){const i=n.accessors[t.attributes[e]],a=_u[i.componentType];l[r]=a.name,o[r]=!0===i.normalized}}return e.getDependency("bufferView",i).then((function(t){return new Promise((function(e,n){r.decodeDracoFile(t,(function(t){for(const e in t.attributes){const n=t.attributes[e],r=o[e];void 0!==r&&(n.normalized=r)}e(t)}),s,l,$t,n)}))}))}}class du{constructor(){this.name=Wc.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return void 0!==e.texCoord&&e.texCoord!==t.channel||void 0!==e.offset||void 0!==e.rotation||void 0!==e.scale?(t=t.clone(),void 0!==e.texCoord&&(t.channel=e.texCoord),void 0!==e.offset&&t.offset.fromArray(e.offset),void 0!==e.rotation&&(t.rotation=e.rotation),void 0!==e.scale&&t.repeat.fromArray(e.scale),t.needsUpdate=!0,t):t}}class pu{constructor(){this.name=Wc.KHR_MESH_QUANTIZATION}}class fu extends wl{constructor(t,e,n,r){super(t,e,n,r)}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=t*r*3+r;for(let t=0;t!==r;t++)e[t]=n[i+t];return e}interpolate_(t,e,n,r){const i=this.resultBuffer,a=this.sampleValues,s=this.valueSize,o=2*s,l=3*s,c=r-e,u=(n-e)/c,h=u*u,d=h*u,p=t*l,f=p-l,m=-2*d+3*h,g=d-h,v=1-m,_=g-h+u;for(let t=0;t!==s;t++){const e=a[f+t+s],n=a[f+t+o]*c,r=a[p+t+s],l=a[p+t]*c;i[t]=v*e+_*n+m*r+g*l}return i}}const mu=new Je;class gu extends fu{interpolate_(t,e,n,r){const i=super.interpolate_(t,e,n,r);return mu.fromArray(i).normalize().toArray(i),i}}const vu={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},_u={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},yu={9728:G,9729:j,9984:1004,9985:q,9986:W,9987:X},xu={33071:z,33648:H,10497:k},bu={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},wu={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Mu={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Tu={CUBICSPLINE:void 0,LINEAR:jt,STEP:Wt};function Eu(t,e,n){for(const r in n.extensions)void 0===t[r]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[r]=n.extensions[r])}function Su(t,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(t.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Au(t,e){if(t.updateMorphTargets(),void 0!==e.weights)for(let n=0,r=e.weights.length;n<r;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let e=0,r=n.length;e<r;e++)t.morphTargetDictionary[n[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Ru(t){let e;const n=t.extensions&&t.extensions[Wc.KHR_DRACO_MESH_COMPRESSION];if(e=n?"draco:"+n.bufferView+":"+n.indices+":"+Cu(n.attributes):t.indices+":"+Cu(t.attributes)+":"+t.mode,void 0!==t.targets)for(let n=0,r=t.targets.length;n<r;n++)e+=":"+Cu(t.targets[n]);return e}function Cu(t){let e="";const n=Object.keys(t).sort();for(let r=0,i=n.length;r<i;r++)e+=n[r]+":"+t[n[r]]+";";return e}function Pu(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const Iu=new Pn;class Lu{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new Vc,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,r=-1,i=!1,a=-1;if("undefined"!=typeof navigator){const t=navigator.userAgent;n=!0===/^((?!chrome|android).)*safari/i.test(t);const e=t.match(/Version\/(\d+)/);r=n&&e?parseInt(e[1],10):-1,i=t.indexOf("Firefox")>-1,a=i?t.match(/Firefox\/([0-9]+)\./)[1]:-1}"undefined"==typeof createImageBitmap||n&&r<17||i&&a<98?this.textureLoader=new jl(this.options.manager):this.textureLoader=new oc(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Gl(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const n=this,r=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll((function(t){return t._markDefs&&t._markDefs()})),Promise.all(this._invokeAll((function(t){return t.beforeRoot&&t.beforeRoot()}))).then((function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])})).then((function(e){const a={scene:e[0][r.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:r.asset,parser:n,userData:{}};return Eu(i,a,r),Su(a,r),Promise.all(n._invokeAll((function(t){return t.afterRoot&&t.afterRoot(a)}))).then((function(){for(const t of a.scenes)t.updateMatrixWorld();t(a)}))})).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],n=this.json.meshes||[];for(let n=0,r=e.length;n<r;n++){const r=e[n].joints;for(let e=0,n=r.length;e<n;e++)t[r[e]].isBone=!0}for(let e=0,r=t.length;e<r;e++){const r=t[e];void 0!==r.mesh&&(this._addNodeRef(this.meshCache,r.mesh),void 0!==r.skin&&(n[r.mesh].isSkinnedMesh=!0)),void 0!==r.camera&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(t,e){void 0!==e&&(void 0===t.refs[e]&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,n){if(t.refs[e]<=1)return n;const r=n.clone(),i=(t,e)=>{const n=this.associations.get(t);null!=n&&this.associations.set(e,n);for(const[n,r]of t.children.entries())i(r,e.children[n])};return i(n,r),r.name+="_instance_"+t.uses[e]++,r}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let n=0;n<e.length;n++){const r=t(e[n]);if(r)return r}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const n=[];for(let r=0;r<e.length;r++){const i=t(e[r]);i&&n.push(i)}return n}getDependency(t,e){const n=t+":"+e;let r=this.cache.get(n);if(!r){switch(t){case"scene":r=this.loadScene(e);break;case"node":r=this._invokeOne((function(t){return t.loadNode&&t.loadNode(e)}));break;case"mesh":r=this._invokeOne((function(t){return t.loadMesh&&t.loadMesh(e)}));break;case"accessor":r=this.loadAccessor(e);break;case"bufferView":r=this._invokeOne((function(t){return t.loadBufferView&&t.loadBufferView(e)}));break;case"buffer":r=this.loadBuffer(e);break;case"material":r=this._invokeOne((function(t){return t.loadMaterial&&t.loadMaterial(e)}));break;case"texture":r=this._invokeOne((function(t){return t.loadTexture&&t.loadTexture(e)}));break;case"skin":r=this.loadSkin(e);break;case"animation":r=this._invokeOne((function(t){return t.loadAnimation&&t.loadAnimation(e)}));break;case"camera":r=this.loadCamera(e);break;default:if(r=this._invokeOne((function(n){return n!=this&&n.getDependency&&n.getDependency(t,e)})),!r)throw new Error("Unknown type: "+t)}this.cache.add(n,r)}return r}getDependencies(t){let e=this.cache.get(t);if(!e){const n=this,r=this.json[t+("mesh"===t?"es":"s")]||[];e=Promise.all(r.map((function(e,r){return n.getDependency(t,r)}))),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],n=this.fileLoader;if(e.type&&"arraybuffer"!==e.type)throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(void 0===e.uri&&0===t)return Promise.resolve(this.extensions[Wc.KHR_BINARY_GLTF].body);const r=this.options;return new Promise((function(t,i){n.load(sc.resolveURL(e.uri,r.path),t,void 0,(function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))}))}))}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then((function(t){const n=e.byteLength||0,r=e.byteOffset||0;return t.slice(r,r+n)}))}loadAccessor(t){const e=this,n=this.json,r=this.json.accessors[t];if(void 0===r.bufferView&&void 0===r.sparse){const t=bu[r.type],e=_u[r.componentType],n=!0===r.normalized,i=new e(r.count*t);return Promise.resolve(new Lr(i,t,n))}const i=[];return void 0!==r.bufferView?i.push(this.getDependency("bufferView",r.bufferView)):i.push(null),void 0!==r.sparse&&(i.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(i).then((function(t){const i=t[0],a=bu[r.type],s=_u[r.componentType],o=s.BYTES_PER_ELEMENT,l=o*a,c=r.byteOffset||0,u=void 0!==r.bufferView?n.bufferViews[r.bufferView].byteStride:void 0,h=!0===r.normalized;let d,p;if(u&&u!==l){const t=Math.floor(c/u),n="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+t+":"+r.count;let l=e.cache.get(n);l||(d=new s(i,t*u,r.count*u/o),l=new go(d,u/o),e.cache.add(n,l)),p=new _o(l,a,c%u/o,h)}else d=null===i?new s(r.count*a):new s(i,c,r.count*a),p=new Lr(d,a,h);if(void 0!==r.sparse){const e=bu.SCALAR,n=_u[r.sparse.indices.componentType],o=r.sparse.indices.byteOffset||0,l=r.sparse.values.byteOffset||0,c=new n(t[1],o,r.sparse.count*e),u=new s(t[2],l,r.sparse.count*a);null!==i&&(p=new Lr(p.array.slice(),p.itemSize,p.normalized)),p.normalized=!1;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(p.setX(e,u[t*a]),a>=2&&p.setY(e,u[t*a+1]),a>=3&&p.setZ(e,u[t*a+2]),a>=4&&p.setW(e,u[t*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}p.normalized=h}return p}))}loadTexture(t){const e=this.json,n=this.options,r=e.textures[t].source,i=e.images[r];let a=this.textureLoader;if(i.uri){const t=n.manager.getHandler(i.uri);null!==t&&(a=t)}return this.loadTextureImage(t,r,a)}loadTextureImage(t,e,n){const r=this,i=this.json,a=i.textures[t],s=i.images[e],o=(s.uri||s.bufferView)+":"+a.sampler;if(this.textureCache[o])return this.textureCache[o];const l=this.loadImageSource(e,n).then((function(e){e.flipY=!1,e.name=a.name||s.name||"",""===e.name&&"string"==typeof s.uri&&!1===s.uri.startsWith("data:image/")&&(e.name=s.uri);const n=(i.samplers||{})[a.sampler]||{};return e.magFilter=yu[n.magFilter]||j,e.minFilter=yu[n.minFilter]||X,e.wrapS=xu[n.wrapS]||k,e.wrapT=xu[n.wrapT]||k,e.generateMipmaps=!e.isCompressedTexture&&e.minFilter!==G&&e.minFilter!==j,r.associations.set(e,{textures:t}),e})).catch((function(){return null}));return this.textureCache[o]=l,l}loadImageSource(t,e){const n=this.json,r=this.options;if(void 0!==this.sourceCache[t])return this.sourceCache[t].then((t=>t.clone()));const i=n.images[t],a=self.URL||self.webkitURL;let s=i.uri||"",o=!1;if(void 0!==i.bufferView)s=this.getDependency("bufferView",i.bufferView).then((function(t){o=!0;const e=new Blob([t],{type:i.mimeType});return s=a.createObjectURL(e),s}));else if(void 0===i.uri)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const l=Promise.resolve(s).then((function(t){return new Promise((function(n,i){let a=n;!0===e.isImageBitmapLoader&&(a=function(t){const e=new je(t);e.needsUpdate=!0,n(e)}),e.load(sc.resolveURL(t,r.path),a,void 0,i)}))})).then((function(t){var e;return!0===o&&a.revokeObjectURL(s),Su(t,i),t.userData.mimeType=i.mimeType||((e=i.uri).search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":e.search(/\.webp($|\?)/i)>0||0===e.search(/^data\:image\/webp/)?"image/webp":e.search(/\.ktx2($|\?)/i)>0||0===e.search(/^data\:image\/ktx2/)?"image/ktx2":"image/png"),t})).catch((function(t){throw console.error("THREE.GLTFLoader: Couldn't load texture",s),t}));return this.sourceCache[t]=l,l}assignTexture(t,e,n,r){const i=this;return this.getDependency("texture",n.index).then((function(a){if(!a)return null;if(void 0!==n.texCoord&&n.texCoord>0&&((a=a.clone()).channel=n.texCoord),i.extensions[Wc.KHR_TEXTURE_TRANSFORM]){const t=void 0!==n.extensions?n.extensions[Wc.KHR_TEXTURE_TRANSFORM]:void 0;if(t){const e=i.associations.get(a);a=i.extensions[Wc.KHR_TEXTURE_TRANSFORM].extendTexture(a,t),i.associations.set(a,e)}}return void 0!==r&&(a.colorSpace=r),t[e]=a,a}))}assignFinalMaterial(t){const e=t.geometry;let n=t.material;const r=void 0===e.attributes.tangent,i=void 0!==e.attributes.color,a=void 0===e.attributes.normal;if(t.isPoints){const t="PointsMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new rl,Er.prototype.copy.call(e,n),e.color.copy(n.color),e.map=n.map,e.sizeAttenuation=!1,this.cache.add(t,e)),n=e}else if(t.isLine){const t="LineBasicMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new Vo,Er.prototype.copy.call(e,n),e.color.copy(n.color),e.map=n.map,this.cache.add(t,e)),n=e}if(r||i||a){let t="ClonedMaterial:"+n.uuid+":";r&&(t+="derivative-tangents:"),i&&(t+="vertex-colors:"),a&&(t+="flat-shading:");let e=this.cache.get(t);e||(e=n.clone(),i&&(e.vertexColors=!0),a&&(e.flatShading=!0),r&&(e.normalScale&&(e.normalScale.y*=-1),e.clearcoatNormalScale&&(e.clearcoatNormalScale.y*=-1)),this.cache.add(t,e),this.associations.set(e,this.associations.get(n))),n=e}t.material=n}getMaterialType(){return ml}loadMaterial(t){const e=this,n=this.json,r=this.extensions,i=n.materials[t];let a;const s={},o=[];if((i.extensions||{})[Wc.KHR_MATERIALS_UNLIT]){const t=r[Wc.KHR_MATERIALS_UNLIT];a=t.getMaterialType(),o.push(t.extendParams(s,i,e))}else{const n=i.pbrMetallicRoughness||{};if(s.color=new wr(1,1,1),s.opacity=1,Array.isArray(n.baseColorFactor)){const t=n.baseColorFactor;s.color.setRGB(t[0],t[1],t[2],$t),s.opacity=t[3]}void 0!==n.baseColorTexture&&o.push(e.assignTexture(s,"map",n.baseColorTexture,Yt)),s.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,s.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(o.push(e.assignTexture(s,"metalnessMap",n.metallicRoughnessTexture)),o.push(e.assignTexture(s,"roughnessMap",n.metallicRoughnessTexture))),a=this._invokeOne((function(e){return e.getMaterialType&&e.getMaterialType(t)})),o.push(Promise.all(this._invokeAll((function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,s)}))))}!0===i.doubleSided&&(s.side=2);const l=i.alphaMode||"OPAQUE";if("BLEND"===l?(s.transparent=!0,s.depthWrite=!1):(s.transparent=!1,"MASK"===l&&(s.alphaTest=void 0!==i.alphaCutoff?i.alphaCutoff:.5)),void 0!==i.normalTexture&&a!==Sr&&(o.push(e.assignTexture(s,"normalMap",i.normalTexture)),s.normalScale=new Me(1,1),void 0!==i.normalTexture.scale)){const t=i.normalTexture.scale;s.normalScale.set(t,t)}if(void 0!==i.occlusionTexture&&a!==Sr&&(o.push(e.assignTexture(s,"aoMap",i.occlusionTexture)),void 0!==i.occlusionTexture.strength&&(s.aoMapIntensity=i.occlusionTexture.strength)),void 0!==i.emissiveFactor&&a!==Sr){const t=i.emissiveFactor;s.emissive=(new wr).setRGB(t[0],t[1],t[2],$t)}return void 0!==i.emissiveTexture&&a!==Sr&&o.push(e.assignTexture(s,"emissiveMap",i.emissiveTexture,Yt)),Promise.all(o).then((function(){const n=new a(s);return i.name&&(n.name=i.name),Su(n,i),e.associations.set(n,{materials:t}),i.extensions&&Eu(r,n,i),n}))}createUniqueName(t){const e=gc.sanitizeNodeName(t||"");return e in this.nodeNamesUsed?e+"_"+ ++this.nodeNamesUsed[e]:(this.nodeNamesUsed[e]=0,e)}loadGeometries(t){const e=this,n=this.extensions,r=this.primitiveCache;function i(t){return n[Wc.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t,e).then((function(n){return Du(n,t,e)}))}const a=[];for(let n=0,s=t.length;n<s;n++){const s=t[n],o=Ru(s),l=r[o];if(l)a.push(l.promise);else{let t;t=s.extensions&&s.extensions[Wc.KHR_DRACO_MESH_COMPRESSION]?i(s):Du(new Vr,s,e),r[o]={primitive:s,promise:t},a.push(t)}}return Promise.all(a)}loadMesh(t){const e=this,n=this.json,r=this.extensions,i=n.meshes[t],a=i.primitives,s=[];for(let t=0,e=a.length;t<e;t++){const e=void 0===a[t].material?(void 0===(o=this.cache).DefaultMaterial&&(o.DefaultMaterial=new ml({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:0})),o.DefaultMaterial):this.getDependency("material",a[t].material);s.push(e)}var o;return s.push(e.loadGeometries(a)),Promise.all(s).then((function(n){const s=n.slice(0,n.length-1),o=n[n.length-1],l=[];for(let n=0,c=o.length;n<c;n++){const c=o[n],u=a[n];let h;const d=s[n];if(u.mode===vu.TRIANGLES||u.mode===vu.TRIANGLE_STRIP||u.mode===vu.TRIANGLE_FAN||void 0===u.mode)h=!0===i.isSkinnedMesh?new Ro(c,d):new ei(c,d),!0===h.isSkinnedMesh&&h.normalizeSkinWeights(),u.mode===vu.TRIANGLE_STRIP?h.geometry=Hc(h.geometry,1):u.mode===vu.TRIANGLE_FAN&&(h.geometry=Hc(h.geometry,2));else if(u.mode===vu.LINES)h=new el(c,d);else if(u.mode===vu.LINE_STRIP)h=new Zo(c,d);else if(u.mode===vu.LINE_LOOP)h=new nl(c,d);else{if(u.mode!==vu.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+u.mode);h=new ll(c,d)}Object.keys(h.geometry.morphAttributes).length>0&&Au(h,i),h.name=e.createUniqueName(i.name||"mesh_"+t),Su(h,i),u.extensions&&Eu(r,h,u),e.assignFinalMaterial(h),l.push(h)}for(let n=0,r=l.length;n<r;n++)e.associations.set(l[n],{meshes:t,primitives:n});if(1===l.length)return i.extensions&&Eu(r,l[0],i),l[0];const c=new io;i.extensions&&Eu(r,c,i),e.associations.set(c,{meshes:t});for(let t=0,e=l.length;t<e;t++)c.add(l[t]);return c}))}loadCamera(t){let e;const n=this.json.cameras[t],r=n[n.type];if(r)return"perspective"===n.type?e=new pi(we(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):"orthographic"===n.type&&(e=new zi(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),n.name&&(e.name=this.createUniqueName(n.name)),Su(e,n),Promise.resolve(e);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(t){const e=this.json.skins[t],n=[];for(let t=0,r=e.joints.length;t<r;t++)n.push(this._loadNodeShallow(e.joints[t]));return void 0!==e.inverseBindMatrices?n.push(this.getDependency("accessor",e.inverseBindMatrices)):n.push(null),Promise.all(n).then((function(t){const n=t.pop(),r=t,i=[],a=[];for(let t=0,s=r.length;t<s;t++){const s=r[t];if(s){i.push(s);const e=new Pn;null!==n&&e.fromArray(n.array,16*t),a.push(e)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',e.joints[t])}return new Do(i,a)}))}loadAnimation(t){const e=this.json,n=this,r=e.animations[t],i=r.name?r.name:"animation_"+t,a=[],s=[],o=[],l=[],c=[];for(let t=0,e=r.channels.length;t<e;t++){const e=r.channels[t],n=r.samplers[e.sampler],i=e.target,u=i.node,h=void 0!==r.parameters?r.parameters[n.input]:n.input,d=void 0!==r.parameters?r.parameters[n.output]:n.output;void 0!==i.node&&(a.push(this.getDependency("node",u)),s.push(this.getDependency("accessor",h)),o.push(this.getDependency("accessor",d)),l.push(n),c.push(i))}return Promise.all([Promise.all(a),Promise.all(s),Promise.all(o),Promise.all(l),Promise.all(c)]).then((function(t){const e=t[0],r=t[1],a=t[2],s=t[3],o=t[4],l=[];for(let t=0,i=e.length;t<i;t++){const i=e[t],c=r[t],u=a[t],h=s[t],d=o[t];if(void 0===i)continue;i.updateMatrix&&i.updateMatrix();const p=n._createAnimationTracks(i,c,u,h,d);if(p)for(let t=0;t<p.length;t++)l.push(p[t])}return new Ol(i,void 0,l)}))}createNodeMesh(t){const e=this.json,n=this,r=e.nodes[t];return void 0===r.mesh?null:n.getDependency("mesh",r.mesh).then((function(t){const e=n._getNodeRef(n.meshCache,r.mesh,t);return void 0!==r.weights&&e.traverse((function(t){if(t.isMesh)for(let e=0,n=r.weights.length;e<n;e++)t.morphTargetInfluences[e]=r.weights[e]})),e}))}loadNode(t){const e=this,n=this.json.nodes[t],r=e._loadNodeShallow(t),i=[],a=n.children||[];for(let t=0,n=a.length;t<n;t++)i.push(e.getDependency("node",a[t]));const s=void 0===n.skin?Promise.resolve(null):e.getDependency("skin",n.skin);return Promise.all([r,Promise.all(i),s]).then((function(t){const e=t[0],n=t[1],r=t[2];null!==r&&e.traverse((function(t){t.isSkinnedMesh&&t.bind(r,Iu)}));for(let t=0,r=n.length;t<r;t++)e.add(n[t]);return e}))}_loadNodeShallow(t){const e=this.json,n=this.extensions,r=this;if(void 0!==this.nodeCache[t])return this.nodeCache[t];const i=e.nodes[t],a=i.name?r.createUniqueName(i.name):"",s=[],o=r._invokeOne((function(e){return e.createNodeMesh&&e.createNodeMesh(t)}));return o&&s.push(o),void 0!==i.camera&&s.push(r.getDependency("camera",i.camera).then((function(t){return r._getNodeRef(r.cameraCache,i.camera,t)}))),r._invokeAll((function(e){return e.createNodeAttachment&&e.createNodeAttachment(t)})).forEach((function(t){s.push(t)})),this.nodeCache[t]=Promise.all(s).then((function(e){let s;if(s=!0===i.isBone?new Co:e.length>1?new io:1===e.length?e[0]:new rr,s!==e[0])for(let t=0,n=e.length;t<n;t++)s.add(e[t]);if(i.name&&(s.userData.name=i.name,s.name=a),Su(s,i),i.extensions&&Eu(n,s,i),void 0!==i.matrix){const t=new Pn;t.fromArray(i.matrix),s.applyMatrix4(t)}else void 0!==i.translation&&s.position.fromArray(i.translation),void 0!==i.rotation&&s.quaternion.fromArray(i.rotation),void 0!==i.scale&&s.scale.fromArray(i.scale);return r.associations.has(s)||r.associations.set(s,{}),r.associations.get(s).nodes=t,s})),this.nodeCache[t]}loadScene(t){const e=this.extensions,n=this.json.scenes[t],r=this,i=new io;n.name&&(i.name=r.createUniqueName(n.name)),Su(i,n),n.extensions&&Eu(e,i,n);const a=n.nodes||[],s=[];for(let t=0,e=a.length;t<e;t++)s.push(r.getDependency("node",a[t]));return Promise.all(s).then((function(t){for(let e=0,n=t.length;e<n;e++)i.add(t[e]);return r.associations=(t=>{const e=new Map;for(const[t,n]of r.associations)(t instanceof Er||t instanceof je)&&e.set(t,n);return t.traverse((t=>{const n=r.associations.get(t);null!=n&&e.set(t,n)})),e})(i),i}))}_createAnimationTracks(t,e,n,r,i){const a=[],s=t.name?t.name:t.uuid,o=[];let l;switch(Mu[i.path]===Mu.weights?t.traverse((function(t){t.morphTargetInfluences&&o.push(t.name?t.name:t.uuid)})):o.push(s),Mu[i.path]){case Mu.weights:l=Cl;break;case Mu.rotation:l=Il;break;case Mu.position:case Mu.scale:l=Dl;break;default:l=1===n.itemSize?Cl:Dl}const c=void 0!==r.interpolation?Tu[r.interpolation]:jt,u=this._getArrayFromAccessor(n);for(let t=0,n=o.length;t<n;t++){const n=new l(o[t]+"."+Mu[i.path],e.array,u,c);"CUBICSPLINE"===r.interpolation&&this._createCubicSplineTrackInterpolant(n),a.push(n)}return a}_getArrayFromAccessor(t){let e=t.array;if(t.normalized){const t=Pu(e.constructor),n=new Float32Array(e.length);for(let r=0,i=e.length;r<i;r++)n[r]=e[r]*t;e=n}return e}_createCubicSplineTrackInterpolant(t){t.createInterpolant=function(t){return new(this instanceof Il?gu:fu)(this.times,this.values,this.getValueSize()/3,t)},t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Du(t,e,n){const r=e.attributes,i=[];function a(e,r){return n.getDependency("accessor",e).then((function(e){t.setAttribute(r,e)}))}for(const e in r){const n=wu[e]||e.toLowerCase();n in t.attributes||i.push(a(r[e],n))}if(void 0!==e.indices&&!t.index){const r=n.getDependency("accessor",e.indices).then((function(e){t.setIndex(e)}));i.push(r)}return Ie.workingColorSpace!==$t&&"COLOR_0"in r&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ie.workingColorSpace}" not supported.`),Su(t,e),function(t,e,n){const r=e.attributes,i=new nn;if(void 0===r.POSITION)return;{const t=n.json.accessors[r.POSITION],e=t.min,a=t.max;if(void 0===e||void 0===a)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(i.set(new Qe(e[0],e[1],e[2]),new Qe(a[0],a[1],a[2])),t.normalized){const e=Pu(_u[t.componentType]);i.min.multiplyScalar(e),i.max.multiplyScalar(e)}}const a=e.targets;if(void 0!==a){const t=new Qe,e=new Qe;for(let r=0,i=a.length;r<i;r++){const i=a[r];if(void 0!==i.POSITION){const r=n.json.accessors[i.POSITION],a=r.min,s=r.max;if(void 0!==a&&void 0!==s){if(e.setX(Math.max(Math.abs(a[0]),Math.abs(s[0]))),e.setY(Math.max(Math.abs(a[1]),Math.abs(s[1]))),e.setZ(Math.max(Math.abs(a[2]),Math.abs(s[2]))),r.normalized){const t=Pu(_u[r.componentType]);e.multiplyScalar(t)}t.max(e)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(t)}t.boundingBox=i;const s=new bn;i.getCenter(s.center),s.radius=i.min.distanceTo(i.max)/2,t.boundingSphere=s}(t,e,n),Promise.all(i).then((function(){return void 0!==e.targets?function(t,e,n){let r=!1,i=!1,a=!1;for(let t=0,n=e.length;t<n;t++){const n=e[t];if(void 0!==n.POSITION&&(r=!0),void 0!==n.NORMAL&&(i=!0),void 0!==n.COLOR_0&&(a=!0),r&&i&&a)break}if(!r&&!i&&!a)return Promise.resolve(t);const s=[],o=[],l=[];for(let c=0,u=e.length;c<u;c++){const u=e[c];if(r){const e=void 0!==u.POSITION?n.getDependency("accessor",u.POSITION):t.attributes.position;s.push(e)}if(i){const e=void 0!==u.NORMAL?n.getDependency("accessor",u.NORMAL):t.attributes.normal;o.push(e)}if(a){const e=void 0!==u.COLOR_0?n.getDependency("accessor",u.COLOR_0):t.attributes.color;l.push(e)}}return Promise.all([Promise.all(s),Promise.all(o),Promise.all(l)]).then((function(e){const n=e[0],s=e[1],o=e[2];return r&&(t.morphAttributes.position=n),i&&(t.morphAttributes.normal=s),a&&(t.morphAttributes.color=o),t.morphTargetsRelative=!0,t}))}(t,e.targets,n):t}))}var Ou=function(t,e,n,r){return new(n||(n=Promise))((function(i,a){function s(t){try{l(r.next(t))}catch(t){a(t)}}function o(t){try{l(r.throw(t))}catch(t){a(t)}}function l(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,o)}l((r=r.apply(t,e||[])).next())}))};class Nu extends kl{constructor(t,e){super(),this._materialProperties=new Map,this._threeMaterials=new Map,this._defaultMaterial=new gl({color:"#ffffff",side:2}),this._defaultMaterialFloor=new gl,this._gltfLoader=new Gc,this._renderUpdateCallback=()=>{},this._materialFactory=new Ic,this._geometryFactory=new Ec,this._meshFactory=new Fc(this._materialFactory,this._geometryFactory),this._gltfLoader.setDRACOLoader(t),e&&(this._renderUpdateCallback=e)}loadAsync(t,e){return Ou(this,void 0,void 0,(function*(){const n=yield kc.J.newPlanElementManager(void 0,void 0,null!=e?e:{locateFile(t,e){const n=(t.endsWith(".wasm")?"./":e)+t;return console.log("loading file: "+n),n}});return yield n.loadPlanFromId(t),yield n.createGeometry(),this._debugLogPlanElements(n),{scene:this._generateScene(n)}}))}_generateScene(t){const e=new io;return this._generateMaterials(t),this._generatePlanElements(t,e),this._generateConfigurablePlanObjects(t,e),this._generateStaticPlanObjects(t,e),e}_generateMaterials(t){t.materials.forEach(((t,e)=>{const n=(0,r.getMaterialProperties)(t);this._materialProperties.set(e,n);const i=this._materialFactory.createThreeMaterial(e,n);this._threeMaterials.set(e,i)}))}_generatePlanElements(t,e){var n,r;const i=this._generateWallModels(t),a=t.planMeshes;for(const s of a){if(s.type===zc.CORE_PLAN_ELEMENT_TYPE.CEILING)continue;let a=s.material.getSourceType().value,o=this._defaultMaterial;s.type===zc.CORE_PLAN_ELEMENT_TYPE.FLOOR&&(o=this._defaultMaterialFloor),a===zc.CORE_MATERIAL_SOURCE_TYPE.MATERIAL?o=null!==(n=this._threeMaterials.get(s.material.materialId))&&void 0!==n?n:o:a===zc.CORE_MATERIAL_SOURCE_TYPE.RGBVALUE?o=new gl({color:s.material.rgbValue}):a===zc.CORE_MATERIAL_SOURCE_TYPE.CATALOGITEM&&(o=null!==(r=this._generateMaterialFromCatalogItem(t,s.material.catalogItemId))&&void 0!==r?r:o);const l=this._geometryFactory.createThreeGeometry(s),c=new ei(l,o),u=Sc(s.position);c.position.copy(u),c.receiveShadow=!0,c.castShadow=!0,s.type===zc.CORE_PLAN_ELEMENT_TYPE.FLOOR?c.userData.isPlanFloor=!0:s.type===zc.CORE_PLAN_ELEMENT_TYPE.WALL&&(c.userData.isPlanWall=!0,i.has(s.id)&&(c.userData.wallModel=i.get(s.id))),e.add(c)}}_generateWallModels(t){const e=new Map;for(const n of t.planElements)if(n.getType().value===zc.CORE_PLAN_ELEMENT_TYPE.WALL){const t=n;let r={wallType:t.wallType,rightNormal:Ac(t.rightNormal),leftNormal:Ac(t.leftNormal),center:Ac(t.getCenter())};e.set(n.getId(),r)}return e}_generateConfigurablePlanObjects(t,e){for(const n of t.planObjectMeshes)n.mesh&&this._generateConfigurablePlanObject(e,n)}_generateStaticPlanObjects(t,e){return Ou(this,void 0,void 0,(function*(){const n=[];for(const r of t.planObjectMeshes)!r.mesh&&r.catalogItem&&n.push(this._generateStaticPlanObject(e,r));yield Promise.all(n),this._renderUpdateCallback()}))}_generateConfigurablePlanObject(t,e){const n=e.mesh,r=this._meshFactory.constructThreeMesh(n),i=Uc(r.geometryAndMaterial);this._shiftObjectToBottomCenter(e,i),this._addObjectToSceneAtObjectPosition(t,e,i)}_generateStaticPlanObject(t,e){return Ou(this,void 0,void 0,(function*(){const n=e.catalogItem,r=Fu(n.item);if(!r||""===r)return;let i=n.item.scaleable?Sc(e.size):void 0,a=new Qe(1,1,1);e.planObject.flipX&&(a.x*=-1),e.planObject.flipY&&(a.z*=-1);const s=yield this._gltfLoader.loadAsync(r),o=Bu(s,void 0,void 0,i,a,e.planObject.customColor,n.item.colorable);if(!o)return;const l=o.boundingBox.getCenter(new Qe);o.scene.position.x-=l.x,o.scene.position.y-=o.boundingBox.min.y,o.scene.position.z-=l.z,this._addObjectToSceneAtObjectPosition(t,e,o.scene)}))}_shiftObjectToBottomCenter(t,e){if(t.boxOfGeometry){const n=t.boxOfGeometry,r=[n.origin.x+n.size.x/2,n.origin.y+n.size.y/2,n.origin.z],i=Sc(r);e.position.x-=i.x,e.position.y-=i.y,e.position.z-=i.z}else{const t=(new nn).setFromObject(e),n=t.getCenter(new Qe);e.position.x-=n.x,e.position.y-=t.min.y,e.position.z-=n.z}}_addObjectToSceneAtObjectPosition(t,e,n){const r=new io;r.add(n);const i=Sc(e.position);r.position.copy(i),r.rotation.y=e.rotation,t.add(r)}_generateMaterialFromCatalogItem(t,e){const n=t.getCatalogItem(e),r=null==n?void 0:n.item;if(null==r?void 0:r.topImage){const t=new gl({roughness:.5,metalness:.1});return this._materialFactory.textureLoaderInstance.load(r.topImage,(e=>{e.wrapS=k,e.wrapT=k;let n=new Me(1,1);r.width&&r.width>0&&(n.x=1/r.width),r.depth&&r.depth>0&&(n.y=1/r.depth),e.repeat.set(n.x,n.y),t.map=e})),t}return null}_debugLogPlanElements(t){const e=t.catalogItems;for(const t of e)console.log(`loaded catalog item ${t.item.id}`);const n=t.planElements.length;console.log(`elements in plan ${n}`);const r=t.configurationManager.objectMap.size;console.log(`objects in object map ${r}`);const i=t.planMeshes,a=t.materials;console.log(`plan meshes: ${i.length}`),console.log(`used materials: ${a.size}`)}}const Uu=new RegExp(/\/3d\/[0-9]+\//),Fu=t=>{var e;if(null===(e=t.assets.glb)||void 0===e?void 0:e.url)return t.assets.glb.url;if(t.threeDimensionalAsset)return t.threeDimensionalAsset;const n=t.threeDimensionalAssetWeb;return n&&"string"==typeof n?n.match(Uu)?n.replace(Uu,"/3d/glb/").replace(".flash.u3d",".glb"):n:""},Bu=(t,e,n,r,i,a,s)=>{if(!t||!t.scene||!t.scene.children||0===t.scene.children.length)return null;e&&t.scene.position.copy(e),n&&(t.scene.rotation.y=n);const o=new nn;if(o.setFromObject(t.scene),r){const{x:e,y:n,z:i}=o.getSize(new Qe);let a=new Qe(r.x/e,r.y/n,r.z/i);t.scene.scale.copy(a)}return i&&t.scene.scale.multiply(i),t.scene.traverse((t=>{if(t instanceof ei){if(t.material instanceof ml){const e=t.material;if(s&&a&&a>0){let t=new wr(a);e.color=t.copySRGBToLinear(t),e.roughness=.5,e.metalness=.1}e.needsUpdate=!0}t.castShadow=!0,t.receiveShadow=!0}})),{boundingBox:o,scene:t.scene}};var ku=function(t,e,n,r){return new(n||(n=Promise))((function(i,a){function s(t){try{l(r.next(t))}catch(t){a(t)}}function o(t){try{l(r.throw(t))}catch(t){a(t)}}function l(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,o)}l((r=r.apply(t,e||[])).next())}))};const zu="configuration",Hu="plan";class Gu{constructor(t,e,n){this._sceneCache=new Map,this._dracoLoader=t,this._coreModule=e,this._renderUpdateCallback=n}getScene(t){var e;return null!==(e=this._sceneCache.get(t))&&void 0!==e?e:null}getOrLoadScene(t){return ku(this,void 0,void 0,(function*(){var e;let n=this.getScene(t.id);if(n)return n;switch(t.type){case zu:n=yield this._loadConfiguration(t.id);break;case Hu:n=yield this._loadPlan(t.id);break;case"glb":n=yield this._loadGLb(null!==(e=t.resource)&&void 0!==e?e:t.id)}return this._sceneCache.set(t.id,n),n}))}loadSceneFromId(t){return ku(this,void 0,void 0,(function*(){let e;const n=t.toLowerCase();return e=n.endsWith(".glb")||n.endsWith(".gltf")?yield this._loadGLb(t):t.startsWith("ps_")||-1===t.indexOf(":")?yield this._loadPlan(t):yield this._loadConfiguration(t),e}))}_loadConfiguration(t){return ku(this,void 0,void 0,(function*(){const e=new Bc,n=yield e.loadAsync(t,this._coreModule);return{type:zu,sceneObject:n.scene,animations:[]}}))}_loadPlan(t){return ku(this,void 0,void 0,(function*(){const e=new Nu(this._dracoLoader,this._renderUpdateCallback),n=yield e.loadAsync(t,this._coreModule);return{type:Hu,sceneObject:n.scene,animations:[]}}))}_loadGLb(t){return ku(this,void 0,void 0,(function*(){const e=new Gc;e.setDRACOLoader(this._dracoLoader);const n=yield e.loadAsync(t);return this._updateGLTFScene(n,(t=>{if(t.isMesh){const e=t.material;e instanceof ml&&!1===e.transparent&&(t.castShadow=!0,t.receiveShadow=!0)}})),{type:"glb",sceneObject:n.scene,animations:n.animations}}))}_updateGLTFScene(t,e){t.scene.traverse((t=>{t instanceof ei&&(e(t),t.material instanceof ml&&(t.material.envMapIntensity=1,t.material.needsUpdate=!0))}))}}const Vu={type:"change"},Wu={type:"start"},ju={type:"end"},qu=new Cn,Xu=new bi,Yu=Math.cos(70*be),$u=new Qe,Ku=2*Math.PI,Zu=-1,Ju=1e-6;class Qu extends Tc{constructor(t,e=null){super(t,e),this.state=Zu,this.enabled=!0,this.target=new Qe,this.cursor=new Qe,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:0,MIDDLE:1,RIGHT:2},this.touches={ONE:0,TWO:2},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new Qe,this._lastQuaternion=new Je,this._lastTargetPosition=new Qe,this._quat=(new Je).setFromUnitVectors(t.up,new Qe(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new xc,this._sphericalDelta=new xc,this._scale=1,this._panOffset=new Qe,this._rotateStart=new Me,this._rotateEnd=new Me,this._rotateDelta=new Me,this._panStart=new Me,this._panEnd=new Me,this._panDelta=new Me,this._dollyStart=new Me,this._dollyEnd=new Me,this._dollyDelta=new Me,this._dollyDirection=new Qe,this._mouse=new Me,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=eh.bind(this),this._onPointerDown=th.bind(this),this._onPointerUp=nh.bind(this),this._onContextMenu=ch.bind(this),this._onMouseWheel=ah.bind(this),this._onKeyDown=sh.bind(this),this._onTouchStart=oh.bind(this),this._onTouchMove=lh.bind(this),this._onMouseDown=rh.bind(this),this._onMouseMove=ih.bind(this),this._interceptControlDown=uh.bind(this),this._interceptControlUp=hh.bind(this),null!==this.domElement&&this.connect(),this.update()}connect(){this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(t){t.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=t}stopListenToKeyEvents(){null!==this._domElementKeyEvents&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(Vu),this.update(),this.state=Zu}update(t=null){const e=this.object.position;$u.copy(e).sub(this.target),$u.applyQuaternion(this._quat),this._spherical.setFromVector3($u),this.autoRotate&&this.state===Zu&&this._rotateLeft(this._getAutoRotationAngle(t)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let n=this.minAzimuthAngle,r=this.maxAzimuthAngle;isFinite(n)&&isFinite(r)&&(n<-Math.PI?n+=Ku:n>Math.PI&&(n-=Ku),r<-Math.PI?r+=Ku:r>Math.PI&&(r-=Ku),this._spherical.theta=n<=r?Math.max(n,Math.min(r,this._spherical.theta)):this._spherical.theta>(n+r)/2?Math.max(n,this._spherical.theta):Math.min(r,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),!0===this.enableDamping?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let i=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const t=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),i=t!=this._spherical.radius}if($u.setFromSpherical(this._spherical),$u.applyQuaternion(this._quatInverse),e.copy(this.target).add($u),this.object.lookAt(this.target),!0===this.enableDamping?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let t=null;if(this.object.isPerspectiveCamera){const e=$u.length();t=this._clampDistance(e*this._scale);const n=e-t;this.object.position.addScaledVector(this._dollyDirection,n),this.object.updateMatrixWorld(),i=!!n}else if(this.object.isOrthographicCamera){const e=new Qe(this._mouse.x,this._mouse.y,0);e.unproject(this.object);const n=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),i=n!==this.object.zoom;const r=new Qe(this._mouse.x,this._mouse.y,0);r.unproject(this.object),this.object.position.sub(r).add(e),this.object.updateMatrixWorld(),t=$u.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;null!==t&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(t).add(this.object.position):(qu.origin.copy(this.object.position),qu.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(qu.direction))<Yu?this.object.lookAt(this.target):(Xu.setFromNormalAndCoplanarPoint(this.object.up,this.target),qu.intersectPlane(Xu,this.target))))}else if(this.object.isOrthographicCamera){const t=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),t!==this.object.zoom&&(this.object.updateProjectionMatrix(),i=!0)}return this._scale=1,this._performCursorZoom=!1,!!(i||this._lastPosition.distanceToSquared(this.object.position)>Ju||8*(1-this._lastQuaternion.dot(this.object.quaternion))>Ju||this._lastTargetPosition.distanceToSquared(this.target)>Ju)&&(this.dispatchEvent(Vu),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0)}_getAutoRotationAngle(t){return null!==t?Ku/60*this.autoRotateSpeed*t:Ku/60/60*this.autoRotateSpeed}_getZoomScale(t){const e=Math.abs(.01*t);return Math.pow(.95,this.zoomSpeed*e)}_rotateLeft(t){this._sphericalDelta.theta-=t}_rotateUp(t){this._sphericalDelta.phi-=t}_panLeft(t,e){$u.setFromMatrixColumn(e,0),$u.multiplyScalar(-t),this._panOffset.add($u)}_panUp(t,e){!0===this.screenSpacePanning?$u.setFromMatrixColumn(e,1):($u.setFromMatrixColumn(e,0),$u.crossVectors(this.object.up,$u)),$u.multiplyScalar(t),this._panOffset.add($u)}_pan(t,e){const n=this.domElement;if(this.object.isPerspectiveCamera){const r=this.object.position;$u.copy(r).sub(this.target);let i=$u.length();i*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*t*i/n.clientHeight,this.object.matrix),this._panUp(2*e*i/n.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(t*(this.object.right-this.object.left)/this.object.zoom/n.clientWidth,this.object.matrix),this._panUp(e*(this.object.top-this.object.bottom)/this.object.zoom/n.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(t,e){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const n=this.domElement.getBoundingClientRect(),r=t-n.left,i=e-n.top,a=n.width,s=n.height;this._mouse.x=r/a*2-1,this._mouse.y=-i/s*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(t){return Math.max(this.minDistance,Math.min(this.maxDistance,t))}_handleMouseDownRotate(t){this._rotateStart.set(t.clientX,t.clientY)}_handleMouseDownDolly(t){this._updateZoomParameters(t.clientX,t.clientX),this._dollyStart.set(t.clientX,t.clientY)}_handleMouseDownPan(t){this._panStart.set(t.clientX,t.clientY)}_handleMouseMoveRotate(t){this._rotateEnd.set(t.clientX,t.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const e=this.domElement;this._rotateLeft(Ku*this._rotateDelta.x/e.clientHeight),this._rotateUp(Ku*this._rotateDelta.y/e.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(t){this._dollyEnd.set(t.clientX,t.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(t){this._panEnd.set(t.clientX,t.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(t){this._updateZoomParameters(t.clientX,t.clientY),t.deltaY<0?this._dollyIn(this._getZoomScale(t.deltaY)):t.deltaY>0&&this._dollyOut(this._getZoomScale(t.deltaY)),this.update()}_handleKeyDown(t){let e=!1;switch(t.code){case this.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateUp(Ku*this.rotateSpeed/this.domElement.clientHeight):this._pan(0,this.keyPanSpeed),e=!0;break;case this.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateUp(-Ku*this.rotateSpeed/this.domElement.clientHeight):this._pan(0,-this.keyPanSpeed),e=!0;break;case this.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateLeft(Ku*this.rotateSpeed/this.domElement.clientHeight):this._pan(this.keyPanSpeed,0),e=!0;break;case this.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateLeft(-Ku*this.rotateSpeed/this.domElement.clientHeight):this._pan(-this.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),this.update())}_handleTouchStartRotate(t){if(1===this._pointers.length)this._rotateStart.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),n=.5*(t.pageX+e.x),r=.5*(t.pageY+e.y);this._rotateStart.set(n,r)}}_handleTouchStartPan(t){if(1===this._pointers.length)this._panStart.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),n=.5*(t.pageX+e.x),r=.5*(t.pageY+e.y);this._panStart.set(n,r)}}_handleTouchStartDolly(t){const e=this._getSecondPointerPosition(t),n=t.pageX-e.x,r=t.pageY-e.y,i=Math.sqrt(n*n+r*r);this._dollyStart.set(0,i)}_handleTouchStartDollyPan(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enablePan&&this._handleTouchStartPan(t)}_handleTouchStartDollyRotate(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enableRotate&&this._handleTouchStartRotate(t)}_handleTouchMoveRotate(t){if(1==this._pointers.length)this._rotateEnd.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),n=.5*(t.pageX+e.x),r=.5*(t.pageY+e.y);this._rotateEnd.set(n,r)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const e=this.domElement;this._rotateLeft(Ku*this._rotateDelta.x/e.clientHeight),this._rotateUp(Ku*this._rotateDelta.y/e.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(t){if(1===this._pointers.length)this._panEnd.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),n=.5*(t.pageX+e.x),r=.5*(t.pageY+e.y);this._panEnd.set(n,r)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(t){const e=this._getSecondPointerPosition(t),n=t.pageX-e.x,r=t.pageY-e.y,i=Math.sqrt(n*n+r*r);this._dollyEnd.set(0,i),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const a=.5*(t.pageX+e.x),s=.5*(t.pageY+e.y);this._updateZoomParameters(a,s)}_handleTouchMoveDollyPan(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enablePan&&this._handleTouchMovePan(t)}_handleTouchMoveDollyRotate(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enableRotate&&this._handleTouchMoveRotate(t)}_addPointer(t){this._pointers.push(t.pointerId)}_removePointer(t){delete this._pointerPositions[t.pointerId];for(let e=0;e<this._pointers.length;e++)if(this._pointers[e]==t.pointerId)return void this._pointers.splice(e,1)}_isTrackingPointer(t){for(let e=0;e<this._pointers.length;e++)if(this._pointers[e]==t.pointerId)return!0;return!1}_trackPointer(t){let e=this._pointerPositions[t.pointerId];void 0===e&&(e=new Me,this._pointerPositions[t.pointerId]=e),e.set(t.pageX,t.pageY)}_getSecondPointerPosition(t){const e=t.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[e]}_customWheelEvent(t){const e=t.deltaMode,n={clientX:t.clientX,clientY:t.clientY,deltaY:t.deltaY};switch(e){case 1:n.deltaY*=16;break;case 2:n.deltaY*=100}return t.ctrlKey&&!this._controlActive&&(n.deltaY*=10),n}}function th(t){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._isTrackingPointer(t)||(this._addPointer(t),"touch"===t.pointerType?this._onTouchStart(t):this._onMouseDown(t)))}function eh(t){!1!==this.enabled&&("touch"===t.pointerType?this._onTouchMove(t):this._onMouseMove(t))}function nh(t){switch(this._removePointer(t),this._pointers.length){case 0:this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(ju),this.state=Zu;break;case 1:const e=this._pointers[0],n=this._pointerPositions[e];this._onTouchStart({pointerId:e,pageX:n.x,pageY:n.y})}}function rh(t){let e;switch(t.button){case 0:e=this.mouseButtons.LEFT;break;case 1:e=this.mouseButtons.MIDDLE;break;case 2:e=this.mouseButtons.RIGHT;break;default:e=-1}switch(e){case 1:if(!1===this.enableZoom)return;this._handleMouseDownDolly(t),this.state=1;break;case 0:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=2}else{if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=0}break;case 2:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=0}else{if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=2}break;default:this.state=Zu}this.state!==Zu&&this.dispatchEvent(Wu)}function ih(t){switch(this.state){case 0:if(!1===this.enableRotate)return;this._handleMouseMoveRotate(t);break;case 1:if(!1===this.enableZoom)return;this._handleMouseMoveDolly(t);break;case 2:if(!1===this.enablePan)return;this._handleMouseMovePan(t)}}function ah(t){!1!==this.enabled&&!1!==this.enableZoom&&this.state===Zu&&(t.preventDefault(),this.dispatchEvent(Wu),this._handleMouseWheel(this._customWheelEvent(t)),this.dispatchEvent(ju))}function sh(t){!1!==this.enabled&&!1!==this.enablePan&&this._handleKeyDown(t)}function oh(t){switch(this._trackPointer(t),this._pointers.length){case 1:switch(this.touches.ONE){case 0:if(!1===this.enableRotate)return;this._handleTouchStartRotate(t),this.state=3;break;case 1:if(!1===this.enablePan)return;this._handleTouchStartPan(t),this.state=4;break;default:this.state=Zu}break;case 2:switch(this.touches.TWO){case 2:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchStartDollyPan(t),this.state=5;break;case 3:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchStartDollyRotate(t),this.state=6;break;default:this.state=Zu}break;default:this.state=Zu}this.state!==Zu&&this.dispatchEvent(Wu)}function lh(t){switch(this._trackPointer(t),this.state){case 3:if(!1===this.enableRotate)return;this._handleTouchMoveRotate(t),this.update();break;case 4:if(!1===this.enablePan)return;this._handleTouchMovePan(t),this.update();break;case 5:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchMoveDollyPan(t),this.update();break;case 6:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchMoveDollyRotate(t),this.update();break;default:this.state=Zu}}function ch(t){!1!==this.enabled&&t.preventDefault()}function uh(t){"Control"===t.key&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function hh(t){"Control"===t.key&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}const dh=new class{constructor(t,e,n=0,r=1/0){this.ray=new Cn(t,e),this.near=n,this.far=r,this.camera=null,this.layers=new Hn,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}setFromXRController(t){return vc.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(vc),this}intersectObject(t,e=!0,n=[]){return yc(t,this,n,e),n.sort(_c),n}intersectObjects(t,e=!0,n=[]){for(let r=0,i=t.length;r<i;r++)yc(t[r],this,n,e);return n.sort(_c),n}},ph=new Qe,fh=new Qe,mh=new Je,gh={X:new Qe(1,0,0),Y:new Qe(0,1,0),Z:new Qe(0,0,1)},vh={type:"change"},_h={type:"mouseDown",mode:null},yh={type:"mouseUp",mode:null},xh={type:"objectChange"};class bh extends Tc{constructor(t,e=null){super(void 0,e);const n=new Gh(this);this._root=n;const r=new Vh;this._gizmo=r,n.add(r);const i=new Wh;this._plane=i,n.add(i);const a=this;function s(t,e){let n=e;Object.defineProperty(a,t,{get:function(){return void 0!==n?n:e},set:function(e){n!==e&&(n=e,i[t]=e,r[t]=e,a.dispatchEvent({type:t+"-changed",value:e}),a.dispatchEvent(vh))}}),a[t]=e,i[t]=e,r[t]=e}s("camera",t),s("object",void 0),s("enabled",!0),s("axis",null),s("mode","translate"),s("translationSnap",null),s("rotationSnap",null),s("scaleSnap",null),s("space","world"),s("size",1),s("dragging",!1),s("showX",!0),s("showY",!0),s("showZ",!0),s("minX",-1/0),s("maxX",1/0),s("minY",-1/0),s("maxY",1/0),s("minZ",-1/0),s("maxZ",1/0);const o=new Qe,l=new Qe,c=new Je,u=new Je,h=new Qe,d=new Je,p=new Qe,f=new Qe,m=new Qe,g=new Qe;s("worldPosition",o),s("worldPositionStart",l),s("worldQuaternion",c),s("worldQuaternionStart",u),s("cameraPosition",h),s("cameraQuaternion",d),s("pointStart",p),s("pointEnd",f),s("rotationAxis",m),s("rotationAngle",0),s("eye",g),this._offset=new Qe,this._startNorm=new Qe,this._endNorm=new Qe,this._cameraScale=new Qe,this._parentPosition=new Qe,this._parentQuaternion=new Je,this._parentQuaternionInv=new Je,this._parentScale=new Qe,this._worldScaleStart=new Qe,this._worldQuaternionInv=new Je,this._worldScale=new Qe,this._positionStart=new Qe,this._quaternionStart=new Je,this._scaleStart=new Qe,this._getPointer=wh.bind(this),this._onPointerDown=Th.bind(this),this._onPointerHover=Mh.bind(this),this._onPointerMove=Eh.bind(this),this._onPointerUp=Sh.bind(this),null!==e&&this.connect()}connect(){this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.style.touchAction="auto"}getHelper(){return this._root}pointerHover(t){if(void 0===this.object||!0===this.dragging)return;null!==t&&dh.setFromCamera(t,this.camera);const e=Ah(this._gizmo.picker[this.mode],dh);this.axis=e?e.object.name:null}pointerDown(t){if(void 0!==this.object&&!0!==this.dragging&&(null==t||0===t.button)&&null!==this.axis){null!==t&&dh.setFromCamera(t,this.camera);const e=Ah(this._plane,dh,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,_h.mode=this.mode,this.dispatchEvent(_h)}}pointerMove(t){const e=this.axis,n=this.mode,r=this.object;let i=this.space;if("scale"===n?i="local":"E"!==e&&"XYZE"!==e&&"XYZ"!==e||(i="world"),void 0===r||null===e||!1===this.dragging||null!==t&&-1!==t.button)return;null!==t&&dh.setFromCamera(t,this.camera);const a=Ah(this._plane,dh,!0);if(a){if(this.pointEnd.copy(a.point).sub(this.worldPositionStart),"translate"===n)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===i&&"XYZ"!==e&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===e.indexOf("X")&&(this._offset.x=0),-1===e.indexOf("Y")&&(this._offset.y=0),-1===e.indexOf("Z")&&(this._offset.z=0),"local"===i&&"XYZ"!==e?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),r.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===i&&(r.position.applyQuaternion(mh.copy(this._quaternionStart).invert()),-1!==e.search("X")&&(r.position.x=Math.round(r.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(r.position.y=Math.round(r.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(r.position.z=Math.round(r.position.z/this.translationSnap)*this.translationSnap),r.position.applyQuaternion(this._quaternionStart)),"world"===i&&(r.parent&&r.position.add(ph.setFromMatrixPosition(r.parent.matrixWorld)),-1!==e.search("X")&&(r.position.x=Math.round(r.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(r.position.y=Math.round(r.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(r.position.z=Math.round(r.position.z/this.translationSnap)*this.translationSnap),r.parent&&r.position.sub(ph.setFromMatrixPosition(r.parent.matrixWorld)))),r.position.x=Math.max(this.minX,Math.min(this.maxX,r.position.x)),r.position.y=Math.max(this.minY,Math.min(this.maxY,r.position.y)),r.position.z=Math.max(this.minZ,Math.min(this.maxZ,r.position.z));else if("scale"===n){if(-1!==e.search("XYZ")){let t=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(t*=-1),fh.set(t,t,t)}else ph.copy(this.pointStart),fh.copy(this.pointEnd),ph.applyQuaternion(this._worldQuaternionInv),fh.applyQuaternion(this._worldQuaternionInv),fh.divide(ph),-1===e.search("X")&&(fh.x=1),-1===e.search("Y")&&(fh.y=1),-1===e.search("Z")&&(fh.z=1);r.scale.copy(this._scaleStart).multiply(fh),this.scaleSnap&&(-1!==e.search("X")&&(r.scale.x=Math.round(r.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Y")&&(r.scale.y=Math.round(r.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Z")&&(r.scale.z=Math.round(r.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===n){this._offset.copy(this.pointEnd).sub(this.pointStart);const t=20/this.worldPosition.distanceTo(ph.setFromMatrixPosition(this.camera.matrixWorld));let n=!1;"XYZE"===e?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(ph.copy(this.rotationAxis).cross(this.eye))*t):"X"!==e&&"Y"!==e&&"Z"!==e||(this.rotationAxis.copy(gh[e]),ph.copy(gh[e]),"local"===i&&ph.applyQuaternion(this.worldQuaternion),ph.cross(this.eye),0===ph.length()?n=!0:this.rotationAngle=this._offset.dot(ph.normalize())*t),("E"===e||n)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===i&&"E"!==e&&"XYZE"!==e?(r.quaternion.copy(this._quaternionStart),r.quaternion.multiply(mh.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),r.quaternion.copy(mh.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),r.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(vh),this.dispatchEvent(xh)}}pointerUp(t){null!==t&&0!==t.button||(this.dragging&&null!==this.axis&&(yh.mode=this.mode,this.dispatchEvent(yh)),this.dragging=!1,this.axis=null)}dispose(){this.disconnect(),this._root.dispose()}attach(t){return this.object=t,this._root.visible=!0,this}detach(){return this.object=void 0,this.axis=null,this._root.visible=!1,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(vh),this.dispatchEvent(xh),this.pointStart.copy(this.pointEnd))}getRaycaster(){return dh}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}}function wh(t){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:t.button};{const e=this.domElement.getBoundingClientRect();return{x:(t.clientX-e.left)/e.width*2-1,y:-(t.clientY-e.top)/e.height*2+1,button:t.button}}}function Mh(t){if(this.enabled)switch(t.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(t))}}function Th(t){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(t)),this.pointerDown(this._getPointer(t)))}function Eh(t){this.enabled&&this.pointerMove(this._getPointer(t))}function Sh(t){this.enabled&&(this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(t)))}function Ah(t,e,n){const r=e.intersectObject(t,!0);for(let t=0;t<r.length;t++)if(r[t].object.visible||n)return r[t];return!1}const Rh=new zn,Ch=new Qe(0,1,0),Ph=new Qe(0,0,0),Ih=new Pn,Lh=new Je,Dh=new Je,Oh=new Qe,Nh=new Pn,Uh=new Qe(1,0,0),Fh=new Qe(0,1,0),Bh=new Qe(0,0,1),kh=new Qe,zh=new Qe,Hh=new Qe;class Gh extends rr{constructor(t){super(),this.isTransformControlsRoot=!0,this.controls=t,this.visible=!1}updateMatrixWorld(t){const e=this.controls;void 0!==e.object&&(e.object.updateMatrixWorld(),null===e.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):e.object.parent.matrixWorld.decompose(e._parentPosition,e._parentQuaternion,e._parentScale),e.object.matrixWorld.decompose(e.worldPosition,e.worldQuaternion,e._worldScale),e._parentQuaternionInv.copy(e._parentQuaternion).invert(),e._worldQuaternionInv.copy(e.worldQuaternion).invert()),e.camera.updateMatrixWorld(),e.camera.matrixWorld.decompose(e.cameraPosition,e.cameraQuaternion,e._cameraScale),e.camera.isOrthographicCamera?e.camera.getWorldDirection(e.eye).negate():e.eye.copy(e.cameraPosition).sub(e.worldPosition).normalize(),super.updateMatrixWorld(t)}dispose(){this.traverse((function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()}))}}class Vh extends rr{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const t=new Sr({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new Vo({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),n=t.clone();n.opacity=.15;const r=e.clone();r.opacity=.5;const i=t.clone();i.color.setHex(16711680);const a=t.clone();a.color.setHex(65280);const s=t.clone();s.color.setHex(255);const o=t.clone();o.color.setHex(16711680),o.opacity=.5;const l=t.clone();l.color.setHex(65280),l.opacity=.5;const c=t.clone();c.color.setHex(255),c.opacity=.5;const u=t.clone();u.opacity=.25;const h=t.clone();h.color.setHex(16776960),h.opacity=.25,t.clone().color.setHex(16776960);const d=t.clone();d.color.setHex(7895160);const p=new ul(0,.04,.1,12);p.translate(0,.05,0);const f=new ri(.08,.08,.08);f.translate(0,.04,0);const m=new Vr;m.setAttribute("position",new Nr([0,0,0,1,0,0],3));const g=new ul(.0075,.0075,.5,3);function v(t,e){const n=new fl(t,.0075,3,64,e*Math.PI*2);return n.rotateY(Math.PI/2),n.rotateX(Math.PI/2),n}g.translate(0,.25,0);const _={X:[[new ei(p,i),[.5,0,0],[0,0,-Math.PI/2]],[new ei(p,i),[-.5,0,0],[0,0,Math.PI/2]],[new ei(g,i),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new ei(p,a),[0,.5,0]],[new ei(p,a),[0,-.5,0],[Math.PI,0,0]],[new ei(g,a)]],Z:[[new ei(p,s),[0,0,.5],[Math.PI/2,0,0]],[new ei(p,s),[0,0,-.5],[-Math.PI/2,0,0]],[new ei(g,s),null,[Math.PI/2,0,0]]],XYZ:[[new ei(new dl(.1,0),u.clone()),[0,0,0]]],XY:[[new ei(new ri(.15,.15,.01),c.clone()),[.15,.15,0]]],YZ:[[new ei(new ri(.15,.15,.01),o.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ei(new ri(.15,.15,.01),l.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},y={X:[[new ei(new ul(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new ei(new ul(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new ei(new ul(.2,0,.6,4),n),[0,.3,0]],[new ei(new ul(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new ei(new ul(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new ei(new ul(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new ei(new dl(.2,0),n)]],XY:[[new ei(new ri(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new ei(new ri(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ei(new ri(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]]},x={START:[[new ei(new dl(.01,2),r),null,null,null,"helper"]],END:[[new ei(new dl(.01,2),r),null,null,null,"helper"]],DELTA:[[new Zo(function(){const t=new Vr;return t.setAttribute("position",new Nr([0,0,0,1,1,1],3)),t}(),r),null,null,null,"helper"]],X:[[new Zo(m,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Zo(m,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Zo(m,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},b={XYZE:[[new ei(v(.5,1),d),null,[0,Math.PI/2,0]]],X:[[new ei(v(.5,.5),i)]],Y:[[new ei(v(.5,.5),a),null,[0,0,-Math.PI/2]]],Z:[[new ei(v(.5,.5),s),null,[0,Math.PI/2,0]]],E:[[new ei(v(.75,1),h),null,[0,Math.PI/2,0]]]},w={AXIS:[[new Zo(m,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},M={XYZE:[[new ei(new pl(.25,10,8),n)]],X:[[new ei(new fl(.5,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new ei(new fl(.5,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new ei(new fl(.5,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new ei(new fl(.75,.1,2,24),n)]]},T={X:[[new ei(f,i),[.5,0,0],[0,0,-Math.PI/2]],[new ei(g,i),[0,0,0],[0,0,-Math.PI/2]],[new ei(f,i),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new ei(f,a),[0,.5,0]],[new ei(g,a)],[new ei(f,a),[0,-.5,0],[0,0,Math.PI]]],Z:[[new ei(f,s),[0,0,.5],[Math.PI/2,0,0]],[new ei(g,s),[0,0,0],[Math.PI/2,0,0]],[new ei(f,s),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new ei(new ri(.15,.15,.01),c),[.15,.15,0]]],YZ:[[new ei(new ri(.15,.15,.01),o),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ei(new ri(.15,.15,.01),l),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new ei(new ri(.1,.1,.1),u.clone())]]},E={X:[[new ei(new ul(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new ei(new ul(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new ei(new ul(.2,0,.6,4),n),[0,.3,0]],[new ei(new ul(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new ei(new ul(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new ei(new ul(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new ei(new ri(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new ei(new ri(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ei(new ri(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new ei(new ri(.2,.2,.2),n),[0,0,0]]]},S={X:[[new Zo(m,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Zo(m,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Zo(m,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function A(t){const e=new rr;for(const n in t)for(let r=t[n].length;r--;){const i=t[n][r][0].clone(),a=t[n][r][1],s=t[n][r][2],o=t[n][r][3],l=t[n][r][4];i.name=n,i.tag=l,a&&i.position.set(a[0],a[1],a[2]),s&&i.rotation.set(s[0],s[1],s[2]),o&&i.scale.set(o[0],o[1],o[2]),i.updateMatrix();const c=i.geometry.clone();c.applyMatrix4(i.matrix),i.geometry=c,i.renderOrder=1/0,i.position.set(0,0,0),i.rotation.set(0,0,0),i.scale.set(1,1,1),e.add(i)}return e}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=A(_)),this.add(this.gizmo.rotate=A(b)),this.add(this.gizmo.scale=A(T)),this.add(this.picker.translate=A(y)),this.add(this.picker.rotate=A(M)),this.add(this.picker.scale=A(E)),this.add(this.helper.translate=A(x)),this.add(this.helper.rotate=A(w)),this.add(this.helper.scale=A(S)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(t){const e="local"===("scale"===this.mode?"local":this.space)?this.worldQuaternion:Dh;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let n=[];n=n.concat(this.picker[this.mode].children),n=n.concat(this.gizmo[this.mode].children),n=n.concat(this.helper[this.mode].children);for(let t=0;t<n.length;t++){const r=n[t];let i;if(r.visible=!0,r.rotation.set(0,0,0),r.position.copy(this.worldPosition),i=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),r.scale.set(1,1,1).multiplyScalar(i*this.size/4),"helper"!==r.tag){if(r.quaternion.copy(e),"translate"===this.mode||"scale"===this.mode){const t=.99,n=.2;"X"===r.name&&Math.abs(Ch.copy(Uh).applyQuaternion(e).dot(this.eye))>t&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"Y"===r.name&&Math.abs(Ch.copy(Fh).applyQuaternion(e).dot(this.eye))>t&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"Z"===r.name&&Math.abs(Ch.copy(Bh).applyQuaternion(e).dot(this.eye))>t&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"XY"===r.name&&Math.abs(Ch.copy(Bh).applyQuaternion(e).dot(this.eye))<n&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"YZ"===r.name&&Math.abs(Ch.copy(Uh).applyQuaternion(e).dot(this.eye))<n&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"XZ"===r.name&&Math.abs(Ch.copy(Fh).applyQuaternion(e).dot(this.eye))<n&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1)}else"rotate"===this.mode&&(Lh.copy(e),Ch.copy(this.eye).applyQuaternion(mh.copy(e).invert()),-1!==r.name.search("E")&&r.quaternion.setFromRotationMatrix(Ih.lookAt(this.eye,Ph,Fh)),"X"===r.name&&(mh.setFromAxisAngle(Uh,Math.atan2(-Ch.y,Ch.z)),mh.multiplyQuaternions(Lh,mh),r.quaternion.copy(mh)),"Y"===r.name&&(mh.setFromAxisAngle(Fh,Math.atan2(Ch.x,Ch.z)),mh.multiplyQuaternions(Lh,mh),r.quaternion.copy(mh)),"Z"===r.name&&(mh.setFromAxisAngle(Bh,Math.atan2(Ch.y,Ch.x)),mh.multiplyQuaternions(Lh,mh),r.quaternion.copy(mh)));r.visible=r.visible&&(-1===r.name.indexOf("X")||this.showX),r.visible=r.visible&&(-1===r.name.indexOf("Y")||this.showY),r.visible=r.visible&&(-1===r.name.indexOf("Z")||this.showZ),r.visible=r.visible&&(-1===r.name.indexOf("E")||this.showX&&this.showY&&this.showZ),r.material._color=r.material._color||r.material.color.clone(),r.material._opacity=r.material._opacity||r.material.opacity,r.material.color.copy(r.material._color),r.material.opacity=r.material._opacity,this.enabled&&this.axis&&(r.name===this.axis||this.axis.split("").some((function(t){return r.name===t})))&&(r.material.color.setHex(16776960),r.material.opacity=1)}else r.visible=!1,"AXIS"===r.name?(r.visible=!!this.axis,"X"===this.axis&&(mh.setFromEuler(Rh.set(0,0,0)),r.quaternion.copy(e).multiply(mh),Math.abs(Ch.copy(Uh).applyQuaternion(e).dot(this.eye))>.9&&(r.visible=!1)),"Y"===this.axis&&(mh.setFromEuler(Rh.set(0,0,Math.PI/2)),r.quaternion.copy(e).multiply(mh),Math.abs(Ch.copy(Fh).applyQuaternion(e).dot(this.eye))>.9&&(r.visible=!1)),"Z"===this.axis&&(mh.setFromEuler(Rh.set(0,Math.PI/2,0)),r.quaternion.copy(e).multiply(mh),Math.abs(Ch.copy(Bh).applyQuaternion(e).dot(this.eye))>.9&&(r.visible=!1)),"XYZE"===this.axis&&(mh.setFromEuler(Rh.set(0,Math.PI/2,0)),Ch.copy(this.rotationAxis),r.quaternion.setFromRotationMatrix(Ih.lookAt(Ph,Ch,Fh)),r.quaternion.multiply(mh),r.visible=this.dragging),"E"===this.axis&&(r.visible=!1)):"START"===r.name?(r.position.copy(this.worldPositionStart),r.visible=this.dragging):"END"===r.name?(r.position.copy(this.worldPosition),r.visible=this.dragging):"DELTA"===r.name?(r.position.copy(this.worldPositionStart),r.quaternion.copy(this.worldQuaternionStart),ph.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),ph.applyQuaternion(this.worldQuaternionStart.clone().invert()),r.scale.copy(ph),r.visible=this.dragging):(r.quaternion.copy(e),this.dragging?r.position.copy(this.worldPositionStart):r.position.copy(this.worldPosition),this.axis&&(r.visible=-1!==this.axis.search(r.name)))}super.updateMatrixWorld(t)}}class Wh extends ei{constructor(){super(new Ai(1e5,1e5,2,2),new Sr({visible:!1,wireframe:!0,side:2,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(e="local"),kh.copy(Uh).applyQuaternion("local"===e?this.worldQuaternion:Dh),zh.copy(Fh).applyQuaternion("local"===e?this.worldQuaternion:Dh),Hh.copy(Bh).applyQuaternion("local"===e?this.worldQuaternion:Dh),Ch.copy(zh),this.mode){case"translate":case"scale":switch(this.axis){case"X":Ch.copy(this.eye).cross(kh),Oh.copy(kh).cross(Ch);break;case"Y":Ch.copy(this.eye).cross(zh),Oh.copy(zh).cross(Ch);break;case"Z":Ch.copy(this.eye).cross(Hh),Oh.copy(Hh).cross(Ch);break;case"XY":Oh.copy(Hh);break;case"YZ":Oh.copy(kh);break;case"XZ":Ch.copy(Hh),Oh.copy(zh);break;case"XYZ":case"E":Oh.set(0,0,0)}break;default:Oh.set(0,0,0)}0===Oh.length()?this.quaternion.copy(this.cameraQuaternion):(Nh.lookAt(ph.set(0,0,0),Oh,Ch),this.quaternion.setFromRotationMatrix(Nh)),super.updateMatrixWorld(t)}}var jh=Uint8Array,qh=Uint16Array,Xh=Int32Array,Yh=new jh([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),$h=new jh([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Kh=new jh([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Zh=function(t,e){for(var n=new qh(31),r=0;r<31;++r)n[r]=e+=1<<t[r-1];var i=new Xh(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)i[a]=a-n[r]<<5|r;return{b:n,r:i}},Jh=Zh(Yh,2),Qh=Jh.b,td=Jh.r;Qh[28]=258,td[258]=28;for(var ed=Zh($h,0),nd=ed.b,rd=(ed.r,new qh(32768)),id=0;id<32768;++id){var ad=(43690&id)>>1|(21845&id)<<1;ad=(61680&(ad=(52428&ad)>>2|(13107&ad)<<2))>>4|(3855&ad)<<4,rd[id]=((65280&ad)>>8|(255&ad)<<8)>>1}var sd=function(t,e,n){for(var r=t.length,i=0,a=new qh(e);i<r;++i)t[i]&&++a[t[i]-1];var s,o=new qh(e);for(i=1;i<e;++i)o[i]=o[i-1]+a[i-1]<<1;if(n){s=new qh(1<<e);var l=15-e;for(i=0;i<r;++i)if(t[i])for(var c=i<<4|t[i],u=e-t[i],h=o[t[i]-1]++<<u,d=h|(1<<u)-1;h<=d;++h)s[rd[h]>>l]=c}else for(s=new qh(r),i=0;i<r;++i)t[i]&&(s[i]=rd[o[t[i]-1]++]>>15-t[i]);return s},od=new jh(288);for(id=0;id<144;++id)od[id]=8;for(id=144;id<256;++id)od[id]=9;for(id=256;id<280;++id)od[id]=7;for(id=280;id<288;++id)od[id]=8;var ld=new jh(32);for(id=0;id<32;++id)ld[id]=5;var cd=sd(od,9,1),ud=sd(ld,5,1),hd=function(t){for(var e=t[0],n=1;n<t.length;++n)t[n]>e&&(e=t[n]);return e},dd=function(t,e,n){var r=e/8|0;return(t[r]|t[r+1]<<8)>>(7&e)&n},pd=function(t,e){var n=e/8|0;return(t[n]|t[n+1]<<8|t[n+2]<<16)>>(7&e)},fd=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],md=function(t,e,n){var r=new Error(e||fd[t]);if(r.code=t,Error.captureStackTrace&&Error.captureStackTrace(r,md),!n)throw r;return r},gd=function(t,e,n,r){var i=t.length,a=r?r.length:0;if(!i||e.f&&!e.l)return n||new jh(0);var s=!n,o=s||2!=e.i,l=e.i;s&&(n=new jh(3*i));var c,u=function(t){var e=n.length;if(t>e){var r=new jh(Math.max(2*e,t));r.set(n),n=r}},h=e.f||0,d=e.p||0,p=e.b||0,f=e.l,m=e.d,g=e.m,v=e.n,_=8*i;do{if(!f){h=dd(t,d,1);var y=dd(t,d+1,3);if(d+=3,!y){var x=t[(c=d,(I=4+((c+7)/8|0))-4)]|t[I-3]<<8,b=I+x;if(b>i){l&&md(0);break}o&&u(p+x),n.set(t.subarray(I,b),p),e.b=p+=x,e.p=d=8*b,e.f=h;continue}if(1==y)f=cd,m=ud,g=9,v=5;else if(2==y){var w=dd(t,d,31)+257,M=dd(t,d+10,15)+4,T=w+dd(t,d+5,31)+1;d+=14;for(var E=new jh(T),S=new jh(19),A=0;A<M;++A)S[Kh[A]]=dd(t,d+3*A,7);d+=3*M;var R=hd(S),C=(1<<R)-1,P=sd(S,R,1);for(A=0;A<T;){var I,L=P[dd(t,d,C)];if(d+=15&L,(I=L>>4)<16)E[A++]=I;else{var D=0,O=0;for(16==I?(O=3+dd(t,d,3),d+=2,D=E[A-1]):17==I?(O=3+dd(t,d,7),d+=3):18==I&&(O=11+dd(t,d,127),d+=7);O--;)E[A++]=D}}var N=E.subarray(0,w),U=E.subarray(w);g=hd(N),v=hd(U),f=sd(N,g,1),m=sd(U,v,1)}else md(1);if(d>_){l&&md(0);break}}o&&u(p+131072);for(var F=(1<<g)-1,B=(1<<v)-1,k=d;;k=d){var z=(D=f[pd(t,d)&F])>>4;if((d+=15&D)>_){l&&md(0);break}if(D||md(2),z<256)n[p++]=z;else{if(256==z){k=d,f=null;break}var H=z-254;if(z>264){var G=Yh[A=z-257];H=dd(t,d,(1<<G)-1)+Qh[A],d+=G}var V=m[pd(t,d)&B],W=V>>4;if(V||md(3),d+=15&V,U=nd[W],W>3&&(G=$h[W],U+=pd(t,d)&(1<<G)-1,d+=G),d>_){l&&md(0);break}o&&u(p+131072);var j=p+H;if(p<U){var q=a-U,X=Math.min(U,j);for(q+p<0&&md(3);p<X;++p)n[p]=r[q+p]}for(;p<j;++p)n[p]=n[p-U]}}e.l=f,e.p=k,e.b=p,e.f=h,f&&(h=1,e.m=g,e.d=m,e.n=v)}while(!h);return p!=n.length&&s?function(t,e,n){return(null==e||e<0)&&(e=0),(null==n||n>t.length)&&(n=t.length),new jh(t.subarray(e,n))}(n,0,p):n.subarray(0,p)},vd=new jh(0);function _d(t,e){return gd(t.subarray((n=t,r=e&&e.dictionary,(8!=(15&n[0])||n[0]>>4>7||(n[0]<<8|n[1])%31)&&md(6,"invalid zlib data"),(n[1]>>5&1)==+!r&&md(6,"invalid zlib data: "+(32&n[1]?"need":"unexpected")+" dictionary"),2+(n[1]>>3&4)),-4),{i:2},e&&e.out,e&&e.dictionary);var n,r}var yd="undefined"!=typeof TextDecoder&&new TextDecoder;try{yd.decode(vd,{stream:!0})}catch(t){}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;class xd extends Wl{constructor(t){super(t),this.type=et}parse(t){const e=65536,n=14,r=65537,i=Math.pow(2.7182818,2.2),a={l:0,c:0,lc:0};function s(t,e,n,r,i){for(;n<t;)e=e<<8|F(r,i),n+=8;n-=t,a.l=e>>n&(1<<t)-1,a.c=e,a.lc=n}const o=new Array(59);function l(t){return 63&t}function c(t){return t>>6}const u={c:0,lc:0};function h(t,e,n,r){t=t<<8|F(n,r),e+=8,u.c=t,u.lc=e}const d={c:0,lc:0};function p(t,e,n,r,i,a,s,o,l){if(t==e){r<8&&(h(n,r,i,a),n=u.c,r=u.lc);let t=n>>(r-=8);if(t=new Uint8Array([t])[0],o.value+t>l)return!1;const e=s[o.value-1];for(;t-- >0;)s[o.value++]=e}else{if(!(o.value<l))return!1;s[o.value++]=t}d.c=n,d.lc=r}function f(t){return 65535&t}function m(t){const e=f(t);return e>32767?e-65536:e}const g={a:0,b:0};function v(t,e){const n=m(t),r=m(e),i=n+(1&r)+(r>>1),a=i,s=i-r;g.a=a,g.b=s}function _(t,e){const n=f(t),r=f(e),i=n-(r>>1)&65535,a=r+i-32768&65535;g.a=a,g.b=i}function y(t,e,n,r,i,a,s){const o=s<16384,l=n>i?i:n;let c,u,h=1;for(;h<=l;)h<<=1;for(h>>=1,c=h,h>>=1;h>=1;){u=0;const s=u+a*(i-c),l=a*h,d=a*c,p=r*h,f=r*c;let m,y,x,b;for(;u<=s;u+=d){let i=u;const a=u+r*(n-c);for(;i<=a;i+=f){const n=i+p,r=i+l,a=r+p;o?(v(t[i+e],t[r+e]),m=g.a,x=g.b,v(t[n+e],t[a+e]),y=g.a,b=g.b,v(m,y),t[i+e]=g.a,t[n+e]=g.b,v(x,b),t[r+e]=g.a,t[a+e]=g.b):(_(t[i+e],t[r+e]),m=g.a,x=g.b,_(t[n+e],t[a+e]),y=g.a,b=g.b,_(m,y),t[i+e]=g.a,t[n+e]=g.b,_(x,b),t[r+e]=g.a,t[a+e]=g.b)}if(n&h){const n=i+l;o?v(t[i+e],t[n+e]):_(t[i+e],t[n+e]),m=g.a,t[n+e]=g.b,t[i+e]=m}}if(i&h){let i=u;const a=u+r*(n-c);for(;i<=a;i+=f){const n=i+p;o?v(t[i+e],t[n+e]):_(t[i+e],t[n+e]),m=g.a,t[n+e]=g.b,t[i+e]=m}}c=h,h>>=1}return u}function x(t,e,i,f,m,g){const v=i.value,_=U(e,i),y=U(e,i);i.value+=4;const x=U(e,i);if(i.value+=4,_<0||_>=r||y<0||y>=r)throw new Error("Something wrong with HUF_ENCSIZE");const b=new Array(r),w=new Array(16384);if(function(t){for(let e=0;e<16384;e++)t[e]={},t[e].len=0,t[e].lit=0,t[e].p=null}(w),function(t,e,n,i,l,c){const u=e;let h=0,d=0;for(;i<=l;i++){if(u.value-e.value>n)return!1;s(6,h,d,t,u);const r=a.l;if(h=a.c,d=a.lc,c[i]=r,63==r){if(u.value-e.value>n)throw new Error("Something wrong with hufUnpackEncTable");s(8,h,d,t,u);let r=a.l+6;if(h=a.c,d=a.lc,i+r>l+1)throw new Error("Something wrong with hufUnpackEncTable");for(;r--;)c[i++]=0;i--}else if(r>=59){let t=r-59+2;if(i+t>l+1)throw new Error("Something wrong with hufUnpackEncTable");for(;t--;)c[i++]=0;i--}}!function(t){for(let t=0;t<=58;++t)o[t]=0;for(let e=0;e<r;++e)o[t[e]]+=1;let e=0;for(let t=58;t>0;--t){const n=e+o[t]>>1;o[t]=e,e=n}for(let e=0;e<r;++e){const n=t[e];n>0&&(t[e]=n|o[n]++<<6)}}(c)}(t,i,f-(i.value-v),_,y,b),x>8*(f-(i.value-v)))throw new Error("Something wrong with hufUncompress");!function(t,e,r,i){for(;e<=r;e++){const r=c(t[e]),a=l(t[e]);if(r>>a)throw new Error("Invalid table entry");if(a>n){const t=i[r>>a-n];if(t.len)throw new Error("Invalid table entry");if(t.lit++,t.p){const e=t.p;t.p=new Array(t.lit);for(let n=0;n<t.lit-1;++n)t.p[n]=e[n]}else t.p=new Array(1);t.p[t.lit-1]=e}else if(a){let t=0;for(let s=1<<n-a;s>0;s--){const s=i[(r<<n-a)+t];if(s.len||s.p)throw new Error("Invalid table entry");s.len=a,s.lit=e,t++}}}}(b,_,y,w),function(t,e,r,i,a,s,o,f,m){let g=0,v=0;const _=o,y=Math.trunc(i.value+(a+7)/8);for(;i.value<y;)for(h(g,v,r,i),g=u.c,v=u.lc;v>=n;){const a=e[g>>v-n&16383];if(a.len)v-=a.len,p(a.lit,s,g,v,r,i,f,m,_),g=d.c,v=d.lc;else{if(!a.p)throw new Error("hufDecode issues");let e;for(e=0;e<a.lit;e++){const n=l(t[a.p[e]]);for(;v<n&&i.value<y;)h(g,v,r,i),g=u.c,v=u.lc;if(v>=n&&c(t[a.p[e]])==(g>>v-n&(1<<n)-1)){v-=n,p(a.p[e],s,g,v,r,i,f,m,_),g=d.c,v=d.lc;break}}if(e==a.lit)throw new Error("hufDecode issues")}}const x=8-a&7;for(g>>=x,v-=x;v>0;){const t=e[g<<n-v&16383];if(!t.len)throw new Error("hufDecode issues");v-=t.len,p(t.lit,s,g,v,r,i,f,m,_),g=d.c,v=d.lc}}(b,w,t,i,x,y,g,m,{value:0})}function b(t){for(let e=1;e<t.length;e++){const n=t[e-1]+t[e]-128;t[e]=n}}function w(t,e){let n=0,r=Math.floor((t.length+1)/2),i=0;const a=t.length-1;for(;!(i>a||(e[i++]=t[n++],i>a));)e[i++]=t[r++]}function M(t){let e=t.byteLength;const n=new Array;let r=0;const i=new DataView(t);for(;e>0;){const t=i.getInt8(r++);if(t<0){const a=-t;e-=a+1;for(let t=0;t<a;t++)n.push(i.getUint8(r++))}else{const a=t;e-=2;const s=i.getUint8(r++);for(let t=0;t<a+1;t++)n.push(s)}}return n}function T(t,e,n){let r,i=1;for(;i<64;)r=e[t.value],65280==r?i=64:r>>8==255?i+=255&r:(n[i]=r,i++),t.value++}function E(t){const e=.5*Math.cos(.7853975),n=.5*Math.cos(3.14159/16),r=.5*Math.cos(3.14159/8),i=.5*Math.cos(3*3.14159/16),a=.5*Math.cos(.981746875),s=.5*Math.cos(3*3.14159/8),o=.5*Math.cos(1.374445625),l=new Array(4),c=new Array(4),u=new Array(4),h=new Array(4);for(let d=0;d<8;++d){const p=8*d;l[0]=r*t[p+2],l[1]=s*t[p+2],l[2]=r*t[p+6],l[3]=s*t[p+6],c[0]=n*t[p+1]+i*t[p+3]+a*t[p+5]+o*t[p+7],c[1]=i*t[p+1]-o*t[p+3]-n*t[p+5]-a*t[p+7],c[2]=a*t[p+1]-n*t[p+3]+o*t[p+5]+i*t[p+7],c[3]=o*t[p+1]-a*t[p+3]+i*t[p+5]-n*t[p+7],u[0]=e*(t[p+0]+t[p+4]),u[3]=e*(t[p+0]-t[p+4]),u[1]=l[0]+l[3],u[2]=l[1]-l[2],h[0]=u[0]+u[1],h[1]=u[3]+u[2],h[2]=u[3]-u[2],h[3]=u[0]-u[1],t[p+0]=h[0]+c[0],t[p+1]=h[1]+c[1],t[p+2]=h[2]+c[2],t[p+3]=h[3]+c[3],t[p+4]=h[3]-c[3],t[p+5]=h[2]-c[2],t[p+6]=h[1]-c[1],t[p+7]=h[0]-c[0]}for(let d=0;d<8;++d)l[0]=r*t[16+d],l[1]=s*t[16+d],l[2]=r*t[48+d],l[3]=s*t[48+d],c[0]=n*t[8+d]+i*t[24+d]+a*t[40+d]+o*t[56+d],c[1]=i*t[8+d]-o*t[24+d]-n*t[40+d]-a*t[56+d],c[2]=a*t[8+d]-n*t[24+d]+o*t[40+d]+i*t[56+d],c[3]=o*t[8+d]-a*t[24+d]+i*t[40+d]-n*t[56+d],u[0]=e*(t[d]+t[32+d]),u[3]=e*(t[d]-t[32+d]),u[1]=l[0]+l[3],u[2]=l[1]-l[2],h[0]=u[0]+u[1],h[1]=u[3]+u[2],h[2]=u[3]-u[2],h[3]=u[0]-u[1],t[0+d]=h[0]+c[0],t[8+d]=h[1]+c[1],t[16+d]=h[2]+c[2],t[24+d]=h[3]+c[3],t[32+d]=h[3]-c[3],t[40+d]=h[2]-c[2],t[48+d]=h[1]-c[1],t[56+d]=h[0]-c[0]}function S(t){for(let e=0;e<64;++e){const n=t[0][e],r=t[1][e],i=t[2][e];t[0][e]=n+1.5747*i,t[1][e]=n-.1873*r-.4682*i,t[2][e]=n+1.8556*r}}function A(t,e,n){for(let a=0;a<64;++a)e[n+a]=Cr.toHalfFloat((r=t[a])<=1?Math.sign(r)*Math.pow(Math.abs(r),2.2):Math.sign(r)*Math.pow(i,Math.abs(r)-1));var r}function R(t){return new DataView(t.array.buffer,t.offset.value,t.size)}function C(t){const e=t.viewer.buffer.slice(t.offset.value,t.offset.value+t.size),n=new Uint8Array(M(e)),r=new Uint8Array(n.length);return b(n),w(n,r),new DataView(r.buffer)}function P(t){const e=_d(t.array.slice(t.offset.value,t.offset.value+t.size)),n=new Uint8Array(e.length);return b(e),w(e,n),new DataView(n.buffer)}function I(t){const n=t.viewer,r={value:t.offset.value},i=new Uint16Array(t.columns*t.lines*(t.inputChannels.length*t.type)),a=new Uint8Array(8192);let s=0;const o=new Array(t.inputChannels.length);for(let e=0,n=t.inputChannels.length;e<n;e++)o[e]={},o[e].start=s,o[e].end=o[e].start,o[e].nx=t.columns,o[e].ny=t.lines,o[e].size=t.type,s+=o[e].nx*o[e].ny*o[e].size;const l=V(n,r),c=V(n,r);if(c>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(l<=c)for(let t=0;t<c-l+1;t++)a[t+l]=B(n,r);const u=new Uint16Array(e),h=function(t,n){let r=0;for(let i=0;i<e;++i)(0==i||t[i>>3]&1<<(7&i))&&(n[r++]=i);const i=r-1;for(;r<e;)n[r++]=0;return i}(a,u),d=U(n,r);x(t.array,n,r,d,i,s);for(let e=0;e<t.inputChannels.length;++e){const t=o[e];for(let n=0;n<o[e].size;++n)y(i,t.start+n,t.nx,t.size,t.ny,t.nx*t.size,h)}!function(t,e,n){for(let r=0;r<n;++r)e[r]=t[e[r]]}(u,i,s);let p=0;const f=new Uint8Array(i.buffer.byteLength);for(let e=0;e<t.lines;e++)for(let e=0;e<t.inputChannels.length;e++){const t=o[e],n=t.nx*t.size,r=new Uint8Array(i.buffer,2*t.end,2*n);f.set(r,p),p+=2*n,t.end+=n}return new DataView(f.buffer)}function L(t){const e=_d(t.array.slice(t.offset.value,t.offset.value+t.size)),n=t.inputChannels.length*t.lines*t.columns*t.totalBytes,r=new ArrayBuffer(n),i=new DataView(r);let a=0,s=0;const o=new Array(4);for(let n=0;n<t.lines;n++)for(let n=0;n<t.inputChannels.length;n++){let r=0;switch(t.inputChannels[n].pixelType){case 1:o[0]=a,o[1]=o[0]+t.columns,a=o[1]+t.columns;for(let n=0;n<t.columns;++n)r+=e[o[0]++]<<8|e[o[1]++],i.setUint16(s,r,!0),s+=2;break;case 2:o[0]=a,o[1]=o[0]+t.columns,o[2]=o[1]+t.columns,a=o[2]+t.columns;for(let n=0;n<t.columns;++n)r+=e[o[0]++]<<24|e[o[1]++]<<16|e[o[2]++]<<8,i.setUint32(s,r,!0),s+=4}}return i}function D(t){const e=t.viewer,n={value:t.offset.value},r=new Uint8Array(t.columns*t.lines*(t.inputChannels.length*t.type*2)),i={version:k(e,n),unknownUncompressedSize:k(e,n),unknownCompressedSize:k(e,n),acCompressedSize:k(e,n),dcCompressedSize:k(e,n),rleCompressedSize:k(e,n),rleUncompressedSize:k(e,n),rleRawSize:k(e,n),totalAcUncompressedCount:k(e,n),totalDcUncompressedCount:k(e,n),acCompression:k(e,n)};if(i.version<2)throw new Error("EXRLoader.parse: "+J.compression+" version "+i.version+" is unsupported");const a=new Array;let s=V(e,n)-2;for(;s>0;){const t=O(e.buffer,n),r=B(e,n),i=r>>2&3,o=new Int8Array([(r>>4)-1])[0],l=B(e,n);a.push({name:t,index:o,type:l,compression:i}),s-=t.length+3}const o=J.channels,l=new Array(t.inputChannels.length);for(let e=0;e<t.inputChannels.length;++e){const n=l[e]={},r=o[e];n.name=r.name,n.compression=0,n.decoded=!1,n.type=r.pixelType,n.pLinear=r.pLinear,n.width=t.columns,n.height=t.lines}const c={idx:new Array(3)};for(let e=0;e<t.inputChannels.length;++e){const t=l[e];for(let n=0;n<a.length;++n){const r=a[n];t.name==r.name&&(t.compression=r.compression,r.index>=0&&(c.idx[r.index]=e),t.offset=e)}}let u,h,d;if(i.acCompressedSize>0)switch(i.acCompression){case 0:u=new Uint16Array(i.totalAcUncompressedCount),x(t.array,e,n,i.acCompressedSize,u,i.totalAcUncompressedCount);break;case 1:const r=_d(t.array.slice(n.value,n.value+i.totalAcUncompressedCount));u=new Uint16Array(r.buffer),n.value+=i.totalAcUncompressedCount}if(i.dcCompressedSize>0){const e={array:t.array,offset:n,size:i.dcCompressedSize};h=new Uint16Array(P(e).buffer),n.value+=i.dcCompressedSize}i.rleRawSize>0&&(d=M(_d(t.array.slice(n.value,n.value+i.rleCompressedSize)).buffer),n.value+=i.rleCompressedSize);let p=0;const f=new Array(l.length);for(let t=0;t<f.length;++t)f[t]=new Array;for(let e=0;e<t.lines;++e)for(let e=0;e<l.length;++e)f[e].push(p),p+=l[e].width*t.type*2;!function(t,e,n,r,i,a){let s=new DataView(a.buffer);const o=n[t.idx[0]].width,l=n[t.idx[0]].height,c=Math.floor(o/8),u=Math.ceil(o/8),h=Math.ceil(l/8),d=o-8*(u-1),p=l-8*(h-1),f={value:0},m=new Array(3),g=new Array(3),v=new Array(3),_=new Array(3),y=new Array(3);for(let n=0;n<3;++n)y[n]=e[t.idx[n]],m[n]=n<1?0:m[n-1]+u*h,g[n]=new Float32Array(64),v[n]=new Uint16Array(64),_[n]=new Uint16Array(64*u);for(let e=0;e<h;++e){let a=8;e==h-1&&(a=p);let o=8;for(let t=0;t<u;++t){t==u-1&&(o=d);for(let t=0;t<3;++t)v[t].fill(0),v[t][0]=i[m[t]++],T(f,r,v[t]),x=v[t],(b=g[t])[0]=G(x[0]),b[1]=G(x[1]),b[2]=G(x[5]),b[3]=G(x[6]),b[4]=G(x[14]),b[5]=G(x[15]),b[6]=G(x[27]),b[7]=G(x[28]),b[8]=G(x[2]),b[9]=G(x[4]),b[10]=G(x[7]),b[11]=G(x[13]),b[12]=G(x[16]),b[13]=G(x[26]),b[14]=G(x[29]),b[15]=G(x[42]),b[16]=G(x[3]),b[17]=G(x[8]),b[18]=G(x[12]),b[19]=G(x[17]),b[20]=G(x[25]),b[21]=G(x[30]),b[22]=G(x[41]),b[23]=G(x[43]),b[24]=G(x[9]),b[25]=G(x[11]),b[26]=G(x[18]),b[27]=G(x[24]),b[28]=G(x[31]),b[29]=G(x[40]),b[30]=G(x[44]),b[31]=G(x[53]),b[32]=G(x[10]),b[33]=G(x[19]),b[34]=G(x[23]),b[35]=G(x[32]),b[36]=G(x[39]),b[37]=G(x[45]),b[38]=G(x[52]),b[39]=G(x[54]),b[40]=G(x[20]),b[41]=G(x[22]),b[42]=G(x[33]),b[43]=G(x[38]),b[44]=G(x[46]),b[45]=G(x[51]),b[46]=G(x[55]),b[47]=G(x[60]),b[48]=G(x[21]),b[49]=G(x[34]),b[50]=G(x[37]),b[51]=G(x[47]),b[52]=G(x[50]),b[53]=G(x[56]),b[54]=G(x[59]),b[55]=G(x[61]),b[56]=G(x[35]),b[57]=G(x[36]),b[58]=G(x[48]),b[59]=G(x[49]),b[60]=G(x[57]),b[61]=G(x[58]),b[62]=G(x[62]),b[63]=G(x[63]),E(g[t]);S(g);for(let e=0;e<3;++e)A(g[e],_[e],64*t)}let l=0;for(let r=0;r<3;++r){const i=n[t.idx[r]].type;for(let t=8*e;t<8*e+a;++t){l=y[r][t];for(let e=0;e<c;++e){const n=64*e+8*(7&t);s.setUint16(l+0*i,_[r][n+0],!0),s.setUint16(l+2*i,_[r][n+1],!0),s.setUint16(l+4*i,_[r][n+2],!0),s.setUint16(l+6*i,_[r][n+3],!0),s.setUint16(l+8*i,_[r][n+4],!0),s.setUint16(l+10*i,_[r][n+5],!0),s.setUint16(l+12*i,_[r][n+6],!0),s.setUint16(l+14*i,_[r][n+7],!0),l+=16*i}}if(c!=u)for(let t=8*e;t<8*e+a;++t){const e=y[r][t]+8*c*2*i,n=64*c+8*(7&t);for(let t=0;t<o;++t)s.setUint16(e+2*t*i,_[r][n+t],!0)}}}var x,b;const w=new Uint16Array(o);s=new DataView(a.buffer);for(let e=0;e<3;++e){n[t.idx[e]].decoded=!0;const r=n[t.idx[e]].type;if(2==n[e].type)for(let t=0;t<l;++t){const n=y[e][t];for(let t=0;t<o;++t)w[t]=s.getUint16(n+2*t*r,!0);for(let t=0;t<o;++t)s.setFloat32(n+2*t*r,G(w[t]),!0)}}}(c,f,l,u,h,r);for(let e=0;e<l.length;++e){const n=l[e];if(!n.decoded){if(2!==n.compression)throw new Error("EXRLoader.parse: unsupported channel compression");{let i=0,a=0;for(let s=0;s<t.lines;++s){let t=f[e][i];for(let e=0;e<n.width;++e){for(let e=0;e<2*n.type;++e)r[t++]=d[a+e*n.width*n.height];a++}i++}}}}return new DataView(r.buffer)}function O(t,e){const n=new Uint8Array(t);let r=0;for(;0!=n[e.value+r];)r+=1;const i=(new TextDecoder).decode(n.slice(e.value,e.value+r));return e.value=e.value+r+1,i}function N(t,e){const n=t.getInt32(e.value,!0);return e.value=e.value+4,n}function U(t,e){const n=t.getUint32(e.value,!0);return e.value=e.value+4,n}function F(t,e){const n=t[e.value];return e.value=e.value+1,n}function B(t,e){const n=t.getUint8(e.value);return e.value=e.value+1,n}const k=function(t,e){let n;return n="getBigInt64"in DataView.prototype?Number(t.getBigInt64(e.value,!0)):t.getUint32(e.value+4,!0)+Number(t.getUint32(e.value,!0)<<32),e.value+=8,n};function z(t,e){const n=t.getFloat32(e.value,!0);return e.value+=4,n}function H(t,e){return Cr.toHalfFloat(z(t,e))}function G(t){const e=(31744&t)>>10,n=1023&t;return(t>>15?-1:1)*(e?31===e?n?NaN:1/0:Math.pow(2,e-15)*(1+n/1024):n/1024*6103515625e-14)}function V(t,e){const n=t.getUint16(e.value,!0);return e.value+=2,n}function W(t,e){return G(V(t,e))}function j(t,e,n,r,i){return"string"===r||"stringvector"===r||"iccProfile"===r?function(t,e,n){const r=(new TextDecoder).decode(new Uint8Array(t).slice(e.value,e.value+n));return e.value=e.value+n,r}(e,n,i):"chlist"===r?function(t,e,n,r){const i=n.value,a=[];for(;n.value<i+r-1;){const r=O(e,n),i=N(t,n),s=B(t,n);n.value+=3;const o=N(t,n),l=N(t,n);a.push({name:r,pixelType:i,pLinear:s,xSampling:o,ySampling:l})}return n.value+=1,a}(t,e,n,i):"chromaticities"===r?function(t,e){return{redX:z(t,e),redY:z(t,e),greenX:z(t,e),greenY:z(t,e),blueX:z(t,e),blueY:z(t,e),whiteX:z(t,e),whiteY:z(t,e)}}(t,n):"compression"===r?function(t,e){return["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"][B(t,e)]}(t,n):"box2i"===r?function(t,e){return{xMin:N(t,e),yMin:N(t,e),xMax:N(t,e),yMax:N(t,e)}}(t,n):"envmap"===r?function(t,e){return["ENVMAP_LATLONG","ENVMAP_CUBE"][B(t,e)]}(t,n):"tiledesc"===r?function(t,e){const n=U(t,e),r=U(t,e),i=B(t,e);return{xSize:n,ySize:r,levelMode:["ONE_LEVEL","MIPMAP_LEVELS","RIPMAP_LEVELS"][15&i],roundingMode:["ROUND_DOWN","ROUND_UP"][i>>4]}}(t,n):"lineOrder"===r?function(t,e){return["INCREASING_Y","DECREASING_Y","RANDOM_Y"][B(t,e)]}(t,n):"float"===r?z(t,n):"v2f"===r?function(t,e){return[z(t,e),z(t,e)]}(t,n):"v3f"===r?function(t,e){return[z(t,e),z(t,e),z(t,e)]}(t,n):"int"===r?N(t,n):"rational"===r?function(t,e){return[N(t,e),U(t,e)]}(t,n):"timecode"===r?function(t,e){return[U(t,e),U(t,e)]}(t,n):"preview"===r?(n.value+=i,"skipped"):void(n.value+=i)}function q(t,e,n,r){const i=new Array(t);for(let a=0;a<t;a++){const t=1<<a;let s=e/t|0;"ROUND_UP"==r&&s*t<e&&(s+=1);const o=Math.max(s,1);i[a]=(o+n-1)/n|0}return i}function X(){const t=this,e=t.offset,n={value:0};for(let r=0;r<t.tileCount;r++){const r=N(t.viewer,e),i=N(t.viewer,e);e.value+=8,t.size=U(t.viewer,e);const a=r*t.blockWidth,s=i*t.blockHeight;t.columns=a+t.blockWidth>t.width?t.width-a:t.blockWidth,t.lines=s+t.blockHeight>t.height?t.height-s:t.blockHeight;const o=t.columns*t.totalBytes,l=t.size<t.lines*o?t.uncompress(t):R(t);e.value+=t.size;for(let e=0;e<t.lines;e++){const r=e*t.columns*t.totalBytes;for(let i=0;i<t.inputChannels.length;i++){const o=J.channels[i].name,c=t.channelByteOffsets[o]*t.columns,u=t.decodeChannels[o];if(void 0===u)continue;n.value=r+c;const h=(t.height-(1+s+e))*t.outLineWidth;for(let e=0;e<t.columns;e++){const r=h+(e+a)*t.outputChannels+u;t.byteArray[r]=t.getter(l,n)}}}}}function Y(){const t=this,e=t.offset,n={value:0};for(let r=0;r<t.height/t.blockHeight;r++){const i=N(t.viewer,e)-J.dataWindow.yMin;t.size=U(t.viewer,e),t.lines=i+t.blockHeight>t.height?t.height-i:t.blockHeight;const a=t.columns*t.totalBytes,s=t.size<t.lines*a?t.uncompress(t):R(t);e.value+=t.size;for(let e=0;e<t.blockHeight;e++){const i=r*t.blockHeight,o=e+t.scanOrder(i);if(o>=t.height)continue;const l=e*a,c=(t.height-1-o)*t.outLineWidth;for(let e=0;e<t.inputChannels.length;e++){const r=J.channels[e].name,i=t.channelByteOffsets[r]*t.columns,a=t.decodeChannels[r];if(void 0!==a){n.value=l+i;for(let e=0;e<t.columns;e++){const r=c+e*t.outputChannels+a;t.byteArray[r]=t.getter(s,n)}}}}}}const $={value:0},K=new DataView(t),Z=new Uint8Array(t),J=function(t,e,n){const r={};if(20000630!=t.getUint32(0,!0))throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");r.version=t.getUint8(4);const i=t.getUint8(5);r.spec={singleTile:!!(2&i),longName:!!(4&i),deepFormat:!!(8&i),multiPart:!!(16&i)},n.value=8;let a=!0;for(;a;){const i=O(e,n);if(0==i)a=!1;else{const a=O(e,n),s=j(t,e,n,a,U(t,n));void 0===s?console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${a}'.`):r[i]=s}}if(-7&i)throw console.error("THREE.EXRHeader:",r),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return r}(K,t,$),Q=function(t,e,n,r,i){const a={size:0,viewer:e,array:n,offset:r,width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,inputChannels:t.channels,channelByteOffsets:{},scanOrder:null,totalBytes:null,columns:null,lines:null,type:null,uncompress:null,getter:null,format:null,colorSpace:$t};switch(t.compression){case"NO_COMPRESSION":a.blockHeight=1,a.uncompress=R;break;case"RLE_COMPRESSION":a.blockHeight=1,a.uncompress=C;break;case"ZIPS_COMPRESSION":a.blockHeight=1,a.uncompress=P;break;case"ZIP_COMPRESSION":a.blockHeight=16,a.uncompress=P;break;case"PIZ_COMPRESSION":a.blockHeight=32,a.uncompress=I;break;case"PXR24_COMPRESSION":a.blockHeight=16,a.uncompress=L;break;case"DWAA_COMPRESSION":a.blockHeight=32,a.uncompress=D;break;case"DWAB_COMPRESSION":a.blockHeight=256,a.uncompress=D;break;default:throw new Error("EXRLoader.parse: "+t.compression+" is unsupported")}const s={};for(const e of t.channels)switch(e.name){case"Y":case"R":case"G":case"B":case"A":s[e.name]=!0,a.type=e.pixelType}let o=!1;if(s.R&&s.G&&s.B)o=!s.A,a.outputChannels=4,a.decodeChannels={R:0,G:1,B:2,A:3};else{if(!s.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");a.outputChannels=1,a.decodeChannels={Y:0}}if(1==a.type)switch(i){case tt:a.getter=W;break;case et:a.getter=V}else{if(2!=a.type)throw new Error("EXRLoader.parse: unsupported pixelType "+a.type+" for "+t.compression+".");switch(i){case tt:a.getter=z;break;case et:a.getter=H}}a.columns=a.width;const l=a.width*a.height*a.outputChannels;switch(i){case tt:a.byteArray=new Float32Array(l),o&&a.byteArray.fill(1,0,l);break;case et:a.byteArray=new Uint16Array(l),o&&a.byteArray.fill(15360,0,l);break;default:console.error("THREE.EXRLoader: unsupported type: ",i)}let c=0;for(const e of t.channels)void 0!==a.decodeChannels[e.name]&&(a.channelByteOffsets[e.name]=c),c+=2*e.pixelType;if(a.totalBytes=c,a.outLineWidth=a.width*a.outputChannels,"INCREASING_Y"===t.lineOrder?a.scanOrder=t=>t:a.scanOrder=t=>a.height-1-t,4==a.outputChannels?(a.format=at,a.colorSpace=$t):(a.format=lt,a.colorSpace=Xt),t.spec.singleTile){a.blockHeight=t.tiles.ySize,a.blockWidth=t.tiles.xSize;const n=function(t,e,n){let r=0;switch(t.levelMode){case"ONE_LEVEL":r=1;break;case"MIPMAP_LEVELS":r=function(t,e){const n=Math.log2(t);return"ROUND_DOWN"==e?Math.floor(n):Math.ceil(n)}(Math.max(e,n),t.roundingMode)+1;break;case"RIPMAP_LEVELS":throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")}return r}(t.tiles,a.width,a.height),i=q(n,a.width,t.tiles.xSize,t.tiles.roundingMode),s=q(n,a.height,t.tiles.ySize,t.tiles.roundingMode);a.tileCount=i[0]*s[0];for(let t=0;t<n;t++)for(let n=0;n<s[t];n++)for(let n=0;n<i[t];n++)k(e,r);a.decode=X.bind(a)}else{a.blockWidth=a.width;const t=Math.ceil(a.height/a.blockHeight);for(let n=0;n<t;n++)k(e,r);a.decode=Y.bind(a)}return a}(J,K,Z,$,this.type);return Q.decode(),{header:J,width:Q.width,height:Q.height,data:Q.byteArray,format:Q.format,colorSpace:Q.colorSpace,type:this.type}}setDataType(t){return this.type=t,this}load(t,e,n,r){return super.load(t,(function(t,n){t.colorSpace=n.colorSpace,t.minFilter=j,t.magFilter=j,t.generateMipmaps=!1,t.flipY=!1,e&&e(t,n)}),n,r)}}class bd extends Wl{constructor(t){super(t),this.type=et}parse(t){const e=function(t,e){switch(t){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(e||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(e||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(e||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(e||""))}},n=function(t,e,n){e=e||1024;let r=t.pos,i=-1,a=0,s="",o=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));for(;0>(i=o.indexOf("\n"))&&a<e&&r<t.byteLength;)s+=o,a+=o.length,r+=128,o+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));return-1<i&&(!1!==n&&(t.pos+=a+i+1),s+o.slice(0,i))},r=function(t,e,n,r){const i=t[e+3],a=Math.pow(2,i-128)/255;n[r+0]=t[e+0]*a,n[r+1]=t[e+1]*a,n[r+2]=t[e+2]*a,n[r+3]=1},i=function(t,e,n,r){const i=t[e+3],a=Math.pow(2,i-128)/255;n[r+0]=Cr.toHalfFloat(Math.min(t[e+0]*a,65504)),n[r+1]=Cr.toHalfFloat(Math.min(t[e+1]*a,65504)),n[r+2]=Cr.toHalfFloat(Math.min(t[e+2]*a,65504)),n[r+3]=Cr.toHalfFloat(1)},a=new Uint8Array(t);a.pos=0;const s=function(t){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,s=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;for((t.pos>=t.byteLength||!(l=n(t)))&&e(1,"no header found"),(c=l.match(/^#\?(\S+)/))||e(3,"bad initial token"),o.valid|=1,o.programtype=c[1],o.string+=l+"\n";l=n(t),!1!==l;)if(o.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(r))&&(o.gamma=parseFloat(c[1])),(c=l.match(i))&&(o.exposure=parseFloat(c[1])),(c=l.match(a))&&(o.valid|=2,o.format=c[1]),(c=l.match(s))&&(o.valid|=4,o.height=parseInt(c[1],10),o.width=parseInt(c[2],10)),2&o.valid&&4&o.valid)break}else o.comments+=l+"\n";return 2&o.valid||e(3,"missing format specifier"),4&o.valid||e(3,"missing image size specifier"),o}(a),o=s.width,l=s.height,c=function(t,n,r){const i=n;if(i<8||i>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);i!==(t[2]<<8|t[3])&&e(3,"wrong scanline width");const a=new Uint8Array(4*n*r);a.length||e(4,"unable to allocate buffer space");let s=0,o=0;const l=4*i,c=new Uint8Array(4),u=new Uint8Array(l);let h=r;for(;h>0&&o<t.byteLength;){o+4>t.byteLength&&e(1),c[0]=t[o++],c[1]=t[o++],c[2]=t[o++],c[3]=t[o++],2==c[0]&&2==c[1]&&(c[2]<<8|c[3])==i||e(3,"bad rgbe scanline format");let n,r=0;for(;r<l&&o<t.byteLength;){n=t[o++];const i=n>128;if(i&&(n-=128),(0===n||r+n>l)&&e(3,"bad scanline data"),i){const e=t[o++];for(let t=0;t<n;t++)u[r++]=e}else u.set(t.subarray(o,o+n),r),r+=n,o+=n}const d=i;for(let t=0;t<d;t++){let e=0;a[s]=u[t+e],e+=i,a[s+1]=u[t+e],e+=i,a[s+2]=u[t+e],e+=i,a[s+3]=u[t+e],s+=4}h--}return a}(a.subarray(a.pos),o,l);let u,h,d;switch(this.type){case tt:d=c.length/4;const t=new Float32Array(4*d);for(let e=0;e<d;e++)r(c,4*e,t,4*e);u=t,h=tt;break;case et:d=c.length/4;const e=new Uint16Array(4*d);for(let t=0;t<d;t++)i(c,4*t,e,4*t);u=e,h=et;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:o,height:l,data:u,header:s.string,gamma:s.gamma,exposure:s.exposure,type:h}}setDataType(t){return this.type=t,this}load(t,e,n,r){return super.load(t,(function(t,n){switch(t.type){case tt:case et:t.colorSpace=$t,t.minFilter=j,t.magFilter=j,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,r)}}const wd=new WeakMap;class Md extends kl{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,e,n,r){const i=new Gl(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(t=>{this.parse(t,e,r)}),n,r)}parse(t,e,n=()=>{}){this.decodeDracoFile(t,e,null,null,Yt,n).catch(n)}decodeDracoFile(t,e,n,r,i=$t,a=()=>{}){const s={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!n,vertexColorSpace:i};return this.decodeGeometry(t,s).then(e).catch(a)}decodeGeometry(t,e){const n=JSON.stringify(e);if(wd.has(t)){const e=wd.get(t);if(e.key===n)return e.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let r;const i=this.workerNextTaskID++,a=t.byteLength,s=this._getWorker(i,a).then((n=>(r=n,new Promise(((n,a)=>{r._callbacks[i]={resolve:n,reject:a},r.postMessage({type:"decode",id:i,taskConfig:e,buffer:t},[t])}))))).then((t=>this._createGeometry(t.geometry)));return s.catch((()=>!0)).then((()=>{r&&i&&this._releaseTask(r,i)})),wd.set(t,{key:n,promise:s}),s}_createGeometry(t){const e=new Vr;t.index&&e.setIndex(new Lr(t.index.array,1));for(let n=0;n<t.attributes.length;n++){const r=t.attributes[n],i=r.name,a=r.array,s=r.itemSize,o=new Lr(a,s);"color"===i&&(this._assignVertexColorSpace(o,r.vertexColorSpace),o.normalized=a instanceof Float32Array==0),e.setAttribute(i,o)}return e}_assignVertexColorSpace(t,e){if(e!==Yt)return;const n=new wr;for(let e=0,r=t.count;e<r;e++)n.fromBufferAttribute(t,e),Ie.toWorkingColorSpace(n,Yt),t.setXYZ(e,n.r,n.g,n.b)}_loadLibrary(t,e){const n=new Gl(this.manager);return n.setPath(this.decoderPath),n.setResponseType(e),n.setWithCredentials(this.withCredentials),new Promise(((e,r)=>{n.load(t,e,void 0,r)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return t?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then((e=>{const n=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const r=Td.toString(),i=["/* draco decoder */",n,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([i]))})),this.decoderPending}_getWorker(t,e){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskCosts={},t._taskLoad=0,t.postMessage({type:"init",decoderConfig:this.decoderConfig}),t.onmessage=function(e){const n=e.data;switch(n.type){case"decode":t._callbacks[n.id].resolve(n);break;case"error":t._callbacks[n.id].reject(n);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort((function(t,e){return t._taskLoad>e._taskLoad?-1:1}));const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[t]=e,n._taskLoad+=e,n}))}_releaseTask(t,e){t._taskLoad-=t._taskCosts[e],delete t._callbacks[e],delete t._taskCosts[e]}debug(){console.log("Task load: ",this.workerPool.map((t=>t._taskLoad)))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}}function Td(){let t,e;function n(t,e,n,r,i,a){const s=a.num_components(),o=n.num_points()*s,l=o*i.BYTES_PER_ELEMENT,c=function(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}(t,i),u=t._malloc(l);e.GetAttributeDataArrayForAllPoints(n,a,c,l,u);const h=new i(t.HEAPF32.buffer,u,o).slice();return t._free(u),{name:r,array:h,itemSize:s}}onmessage=function(r){const i=r.data;switch(i.type){case"init":t=i.decoderConfig,e=new Promise((function(e){t.onModuleLoaded=function(t){e({draco:t})},DracoDecoderModule(t)}));break;case"decode":const r=i.buffer,a=i.taskConfig;e.then((t=>{const e=t.draco,s=new e.Decoder;try{const t=function(t,e,r,i){const a=i.attributeIDs,s=i.attributeTypes;let o,l;const c=e.GetEncodedGeometryType(r);if(c===t.TRIANGULAR_MESH)o=new t.Mesh,l=e.DecodeArrayToMesh(r,r.byteLength,o);else{if(c!==t.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");o=new t.PointCloud,l=e.DecodeArrayToPointCloud(r,r.byteLength,o)}if(!l.ok()||0===o.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const u={index:null,attributes:[]};for(const r in a){const l=self[s[r]];let c,h;if(i.useUniqueIDs)h=a[r],c=e.GetAttributeByUniqueId(o,h);else{if(h=e.GetAttributeId(o,t[a[r]]),-1===h)continue;c=e.GetAttribute(o,h)}const d=n(t,e,o,r,l,c);"color"===r&&(d.vertexColorSpace=i.vertexColorSpace),u.attributes.push(d)}return c===t.TRIANGULAR_MESH&&(u.index=function(t,e,n){const r=3*n.num_faces(),i=4*r,a=t._malloc(i);e.GetTrianglesUInt32Array(n,i,a);const s=new Uint32Array(t.HEAPF32.buffer,a,r).slice();return t._free(a),{array:s,itemSize:1}}(t,e,o)),t.destroy(o),u}(e,s,new Int8Array(r),a),o=t.attributes.map((t=>t.array.buffer));t.index&&o.push(t.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:t},o)}catch(t){console.error(t),self.postMessage({type:"error",id:i.id,error:t.message})}finally{e.destroy(s)}}))}}}var Ed=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function r(n){for(var r=0;r<e.children.length;r++)e.children[r].style.display=r===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),r(++t%e.children.length)}),!1);var i=(performance||Date).now(),a=i,s=0,o=n(new Ed.Panel("FPS","#0ff","#002")),l=n(new Ed.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=n(new Ed.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:e,addPanel:n,showPanel:r,begin:function(){i=(performance||Date).now()},end:function(){s++;var t=(performance||Date).now();if(l.update(t-i,200),t>=a+1e3&&(o.update(1e3*s/(t-a),100),a=t,s=0,c)){var e=performance.memory;c.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){i=this.end()},domElement:e,setMode:r}};Ed.Panel=function(t,e,n){var r=1/0,i=0,a=Math.round,s=a(window.devicePixelRatio||1),o=80*s,l=48*s,c=3*s,u=2*s,h=3*s,d=15*s,p=74*s,f=30*s,m=document.createElement("canvas");m.width=o,m.height=l,m.style.cssText="width:80px;height:48px";var g=m.getContext("2d");return g.font="bold "+9*s+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=n,g.fillRect(0,0,o,l),g.fillStyle=e,g.fillText(t,c,u),g.fillRect(h,d,p,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h,d,p,f),{dom:m,update:function(l,v){r=Math.min(r,l),i=Math.max(i,l),g.fillStyle=n,g.globalAlpha=1,g.fillRect(0,0,o,d),g.fillStyle=e,g.fillText(a(l)+" "+t+" ("+a(r)+"-"+a(i)+")",c,u),g.drawImage(m,h+s,d,p-s,f,h,d,p-s,f),g.fillRect(h+p-s,d,s,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h+p-s,d,s,a((1-l/v)*f))}}};const Sd=Ed,Ad=1.25,Rd=32,Cd=65535,Pd=Math.pow(2,-24),Id=Symbol("SKIP_GENERATION");function Ld(t){return t.index?t.index.count:t.attributes.position.count}function Dd(t){return Ld(t)/3}function Od(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}function Nd(t,e){if(!t.index){const n=t.attributes.position.count,r=Od(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new Lr(r,1));for(let t=0;t<n;t++)r[t]=t}}function Ud(t,e){const n=Dd(t),r=e||t.drawRange,i=r.start/3,a=(r.start+r.count)/3,s=Math.max(0,i),o=Math.min(n,a)-s;return[{offset:Math.floor(s),count:Math.floor(o)}]}function Fd(t,e){if(!t.groups||!t.groups.length)return Ud(t,e);const n=[],r=new Set,i=e||t.drawRange,a=i.start/3,s=(i.start+i.count)/3;for(const e of t.groups){const t=e.start/3,n=(e.start+e.count)/3;r.add(Math.max(a,t)),r.add(Math.min(s,n))}const o=Array.from(r.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const e=o[t],r=o[t+1];n.push({offset:Math.floor(e),count:Math.floor(r-e)})}return n}function Bd(t,e,n,r,i){let a=1/0,s=1/0,o=1/0,l=-1/0,c=-1/0,u=-1/0,h=1/0,d=1/0,p=1/0,f=-1/0,m=-1/0,g=-1/0;for(let r=6*e,i=6*(e+n);r<i;r+=6){const e=t[r+0],n=t[r+1],i=e-n,v=e+n;i<a&&(a=i),v>l&&(l=v),e<h&&(h=e),e>f&&(f=e);const _=t[r+2],y=t[r+3],x=_-y,b=_+y;x<s&&(s=x),b>c&&(c=b),_<d&&(d=_),_>m&&(m=_);const w=t[r+4],M=t[r+5],T=w-M,E=w+M;T<o&&(o=T),E>u&&(u=E),w<p&&(p=w),w>g&&(g=w)}r[0]=a,r[1]=s,r[2]=o,r[3]=l,r[4]=c,r[5]=u,i[0]=h,i[1]=d,i[2]=p,i[3]=f,i[4]=m,i[5]=g}function kd(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function zd(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const i=t[r+3]-t[r];i>n&&(n=i,e=r)}return e}function Hd(t,e){e.set(t)}function Gd(t,e,n){let r,i;for(let a=0;a<3;a++){const s=a+3;r=t[a],i=e[a],n[a]=r<i?r:i,r=t[s],i=e[s],n[s]=r>i?r:i}}function Vd(t,e,n){for(let r=0;r<3;r++){const i=e[t+2*r],a=e[t+2*r+1],s=i-a,o=i+a;s<n[r]&&(n[r]=s),o>n[r+3]&&(n[r+3]=o)}}function Wd(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const jd=(t,e)=>t.candidate-e.candidate,qd=new Array(32).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),Xd=new Float32Array(6);class Yd{constructor(){this.boundingData=new Float32Array(6)}}function $d(t,e,n,r,i,a){let s=r,o=r+i-1;const l=a.pos,c=2*a.axis;for(;;){for(;s<=o&&n[6*s+c]<l;)s++;for(;s<=o&&n[6*o+c]>=l;)o--;if(!(s<o))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*o+t],e[3*o+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*o+t],n[6*o+t]=e}s++,o--}}function Kd(t,e,n,r,i,a){let s=r,o=r+i-1;const l=a.pos,c=2*a.axis;for(;;){for(;s<=o&&n[6*s+c]<l;)s++;for(;s<=o&&n[6*o+c]>=l;)o--;if(!(s<o))return s;{let e=t[s];t[s]=t[o],t[o]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*o+t],n[6*o+t]=e}s++,o--}}}function Zd(t,e){return 65535===e[t+15]}function Jd(t,e){return e[t+6]}function Qd(t,e){return e[t+14]}function tp(t){return t+8}function ep(t,e){return e[t+6]}function np(t,e){return e[t+7]}let rp,ip,ap,sp;const op=Math.pow(2,32);function lp(t){return"count"in t?1:1+lp(t.left)+lp(t.right)}function cp(t,e,n){return rp=new Float32Array(n),ip=new Uint32Array(n),ap=new Uint16Array(n),sp=new Uint8Array(n),up(t,e)}function up(t,e){const n=t/4,r=t/2,i="count"in e,a=e.boundingData;for(let t=0;t<6;t++)rp[n+t]=a[t];if(i){if(e.buffer){const r=e.buffer;sp.set(new Uint8Array(r),t);for(let e=t,i=t+r.byteLength;e<i;e+=Rd)Zd(e/2,ap)||(ip[e/4+6]+=n);return t+r.byteLength}{const i=e.offset,a=e.count;return ip[n+6]=i,ap[r+14]=a,ap[r+15]=Cd,t+Rd}}{const r=e.left,i=e.right,a=e.splitAxis;let s;if(s=up(t+Rd,r),s/4>op)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return ip[n+6]=s/4,s=up(s,i),ip[n+7]=a,s}}function hp(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,i=r?4:2,a=e?new SharedArrayBuffer(n*i):new ArrayBuffer(n*i),s=r?new Uint32Array(a):new Uint16Array(a);for(let t=0,e=s.length;t<e;t++)s[t]=t;return s}(n,e.useSharedArrayBuffer),function(t,e){const n=Dd(t),r=Fd(t,e).sort(((t,e)=>t.offset-e.offset)),i=r[r.length-1];i.count=Math.min(n-i.offset,i.count);let a=0;return r.forEach((({count:t})=>a+=t)),n!==a}(n,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||Nd(n,e);const r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=function(t,e=null,n=null,r=null){const i=t.attributes.position,a=t.index?t.index.array:null,s=Dd(t),o=i.normalized;let l;null===e?(l=new Float32Array(6*s),n=0,r=s):(l=e,n=n||0,r=r||s);const c=i.array,u=i.offset||0;let h=3;i.isInterleavedBufferAttribute&&(h=i.data.stride);const d=["getX","getY","getZ"];for(let t=n;t<n+r;t++){const e=3*t,n=6*t;let r=e+0,s=e+1,p=e+2;a&&(r=a[r],s=a[s],p=a[p]),o||(r=r*h+u,s=s*h+u,p=p*h+u);for(let t=0;t<3;t++){let e,a,u;o?(e=i[d[t]](r),a=i[d[t]](s),u=i[d[t]](p)):(e=c[r+t],a=c[s+t],u=c[p+t]);let h=e;a<h&&(h=a),u<h&&(h=u);let f=e;a>f&&(f=a),u>f&&(f=u);const m=(f-h)/2,g=2*t;l[n+g+0]=h+m,l[n+g+1]=m+(Math.abs(h)+m)*Pd}}return l}(n),a=e.indirect?Ud(n,e.range):Fd(n,e.range);t._roots=a.map((n=>{const a=function(t,e,n,r,i){const{maxDepth:a,verbose:s,maxLeafTris:o,strategy:l,onProgress:c,indirect:u}=i,h=t._indirectBuffer,d=t.geometry,p=d.index?d.index.array:null,f=u?Kd:$d,m=Dd(d),g=new Float32Array(6);let v=!1;const _=new Yd;return Bd(e,n,r,_.boundingData,g),function t(n,r,i,c=null,u=0){if(!v&&u>=a&&(v=!0,s&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(d))),i<=o||u>=a)return y(r+i),n.offset=r,n.count=i,n;const m=function(t,e,n,r,i,a){let s=-1,o=0;if(0===a)s=zd(e),-1!==s&&(o=(e[s]+e[s+3])/2);else if(1===a)s=zd(t),-1!==s&&(o=function(t,e,n,r){let i=0;for(let a=e,s=e+n;a<s;a++)i+=t[6*a+2*r];return i/n}(n,r,i,s));else if(2===a){const a=Wd(t);let l=Ad*i;const c=6*r,u=6*(r+i);for(let t=0;t<3;t++){const r=e[t],h=(e[t+3]-r)/32;if(i<8){const e=[...qd];e.length=i;let r=0;for(let i=c;i<u;i+=6,r++){const a=e[r];a.candidate=n[i+2*t],a.count=0;const{bounds:s,leftCacheBounds:o,rightCacheBounds:l}=a;for(let t=0;t<3;t++)l[t]=1/0,l[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;Vd(i,n,s)}e.sort(jd);let h=i;for(let t=0;t<h;t++){const n=e[t];for(;t+1<h&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),h--}for(let r=c;r<u;r+=6){const i=n[r+2*t];for(let t=0;t<h;t++){const a=e[t];i>=a.candidate?Vd(r,n,a.rightCacheBounds):(Vd(r,n,a.leftCacheBounds),a.count++)}}for(let n=0;n<h;n++){const r=e[n],c=r.count,u=i-r.count,h=r.leftCacheBounds,d=r.rightCacheBounds;let p=0;0!==c&&(p=Wd(h)/a);let f=0;0!==u&&(f=Wd(d)/a);const m=1+Ad*(p*c+f*u);m<l&&(s=t,l=m,o=r.candidate)}}else{for(let t=0;t<32;t++){const e=qd[t];e.count=0,e.candidate=r+h+t*h;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=c;e<u;e+=6){let i=~~((n[e+2*t]-r)/h);i>=32&&(i=31);const a=qd[i];a.count++,Vd(e,n,a.bounds)}const e=qd[31];Hd(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=qd[t],n=qd[t+1];Gd(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let e=0;e<31;e++){const n=qd[e],r=n.count,c=n.bounds,u=qd[e+1].rightCacheBounds;0!==r&&(0===d?Hd(c,Xd):Gd(c,Xd,Xd)),d+=r;let h=0,p=0;0!==d&&(h=Wd(Xd)/a);const f=i-d;0!==f&&(p=Wd(u)/a);const m=1+Ad*(h*d+p*f);m<l&&(s=t,l=m,o=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:s,pos:o}}(n.boundingData,c,e,r,i,l);if(-1===m.axis)return y(r+i),n.offset=r,n.count=i,n;const _=f(h,p,e,r,i,m);if(_===r||_===r+i)y(r+i),n.offset=r,n.count=i;else{n.splitAxis=m.axis;const a=new Yd,s=r,o=_-r;n.left=a,Bd(e,s,o,a.boundingData,g),t(a,s,o,g,u+1);const l=new Yd,c=_,h=i-o;n.right=l,Bd(e,c,h,l.boundingData,g),t(l,c,h,g,u+1)}return n}(_,n,r,g),_;function y(t){c&&c(t/m)}}(t,i,n.offset,n.count,e),s=lp(a),o=new r(Rd*s);return cp(0,a,o),o}))}class dp{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let i=0,a=t.length;i<a;i++){const a=t[i][e];n=a<n?a:n,r=a>r?a:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let i=0,a=e.length;i<a;i++){const a=e[i],s=t.dot(a);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}dp.prototype.setFromBox=function(){const t=new Qe;return function(e,n){const r=n.min,i=n.max;let a=1/0,s=-1/0;for(let n=0;n<=1;n++)for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){t.x=r.x*n+i.x*(1-n),t.y=r.y*o+i.y*(1-o),t.z=r.z*l+i.z*(1-l);const c=e.dot(t);a=Math.min(c,a),s=Math.max(c,s)}this.min=a,this.max=s}}(),new dp;const pp=function(){const t=new Qe,e=new Qe,n=new Qe;return function(r,i,a){const s=r.start,o=t,l=i.start,c=e;n.subVectors(s,l),t.subVectors(r.end,r.start),e.subVectors(i.end,i.start);const u=n.dot(c),h=c.dot(o),d=c.dot(c),p=n.dot(o),f=o.dot(o)*d-h*h;let m,g;m=0!==f?(u*h-p*d)/f:0,g=(u+m*h)/d,a.x=m,a.y=g}}(),fp=function(){const t=new Me,e=new Qe,n=new Qe;return function(r,i,a,s){pp(r,i,t);let o=t.x,l=t.y;if(o>=0&&o<=1&&l>=0&&l<=1)return r.at(o,a),void i.at(l,s);if(o>=0&&o<=1)return l<0?i.at(0,s):i.at(1,s),void r.closestPointToPoint(s,!0,a);if(l>=0&&l<=1)return o<0?r.at(0,a):r.at(1,a),void i.closestPointToPoint(a,!0,s);{let t,c;t=o<0?r.start:r.end,c=l<0?i.start:i.end;const u=e,h=n;return r.closestPointToPoint(c,!0,e),i.closestPointToPoint(t,!0,n),u.distanceToSquared(c)<=h.distanceToSquared(t)?(a.copy(u),void s.copy(c)):(a.copy(t),void s.copy(h))}}}(),mp=function(){const t=new Qe,e=new Qe,n=new bi,r=new Mc;return function(i,a){const{radius:s,center:o}=i,{a:l,b:c,c:u}=a;if(r.start=l,r.end=c,r.closestPointToPoint(o,!0,t).distanceTo(o)<=s)return!0;if(r.start=l,r.end=u,r.closestPointToPoint(o,!0,t).distanceTo(o)<=s)return!0;if(r.start=c,r.end=u,r.closestPointToPoint(o,!0,t).distanceTo(o)<=s)return!0;const h=a.getPlane(n);if(Math.abs(h.distanceToPoint(o))<=s){const t=h.projectPoint(o,e);if(a.containsPoint(t))return!0}return!1}}();function gp(t){return Math.abs(t)<1e-15}class vp extends vr{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new Qe)),this.satBounds=new Array(4).fill().map((()=>new dp)),this.points=[this.a,this.b,this.c],this.sphere=new bn,this.plane=new bi,this.needsUpdate=!0}intersectsSphere(t){return mp(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,i=this.satAxes,a=this.satBounds,s=i[0],o=a[0];this.getNormal(s),o.setFromPoints(s,r);const l=i[1],c=a[1];l.subVectors(t,e),c.setFromPoints(l,r);const u=i[2],h=a[2];u.subVectors(e,n),h.setFromPoints(u,r);const d=i[3],p=a[3];d.subVectors(n,t),p.setFromPoints(d,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}vp.prototype.closestPointToSegment=function(){const t=new Qe,e=new Qe,n=new Mc;return function(r,i=null,a=null){const{start:s,end:o}=r,l=this.points;let c,u=1/0;for(let s=0;s<3;s++){const o=(s+1)%3;n.start.copy(l[s]),n.end.copy(l[o]),fp(n,r,t,e),c=t.distanceToSquared(e),c<u&&(u=c,i&&i.copy(t),a&&a.copy(e))}return this.closestPointToPoint(s,t),c=s.distanceToSquared(t),c<u&&(u=c,i&&i.copy(t),a&&a.copy(s)),this.closestPointToPoint(o,t),c=o.distanceToSquared(t),c<u&&(u=c,i&&i.copy(t),a&&a.copy(o)),Math.sqrt(u)}}(),vp.prototype.intersectsTriangle=function(){const t=new vp,e=new Array(3),n=new Array(3),r=new dp,i=new dp,a=new Qe,s=new Qe,o=new Qe,l=new Qe,c=new Qe,u=new Mc,h=new Mc,d=new Mc,p=new Qe;function f(t,e,n){const r=t.points;let i=0,a=-1;for(let t=0;t<3;t++){const{start:o,end:l}=u;o.copy(r[t]),l.copy(r[(t+1)%3]),u.delta(s);const c=gp(e.distanceToPoint(o));if(gp(e.normal.dot(s))&&c){n.copy(u),i=2;break}const h=e.intersectLine(u,p);if(!h&&c&&p.copy(o),(h||c)&&!gp(p.distanceTo(l))){if(i<=1)(1===i?n.start:n.end).copy(p),c&&(a=i);else if(i>=2){(1===a?n.start:n.end).copy(p),i=2;break}if(i++,2===i&&-1===a)break}}return i}return function(s,u=null,p=!1){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const m=this.plane,g=s.plane;if(Math.abs(m.normal.dot(g.normal))>1-1e-10){const t=this.satBounds,o=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let e=0;e<4;e++){const i=t[e],a=o[e];if(r.setFromPoints(a,n),i.isSeparated(r))return!1}const l=s.satBounds,c=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=l[t],i=c[t];if(r.setFromPoints(i,e),n.isSeparated(r))return!1}for(let t=0;t<4;t++){const s=o[t];for(let t=0;t<4;t++){const o=c[t];if(a.crossVectors(s,o),r.setFromPoints(a,e),i.setFromPoints(a,n),r.isSeparated(i))return!1}}return u&&(p||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),u.start.set(0,0,0),u.end.set(0,0,0)),!0}{const t=f(this,g,h);if(1===t&&s.containsPoint(h.end))return u&&(u.start.copy(h.end),u.end.copy(h.end)),!0;if(2!==t)return!1;const e=f(s,m,d);if(1===e&&this.containsPoint(d.end))return u&&(u.start.copy(d.end),u.end.copy(d.end)),!0;if(2!==e)return!1;if(h.delta(o),d.delta(l),o.dot(l)<0){let t=d.start;d.start=d.end,d.end=t}const n=h.start.dot(o),r=h.end.dot(o),i=d.start.dot(o),a=d.end.dot(o);return(n===a||i===r||r<i!=n<a)&&(u&&(c.subVectors(h.start,d.start),c.dot(o)>0?u.start.copy(h.start):u.start.copy(d.start),c.subVectors(h.end,d.end),c.dot(o)<0?u.end.copy(h.end):u.end.copy(d.end)),!0)}}}(),vp.prototype.distanceToPoint=function(){const t=new Qe;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),vp.prototype.distanceToTriangle=function(){const t=new Qe,e=new Qe,n=["a","b","c"],r=new Mc,i=new Mc;return function(a,s=null,o=null){const l=s||o?r:null;if(this.intersectsTriangle(a,l))return(s||o)&&(s&&l.getCenter(s),o&&l.getCenter(o)),0;let c=1/0;for(let e=0;e<3;e++){let r;const i=n[e],l=a[i];this.closestPointToPoint(l,t),r=l.distanceToSquared(t),r<c&&(c=r,s&&s.copy(t),o&&o.copy(l));const u=this[i];a.closestPointToPoint(u,t),r=u.distanceToSquared(t),r<c&&(c=r,s&&s.copy(u),o&&o.copy(t))}for(let l=0;l<3;l++){const u=n[l],h=n[(l+1)%3];r.set(this[u],this[h]);for(let l=0;l<3;l++){const u=n[l],h=n[(l+1)%3];i.set(a[u],a[h]),fp(r,i,t,e);const d=t.distanceToSquared(e);d<c&&(c=d,s&&s.copy(t),o&&o.copy(e))}}return Math.sqrt(c)}}();class _p{constructor(t,e,n){this.isOrientedBox=!0,this.min=new Qe,this.max=new Qe,this.matrix=new Pn,this.invMatrix=new Pn,this.points=new Array(8).fill().map((()=>new Qe)),this.satAxes=new Array(3).fill().map((()=>new Qe)),this.satBounds=new Array(3).fill().map((()=>new dp)),this.alignedSatBounds=new Array(3).fill().map((()=>new dp)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}_p.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let i=0;i<=1;i++)for(let a=0;a<=1;a++)for(let s=0;s<=1;s++){const o=r[1*i|2*a|4*s];o.x=i?n.x:e.x,o.y=a?n.y:e.y,o.z=s?n.z:e.z,o.applyMatrix4(t)}const i=this.satBounds,a=this.satAxes,s=r[0];for(let t=0;t<3;t++){const e=a[t],n=i[t],o=r[1<<t];e.subVectors(s,o),n.setFromPoints(e,r)}const o=this.alignedSatBounds;o[0].setFromPointsField(r,"x"),o[1].setFromPointsField(r,"y"),o[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},_p.prototype.intersectsBox=function(){const t=new dp;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,i=this.satBounds,a=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const r=a[n],s=i[n];if(t.setFromBox(r,e),s.isSeparated(t))return!1}return!0}}(),_p.prototype.intersectsTriangle=function(){const t=new vp,e=new Array(3),n=new dp,r=new dp,i=new Qe;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(t.copy(a),t.update(),a=t);const s=this.satBounds,o=this.satAxes;e[0]=a.a,e[1]=a.b,e[2]=a.c;for(let t=0;t<3;t++){const r=s[t],i=o[t];if(n.setFromPoints(i,e),r.isSeparated(n))return!1}const l=a.satBounds,c=a.satAxes,u=this.points;for(let t=0;t<3;t++){const e=l[t],r=c[t];if(n.setFromPoints(r,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const a=o[t];for(let t=0;t<4;t++){const s=c[t];if(i.crossVectors(a,s),n.setFromPoints(i,e),r.setFromPoints(i,u),n.isSeparated(r))return!1}}return!0}}(),_p.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},_p.prototype.distanceToPoint=function(){const t=new Qe;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),_p.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new Mc)),n=new Array(12).fill().map((()=>new Mc)),r=new Qe,i=new Qe;return function(a,s=0,o=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(o||l)&&(a.getCenter(i),this.closestPointToPoint(i,r),a.closestPointToPoint(r,i),o&&o.copy(r),l&&l.copy(i)),0;const c=s*s,u=a.min,h=a.max,d=this.points;let p=1/0;for(let t=0;t<8;t++){const e=d[t];i.copy(e).clamp(u,h);const n=e.distanceToSquared(i);if(n<p&&(p=n,o&&o.copy(e),l&&l.copy(i),n<c))return Math.sqrt(n)}let f=0;for(let r=0;r<3;r++)for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const s=(r+1)%3,o=(r+2)%3,l=1<<r|i<<s|a<<o,c=d[i<<s|a<<o],p=d[l];e[f].set(c,p);const m=t[r],g=t[s],v=t[o],_=n[f],y=_.start,x=_.end;y[m]=u[m],y[g]=i?u[g]:h[g],y[v]=a?u[v]:h[g],x[m]=h[m],x[g]=i?u[g]:h[g],x[v]=a?u[v]:h[g],f++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?h.x:u.x,i.y=e?h.y:u.y,i.z=n?h.z:u.z,this.closestPointToPoint(i,r);const a=i.distanceToSquared(r);if(a<p&&(p=a,o&&o.copy(r),l&&l.copy(i),a<c))return Math.sqrt(a)}for(let t=0;t<12;t++){const a=e[t];for(let t=0;t<12;t++){const e=n[t];fp(a,e,r,i);const s=r.distanceToSquared(i);if(s<p&&(p=s,o&&o.copy(r),l&&l.copy(i),s<c))return Math.sqrt(s)}}return Math.sqrt(p)}}();class yp{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class xp extends yp{constructor(){super((()=>new vp))}}const bp=new xp,wp=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let Mp,Tp;const Ep=[],Sp=new yp((()=>new nn));function Ap(t,e,n,r,i,a){Mp=Sp.getPrimitive(),Tp=Sp.getPrimitive(),Ep.push(Mp,Tp),wp.setBuffer(t._roots[e]);const s=Rp(0,t.geometry,n,r,i,a);wp.clearBuffer(),Sp.releasePrimitive(Mp),Sp.releasePrimitive(Tp),Ep.pop(),Ep.pop();const o=Ep.length;return o>0&&(Tp=Ep[o-1],Mp=Ep[o-2]),s}function Rp(t,e,n,r,i=null,a=0,s=0){const{float32Array:o,uint16Array:l,uint32Array:c}=wp;let u=2*t;if(Zd(u,l)){const h=Jd(t,c),d=Qd(u,l);return kd(t,o,Mp),r(h,d,!1,s,a+t,Mp)}{const p=tp(t),f=ep(t,c);let m,g,v,_,y=p,x=f;if(i&&(v=Mp,_=Tp,kd(y,o,v),kd(x,o,_),m=i(v),g=i(_),g<m)){y=f,x=p;const A=m;m=g,g=A,v=_}v||(v=Mp,kd(y,o,v));const b=n(v,Zd(2*y,l),m,s+1,a+y);let w;if(2===b){const R=E(y);w=r(R,S(y)-R,!0,s+1,a+y,v)}else w=b&&Rp(y,e,n,r,i,a,s+1);if(w)return!0;_=Tp,kd(x,o,_);const M=n(_,Zd(2*x,l),g,s+1,a+x);let T;if(2===M){const C=E(x);T=r(C,S(x)-C,!0,s+1,a+x,_)}else T=M&&Rp(x,e,n,r,i,a,s+1);return!!T;function E(t){const{uint16Array:e,uint32Array:n}=wp;let r=2*t;for(;!Zd(r,e);)r=2*(t=tp(t));return Jd(t,n)}function S(t){const{uint16Array:e,uint32Array:n}=wp;let r=2*t;for(;!Zd(r,e);)r=2*(t=ep(t,n));return Jd(t,n)+Qd(r,e)}}}const Cp=new Qe,Pp=new Qe,Ip=parseInt(i)>=169,Lp=new Qe,Dp=new Qe,Op=new Qe,Np=new Me,Up=new Me,Fp=new Me,Bp=new Qe,kp=new Qe,zp=new Qe,Hp=new Qe;function Gp(t,e,n,r,i,a,s){const o=3*r;let l=o+0,c=o+1,u=o+2;const h=t.index;t.index&&(l=h.getX(l),c=h.getX(c),u=h.getX(u));const{position:d,normal:p,uv:f,uv1:m}=t.attributes,g=function(t,e,n,r,i,a,s,o,l,c,u){Lp.fromBufferAttribute(e,a),Dp.fromBufferAttribute(e,s),Op.fromBufferAttribute(e,o);const h=function(t,e,n,r,i,a,s,o){let l;if(l=1===a?t.intersectTriangle(r,n,e,!0,i):t.intersectTriangle(e,n,r,2!==a,i),null===l)return null;const c=t.origin.distanceTo(i);return c<s||c>o?null:{distance:c,point:i.clone()}}(t,Lp,Dp,Op,Hp,l,c,u);if(h){const e=new Qe;vr.getBarycoord(Hp,Lp,Dp,Op,e),r&&(Np.fromBufferAttribute(r,a),Up.fromBufferAttribute(r,s),Fp.fromBufferAttribute(r,o),h.uv=vr.getInterpolation(Hp,Lp,Dp,Op,Np,Up,Fp,new Me)),i&&(Np.fromBufferAttribute(i,a),Up.fromBufferAttribute(i,s),Fp.fromBufferAttribute(i,o),h.uv1=vr.getInterpolation(Hp,Lp,Dp,Op,Np,Up,Fp,new Me)),n&&(Bp.fromBufferAttribute(n,a),kp.fromBufferAttribute(n,s),zp.fromBufferAttribute(n,o),h.normal=vr.getInterpolation(Hp,Lp,Dp,Op,Bp,kp,zp,new Qe),h.normal.dot(t.direction)>0&&h.normal.multiplyScalar(-1));const l={a,b:s,c:o,normal:new Qe,materialIndex:0};vr.getNormal(Lp,Dp,Op,l.normal),h.face=l,h.faceIndex=a,Ip&&(h.barycoord=e)}return h}(n,d,p,f,m,l,c,u,e,a,s);return g?(g.faceIndex=r,i&&i.push(g),g):null}function Vp(t,e,n,r){const i=t.a,a=t.b,s=t.c;let o=e,l=e+1,c=e+2;n&&(o=n.getX(o),l=n.getX(l),c=n.getX(c)),i.x=r.getX(o),i.y=r.getY(o),i.z=r.getZ(o),a.x=r.getX(l),a.y=r.getY(l),a.z=r.getZ(l),s.x=r.getX(c),s.y=r.getY(c),s.z=r.getZ(c)}function Wp(t,e,n,r,i,a,s){const{geometry:o}=n,{index:l}=o,c=o.attributes.position;for(let n=t,o=e+t;n<o;n++){let t;if(t=n,Vp(s,3*t,l,c),s.needsUpdate=!0,r(s,t,i,a))return!0}return!1}function jp(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,i=n.attributes.position;let a,s,o,l,c=0;const u=t._roots;for(let t=0,e=u.length;t<e;t++)a=u[t],s=new Uint32Array(a),o=new Uint16Array(a),l=new Float32Array(a),h(0,c),c+=a.byteLength;function h(t,n,a=!1){const c=2*t;if(o[c+15]===Cd){const e=s[t+6];let n=1/0,a=1/0,u=1/0,h=-1/0,d=-1/0,p=-1/0;for(let t=3*e,s=3*(e+o[c+14]);t<s;t++){let e=r[t];const s=i.getX(e),o=i.getY(e),l=i.getZ(e);s<n&&(n=s),s>h&&(h=s),o<a&&(a=o),o>d&&(d=o),l<u&&(u=l),l>p&&(p=l)}return(l[t+0]!==n||l[t+1]!==a||l[t+2]!==u||l[t+3]!==h||l[t+4]!==d||l[t+5]!==p)&&(l[t+0]=n,l[t+1]=a,l[t+2]=u,l[t+3]=h,l[t+4]=d,l[t+5]=p,!0)}{const r=t+8,i=s[t+6],o=r+n,c=i+n;let u=a,d=!1,p=!1;e?u||(d=e.has(o),p=e.has(c),u=!d&&!p):(d=!0,p=!0);const f=u||p;let m=!1;(u||d)&&(m=h(r,n,u));let g=!1;f&&(g=h(i,n,u));const v=m||g;if(v)for(let e=0;e<3;e++){const n=r+e,a=i+e,s=l[n],o=l[n+3],c=l[a],u=l[a+3];l[t+e]=s<c?s:c,l[t+e+3]=o>u?o:u}return v}}}function qp(t,e,n,r,i){let a,s,o,l,c,u;const h=1/n.direction.x,d=1/n.direction.y,p=1/n.direction.z,f=n.origin.x,m=n.origin.y,g=n.origin.z;let v=e[t],_=e[t+3],y=e[t+1],x=e[t+3+1],b=e[t+2],w=e[t+3+2];return h>=0?(a=(v-f)*h,s=(_-f)*h):(a=(_-f)*h,s=(v-f)*h),d>=0?(o=(y-m)*d,l=(x-m)*d):(o=(x-m)*d,l=(y-m)*d),!(a>l||o>s)&&((o>a||isNaN(a))&&(a=o),(l<s||isNaN(s))&&(s=l),p>=0?(c=(b-g)*p,u=(w-g)*p):(c=(w-g)*p,u=(b-g)*p),!(a>u||c>s)&&((c>a||a!=a)&&(a=c),(u<s||s!=s)&&(s=u),a<=i&&s>=r))}function Xp(t,e,n,r,i,a,s){wp.setBuffer(t._roots[e]),Yp(0,t,n,r,i,a,s),wp.clearBuffer()}function Yp(t,e,n,r,i,a,s){const{float32Array:o,uint16Array:l,uint32Array:c}=wp,u=2*t;if(Zd(u,l))!function(t,e,n,r,i,a,s,o){const{geometry:l,_indirectBuffer:c}=t;for(let t=r,c=r+i;t<c;t++)Gp(l,e,n,t,a,s,o)}(e,n,r,Jd(t,c),Qd(u,l),i,a,s);else{const l=tp(t);qp(l,o,r,a,s)&&Yp(l,e,n,r,i,a,s);const u=ep(t,c);qp(u,o,r,a,s)&&Yp(u,e,n,r,i,a,s)}}const $p=["x","y","z"];function Kp(t,e,n,r,i,a){wp.setBuffer(t._roots[e]);const s=Zp(0,t,n,r,i,a);return wp.clearBuffer(),s}function Zp(t,e,n,r,i,a){const{float32Array:s,uint16Array:o,uint32Array:l}=wp;let c=2*t;if(Zd(c,o))return function(t,e,n,r,i,a,s){const{geometry:o,_indirectBuffer:l}=t;let c=1/0,u=null;for(let t=r,l=r+i;t<l;t++){let r;r=Gp(o,e,n,t,null,a,s),r&&r.distance<c&&(u=r,c=r.distance)}return u}(e,n,r,Jd(t,l),Qd(c,o),i,a);{const o=np(t,l),c=$p[o],u=r.direction[c]>=0;let h,d;u?(h=tp(t),d=ep(t,l)):(h=ep(t,l),d=tp(t));const p=qp(h,s,r,i,a)?Zp(h,e,n,r,i,a):null;if(p){const t=p.point[c];if(u?t<=s[d+o]:t>=s[d+o+3])return p}const f=qp(d,s,r,i,a)?Zp(d,e,n,r,i,a):null;return p&&f?p.distance<=f.distance?p:f:p||f||null}}const Jp=new nn,Qp=new vp,tf=new vp,ef=new Pn,nf=new _p,rf=new _p;function af(t,e,n,r){wp.setBuffer(t._roots[e]);const i=sf(0,t,n,r);return wp.clearBuffer(),i}function sf(t,e,n,r,i=null){const{float32Array:a,uint16Array:s,uint32Array:o}=wp;let l=2*t;if(null===i&&(n.boundingBox||n.computeBoundingBox(),nf.set(n.boundingBox.min,n.boundingBox.max,r),i=nf),!Zd(l,s)){const s=t+8,l=o[t+6];return kd(s,a,Jp),i.intersectsBox(Jp)&&sf(s,e,n,r,i)?!0:(kd(l,a,Jp),!(!i.intersectsBox(Jp)||!sf(l,e,n,r,i)))}{const i=e.geometry,c=i.index,u=i.attributes.position,h=n.index,d=n.attributes.position,p=Jd(t,o),f=Qd(l,s);if(ef.copy(r).invert(),n.boundsTree){kd(t,a,rf),rf.matrix.copy(ef),rf.needsUpdate=!0;const e=n.boundsTree.shapecast({intersectsBounds:t=>rf.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*p,n=3*(f+p);e<n;e+=3)if(Vp(tf,e,c,u),tf.needsUpdate=!0,t.intersectsTriangle(tf))return!0;return!1}});return e}for(let t=3*p,e=3*(f+p);t<e;t+=3){Vp(Qp,t,c,u),Qp.a.applyMatrix4(ef),Qp.b.applyMatrix4(ef),Qp.c.applyMatrix4(ef),Qp.needsUpdate=!0;for(let t=0,e=h.count;t<e;t+=3)if(Vp(tf,t,h,d),tf.needsUpdate=!0,Qp.intersectsTriangle(tf))return!0}}}const of=new Pn,lf=new _p,cf=new _p,uf=new Qe,hf=new Qe,df=new Qe,pf=new Qe;function ff(t,e,n,r={},i={},a=0,s=1/0){e.boundingBox||e.computeBoundingBox(),lf.set(e.boundingBox.min,e.boundingBox.max,n),lf.needsUpdate=!0;const o=t.geometry,l=o.attributes.position,c=o.index,u=e.attributes.position,h=e.index,d=bp.getPrimitive(),p=bp.getPrimitive();let f=uf,m=hf,g=null,v=null;i&&(g=df,v=pf);let _=1/0,y=null,x=null;return of.copy(n).invert(),cf.matrix.copy(of),t.shapecast({boundsTraverseOrder:t=>lf.distanceToBox(t),intersectsBounds:(t,e,n)=>n<_&&n<s&&(e&&(cf.min.copy(t.min),cf.max.copy(t.max),cf.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:t=>cf.distanceToBox(t),intersectsBounds:(t,e,n)=>n<_&&n<s,intersectsRange:(e,i)=>{for(let s=e,o=e+i;s<o;s++){Vp(p,3*s,h,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Vp(d,3*e,c,l),d.needsUpdate=!0;const t=d.distanceToTriangle(p,f,g);if(t<_&&(m.copy(f),v&&v.copy(g),_=t,y=e,x=s),t<a)return!0}}}});for(let i=0,s=Dd(e);i<s;i++){Vp(p,3*i,h,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Vp(d,3*e,c,l),d.needsUpdate=!0;const t=d.distanceToTriangle(p,f,g);if(t<_&&(m.copy(f),v&&v.copy(g),_=t,y=e,x=i),t<a)return!0}}}}),bp.releasePrimitive(d),bp.releasePrimitive(p),_===1/0?null:(r.point?r.point.copy(m):r.point=m.clone(),r.distance=_,r.faceIndex=y,i&&(i.point?i.point.copy(v):i.point=v.clone(),i.point.applyMatrix4(of),m.applyMatrix4(of),i.distance=m.sub(i.point).length(),i.faceIndex=x),r)}function mf(t,e,n,r,i,a,s){const{geometry:o}=n,{index:l}=o,c=o.attributes.position;for(let o=t,u=e+t;o<u;o++){let t;if(t=n.resolveTriangleIndex(o),Vp(s,3*t,l,c),s.needsUpdate=!0,r(s,t,i,a))return!0}return!1}function gf(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,i=n.attributes.position;let a,s,o,l,c=0;const u=t._roots;for(let t=0,e=u.length;t<e;t++)a=u[t],s=new Uint32Array(a),o=new Uint16Array(a),l=new Float32Array(a),h(0,c),c+=a.byteLength;function h(n,a,c=!1){const u=2*n;if(o[u+15]===Cd){const e=s[n+6];let a=1/0,c=1/0,h=1/0,d=-1/0,p=-1/0,f=-1/0;for(let n=e,s=e+o[u+14];n<s;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const s=i.getX(n),o=i.getY(n),l=i.getZ(n);s<a&&(a=s),s>d&&(d=s),o<c&&(c=o),o>p&&(p=o),l<h&&(h=l),l>f&&(f=l)}}return(l[n+0]!==a||l[n+1]!==c||l[n+2]!==h||l[n+3]!==d||l[n+4]!==p||l[n+5]!==f)&&(l[n+0]=a,l[n+1]=c,l[n+2]=h,l[n+3]=d,l[n+4]=p,l[n+5]=f,!0)}{const t=n+8,r=s[n+6],i=t+a,o=r+a;let u=c,d=!1,p=!1;e?u||(d=e.has(i),p=e.has(o),u=!d&&!p):(d=!0,p=!0);const f=u||p;let m=!1;(u||d)&&(m=h(t,a,u));let g=!1;f&&(g=h(r,a,u));const v=m||g;if(v)for(let e=0;e<3;e++){const i=t+e,a=r+e,s=l[i],o=l[i+3],c=l[a],u=l[a+3];l[n+e]=s<c?s:c,l[n+e+3]=o>u?o:u}return v}}}function vf(t,e,n,r,i,a,s){wp.setBuffer(t._roots[e]),_f(0,t,n,r,i,a,s),wp.clearBuffer()}function _f(t,e,n,r,i,a,s){const{float32Array:o,uint16Array:l,uint32Array:c}=wp,u=2*t;if(Zd(u,l))!function(t,e,n,r,i,a,s,o){const{geometry:l,_indirectBuffer:c}=t;for(let t=r,u=r+i;t<u;t++)Gp(l,e,n,c?c[t]:t,a,s,o)}(e,n,r,Jd(t,c),Qd(u,l),i,a,s);else{const l=tp(t);qp(l,o,r,a,s)&&_f(l,e,n,r,i,a,s);const u=ep(t,c);qp(u,o,r,a,s)&&_f(u,e,n,r,i,a,s)}}const yf=["x","y","z"];function xf(t,e,n,r,i,a){wp.setBuffer(t._roots[e]);const s=bf(0,t,n,r,i,a);return wp.clearBuffer(),s}function bf(t,e,n,r,i,a){const{float32Array:s,uint16Array:o,uint32Array:l}=wp;let c=2*t;if(Zd(c,o))return function(t,e,n,r,i,a,s){const{geometry:o,_indirectBuffer:l}=t;let c=1/0,u=null;for(let t=r,h=r+i;t<h;t++){let r;r=Gp(o,e,n,l?l[t]:t,null,a,s),r&&r.distance<c&&(u=r,c=r.distance)}return u}(e,n,r,Jd(t,l),Qd(c,o),i,a);{const o=np(t,l),c=yf[o],u=r.direction[c]>=0;let h,d;u?(h=tp(t),d=ep(t,l)):(h=ep(t,l),d=tp(t));const p=qp(h,s,r,i,a)?bf(h,e,n,r,i,a):null;if(p){const t=p.point[c];if(u?t<=s[d+o]:t>=s[d+o+3])return p}const f=qp(d,s,r,i,a)?bf(d,e,n,r,i,a):null;return p&&f?p.distance<=f.distance?p:f:p||f||null}}const wf=new nn,Mf=new vp,Tf=new vp,Ef=new Pn,Sf=new _p,Af=new _p;function Rf(t,e,n,r){wp.setBuffer(t._roots[e]);const i=Cf(0,t,n,r);return wp.clearBuffer(),i}function Cf(t,e,n,r,i=null){const{float32Array:a,uint16Array:s,uint32Array:o}=wp;let l=2*t;if(null===i&&(n.boundingBox||n.computeBoundingBox(),Sf.set(n.boundingBox.min,n.boundingBox.max,r),i=Sf),!Zd(l,s)){const s=t+8,l=o[t+6];return kd(s,a,wf),i.intersectsBox(wf)&&Cf(s,e,n,r,i)?!0:(kd(l,a,wf),!(!i.intersectsBox(wf)||!Cf(l,e,n,r,i)))}{const i=e.geometry,c=i.index,u=i.attributes.position,h=n.index,d=n.attributes.position,p=Jd(t,o),f=Qd(l,s);if(Ef.copy(r).invert(),n.boundsTree){kd(t,a,Af),Af.matrix.copy(Ef),Af.needsUpdate=!0;const i=n.boundsTree.shapecast({intersectsBounds:t=>Af.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=p,r=f+p;n<r;n++)if(Vp(Tf,3*e.resolveTriangleIndex(n),c,u),Tf.needsUpdate=!0,t.intersectsTriangle(Tf))return!0;return!1}});return i}for(let t=p,n=f+p;t<n;t++){const n=e.resolveTriangleIndex(t);Vp(Mf,3*n,c,u),Mf.a.applyMatrix4(Ef),Mf.b.applyMatrix4(Ef),Mf.c.applyMatrix4(Ef),Mf.needsUpdate=!0;for(let t=0,e=h.count;t<e;t+=3)if(Vp(Tf,t,h,d),Tf.needsUpdate=!0,Mf.intersectsTriangle(Tf))return!0}}}const Pf=new Pn,If=new _p,Lf=new _p,Df=new Qe,Of=new Qe,Nf=new Qe,Uf=new Qe;function Ff(t,e,n,r={},i={},a=0,s=1/0){e.boundingBox||e.computeBoundingBox(),If.set(e.boundingBox.min,e.boundingBox.max,n),If.needsUpdate=!0;const o=t.geometry,l=o.attributes.position,c=o.index,u=e.attributes.position,h=e.index,d=bp.getPrimitive(),p=bp.getPrimitive();let f=Df,m=Of,g=null,v=null;i&&(g=Nf,v=Uf);let _=1/0,y=null,x=null;return Pf.copy(n).invert(),Lf.matrix.copy(Pf),t.shapecast({boundsTraverseOrder:t=>If.distanceToBox(t),intersectsBounds:(t,e,n)=>n<_&&n<s&&(e&&(Lf.min.copy(t.min),Lf.max.copy(t.max),Lf.needsUpdate=!0),!0),intersectsRange:(r,i)=>{if(e.boundsTree){const o=e.boundsTree;return o.shapecast({boundsTraverseOrder:t=>Lf.distanceToBox(t),intersectsBounds:(t,e,n)=>n<_&&n<s,intersectsRange:(e,s)=>{for(let b=e,w=e+s;b<w;b++){const e=o.resolveTriangleIndex(b);Vp(p,3*e,h,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=r,n=r+i;e<n;e++){const n=t.resolveTriangleIndex(e);Vp(d,3*n,c,l),d.needsUpdate=!0;const r=d.distanceToTriangle(p,f,g);if(r<_&&(m.copy(f),v&&v.copy(g),_=r,y=e,x=b),r<a)return!0}}}})}for(let s=0,o=Dd(e);s<o;s++){Vp(p,3*s,h,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=r,n=r+i;e<n;e++){const n=t.resolveTriangleIndex(e);Vp(d,3*n,c,l),d.needsUpdate=!0;const r=d.distanceToTriangle(p,f,g);if(r<_&&(m.copy(f),v&&v.copy(g),_=r,y=e,x=s),r<a)return!0}}}}),bp.releasePrimitive(d),bp.releasePrimitive(p),_===1/0?null:(r.point?r.point.copy(m):r.point=m.clone(),r.distance=_,r.faceIndex=y,i&&(i.point?i.point.copy(v):i.point=v.clone(),i.point.applyMatrix4(Pf),m.applyMatrix4(Pf),i.distance=m.sub(i.point).length(),i.faceIndex=x),r)}function Bf(){return"undefined"!=typeof SharedArrayBuffer}function kf(t,e){if(null===t)return t;if(t.buffer){const n=t.buffer;if(n.constructor===e)return t;const r=new(0,t.constructor)(new e(n.byteLength));return r.set(t),r}{if(t.constructor===e)return t;const n=new e(t.byteLength);return new Uint8Array(n).set(new Uint8Array(t)),n}}const zf=new wp.constructor,Hf=new wp.constructor,Gf=new yp((()=>new nn)),Vf=new nn,Wf=new nn,jf=new nn,qf=new nn;let Xf=!1;function Yf(t,e,n,r,i,a=0,s=0,o=0,l=0,c=null,u=!1){let h,d;u?(h=Hf,d=zf):(h=zf,d=Hf);const p=h.float32Array,f=h.uint32Array,m=h.uint16Array,g=d.float32Array,v=d.uint32Array,_=d.uint16Array,y=2*e,x=Zd(2*t,m),b=Zd(y,_);let w=!1;if(b&&x)w=u?i(Jd(e,v),Qd(2*e,_),Jd(t,f),Qd(2*t,m),l,s+e,o,a+t):i(Jd(t,f),Qd(2*t,m),Jd(e,v),Qd(2*e,_),o,a+t,l,s+e);else if(b){const c=Gf.getPrimitive();kd(e,g,c),c.applyMatrix4(n);const h=tp(t),d=ep(t,f);kd(h,p,Vf),kd(d,p,Wf);const m=c.intersectsBox(Vf),v=c.intersectsBox(Wf);w=m&&Yf(e,h,r,n,i,s,a,l,o+1,c,!u)||v&&Yf(e,d,r,n,i,s,a,l,o+1,c,!u),Gf.releasePrimitive(c)}else{const h=tp(e),d=ep(e,v);kd(h,g,jf),kd(d,g,qf);const m=c.intersectsBox(jf),_=c.intersectsBox(qf);if(m&&_)w=Yf(t,h,n,r,i,a,s,o,l+1,c,u)||Yf(t,d,n,r,i,a,s,o,l+1,c,u);else if(m)if(x)w=Yf(t,h,n,r,i,a,s,o,l+1,c,u);else{const e=Gf.getPrimitive();e.copy(jf).applyMatrix4(n);const c=tp(t),d=ep(t,f);kd(c,p,Vf),kd(d,p,Wf);const m=e.intersectsBox(Vf),g=e.intersectsBox(Wf);w=m&&Yf(h,c,r,n,i,s,a,l,o+1,e,!u)||g&&Yf(h,d,r,n,i,s,a,l,o+1,e,!u),Gf.releasePrimitive(e)}else if(_)if(x)w=Yf(t,d,n,r,i,a,s,o,l+1,c,u);else{const e=Gf.getPrimitive();e.copy(qf).applyMatrix4(n);const c=tp(t),h=ep(t,f);kd(c,p,Vf),kd(h,p,Wf);const m=e.intersectsBox(Vf),g=e.intersectsBox(Wf);w=m&&Yf(d,c,r,n,i,s,a,l,o+1,e,!u)||g&&Yf(d,h,r,n,i,s,a,l,o+1,e,!u),Gf.releasePrimitive(e)}}return w}const $f=new _p,Kf=new nn,Zf={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Jf{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,i=t._indirectBuffer,a=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:a?a.array.slice():null,indirectBuffer:i?i.slice():null}:{roots:r,index:a?a.array:null,indirectBuffer:i},s}static deserialize(t,e,n={}){n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:r,roots:i,indirectBuffer:a}=t,s=new Jf(e,{...n,[Id]:!0});if(s._roots=i,s._indirectBuffer=a||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new Lr(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return s}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({...Zf,[Id]:!1},e)).useSharedArrayBuffer&&!Bf())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Id]||(hp(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new nn))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){return(this.indirect?gf:jp)(this,t)}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),i=new Uint16Array(n);!function e(a,s=0){const o=2*a,l=i[o+15]===Cd;if(l){const e=r[a+6],c=i[o+14];t(s,l,new Float32Array(n,4*a,6),e,c)}else{const i=a+8,o=r[a+6],c=r[a+7];t(s,l,new Float32Array(n,4*a,6),c)||(e(i,s+1),e(o,s+1))}}(0)}raycast(t,e=0,n=0,r=1/0){const i=this._roots,a=this.geometry,s=[],o=e.isMaterial,l=Array.isArray(e),c=a.groups,u=o?e.side:e,h=this.indirect?vf:Xp;for(let a=0,o=i.length;a<o;a++){const i=l?e[c[a].materialIndex].side:u,o=s.length;if(h(this,a,i,t,s,n,r),l){const t=c[a].materialIndex;for(let e=o,n=s.length;e<n;e++)s[e].face.materialIndex=t}}return s}raycastFirst(t,e=0,n=0,r=1/0){const i=this._roots,a=this.geometry,s=e.isMaterial,o=Array.isArray(e);let l=null;const c=a.groups,u=s?e.side:e,h=this.indirect?xf:Kp;for(let a=0,s=i.length;a<s;a++){const i=h(this,a,o?e[c[a].materialIndex].side:u,t,n,r);null!=i&&(null==l||i.distance<l.distance)&&(l=i,o&&(i.face.materialIndex=c[a].materialIndex))}return l}intersectsGeometry(t,e){let n=!1;const r=this._roots,i=this.indirect?Rf:af;for(let a=0,s=r.length;a<s&&(n=i(this,a,t,e),!n);a++);return n}shapecast(t){const e=bp.getPrimitive(),n=this.indirect?mf:Wp;let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:a,intersectsTriangle:s}=t;if(a&&s){const t=a;a=(r,i,a,o,l)=>!!t(r,i,a,o,l)||n(r,i,this,s,a,o,e)}else a||(a=s?(t,r,i,a)=>n(t,r,this,s,i,a,e):(t,e,n)=>n);let o=!1,l=0;const c=this._roots;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(o=Ap(this,t,i,a,r,l),o)break;l+=e.byteLength}return bp.releasePrimitive(e),o}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:i}=n;const a=bp.getPrimitive(),s=this.geometry.index,o=this.geometry.attributes.position,l=this.indirect?t=>{const e=this.resolveTriangleIndex(t);Vp(a,3*e,s,o)}:t=>{Vp(a,3*t,s,o)},c=bp.getPrimitive(),u=t.geometry.index,h=t.geometry.attributes.position,d=t.indirect?e=>{const n=t.resolveTriangleIndex(e);Vp(c,3*n,u,h)}:t=>{Vp(c,3*t,u,h)};if(i){const t=(t,n,r,s,o,u,h,p)=>{for(let f=r,m=r+s;f<m;f++){d(f),c.a.applyMatrix4(e),c.b.applyMatrix4(e),c.c.applyMatrix4(e),c.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(l(e),a.needsUpdate=!0,i(a,c,e,f,o,u,h,p))return!0}return!1};if(r){const e=r;r=function(n,r,i,a,s,o,l,c){return!!e(n,r,i,a,s,o,l,c)||t(n,r,i,a,s,o,l,c)}}else r=t}return function(t,e,n,r){if(Xf)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Xf=!0;const i=t._roots,a=e._roots;let s,o=0,l=0;const c=(new Pn).copy(n).invert();for(let t=0,e=i.length;t<e;t++){zf.setBuffer(i[t]),l=0;const e=Gf.getPrimitive();kd(0,zf.float32Array,e),e.applyMatrix4(c);for(let t=0,i=a.length;t<i&&(Hf.setBuffer(a[t]),s=Yf(0,0,n,c,r,o,l,0,0,e),Hf.clearBuffer(),l+=a[t].length,!s);t++);if(Gf.releasePrimitive(e),zf.clearBuffer(),o+=i[t].length,s)break}return Xf=!1,s}(this,t,e,r)}intersectsBox(t,e){return $f.set(t.min,t.max,e),$f.needsUpdate=!0,this.shapecast({intersectsBounds:t=>$f.intersectsBox(t),intersectsTriangle:t=>$f.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},i=0,a=1/0){return(this.indirect?Ff:ff)(this,t,e,n,r,i,a)}closestPointToPoint(t,e={},n=0,r=1/0){return function(t,e,n={},r=0,i=1/0){const a=r*r,s=i*i;let o=1/0,l=null;if(t.shapecast({boundsTraverseOrder:t=>(Cp.copy(e).clamp(t.min,t.max),Cp.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<o&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,Cp);const r=e.distanceToSquared(Cp);return r<o&&(Pp.copy(Cp),o=r,l=n),r<a}}),o===1/0)return null;const c=Math.sqrt(o);return n.point?n.point.copy(Pp):n.point=Pp.clone(),n.distance=c,n.faceIndex=l,n}(this,t,e,n,r)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach((e=>{kd(0,new Float32Array(e),Kf),t.union(Kf)})),t}}class Qf{constructor(t){this.name="WorkerBase",this.running=!1,this.worker=t,this.worker.onerror=t=>{throw t.message?new Error(`${this.name}: Could not create Web Worker with error "${t.message}"`):new Error(`${this.name}: Could not create Web Worker.`)}}runTask(){}generate(...t){if(this.running)throw new Error("GenerateMeshBVHWorker: Already running job.");if(null===this.worker)throw new Error("GenerateMeshBVHWorker: Worker has been disposed.");this.running=!0;const e=this.runTask(this.worker,...t);return e.finally((()=>{this.running=!1})),e}dispose(){this.worker.terminate(),this.worker=null}}class tm extends Qf{constructor(){super(new Worker(new URL(n.p+n.u(770),n.b),{type:void 0})),this.name="GenerateMeshBVHWorker"}runTask(t,e,n={}){return new Promise(((r,i)=>{if(e.getAttribute("position").isInterleavedBufferAttribute||e.index&&e.index.isInterleavedBufferAttribute)throw new Error("GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.");t.onerror=t=>{i(new Error(`GenerateMeshBVHWorker: ${t.message}`))},t.onmessage=a=>{const{data:s}=a;if(s.error)i(new Error(s.error)),t.onmessage=null;else if(s.serialized){const{serialized:i,position:a}=s,o=Jf.deserialize(i,e,{setIndex:!1}),l=Object.assign({setBoundingBox:!0},n);if(e.attributes.position.array=a,i.index)if(e.index)e.index.array=i.index;else{const t=new Lr(i.index,1,!1);e.setIndex(t)}l.setBoundingBox&&(e.boundingBox=o.getBoundingBox(new nn)),n.onProgress&&n.onProgress(s.progress),r(o),t.onmessage=null}else n.onProgress&&n.onProgress(s.progress)};const a=e.index?e.index.array:null,s=e.attributes.position.array,o=[s];a&&o.push(a),t.postMessage({index:a,position:s,options:{...n,onProgress:null,includedProgressCallback:Boolean(n.onProgress),groups:[...e.groups]}},o.map((t=>t.buffer)).filter((t=>"undefined"==typeof SharedArrayBuffer||!(t instanceof SharedArrayBuffer))))}))}}const em="undefined"!=typeof navigator?navigator.hardwareConcurrency:4;class nm extends Qf{constructor(){if(super(new Worker(new URL(n.p+n.u(444),n.b),{type:void 0})),this.name="ParallelMeshBVHWorker",this.maxWorkerCount=Math.max(em,4),!Bf())throw new Error("ParallelMeshBVHWorker: Shared Array Buffers are not supported.")}runTask(t,e,n={}){return new Promise(((r,i)=>{if(e.index||n.indirect||Nd(e,n),e.getAttribute("position").isInterleavedBufferAttribute||e.index&&e.index.isInterleavedBufferAttribute)throw new Error("ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.");t.onerror=t=>{i(new Error(`ParallelMeshBVHWorker: ${t.message}`))},t.onmessage=a=>{const{data:s}=a;if(s.error)i(new Error(s.error)),t.onmessage=null;else if(s.serialized){const{serialized:i,position:a}=s,o=Jf.deserialize(i,e,{setIndex:!1}),l={setBoundingBox:!0,...n};if(e.attributes.position.array=a,i.index)if(e.index)e.index.array=i.index;else{const t=new Lr(i.index,1,!1);e.setIndex(t)}l.setBoundingBox&&(e.boundingBox=o.getBoundingBox(new nn)),n.onProgress&&n.onProgress(s.progress),r(o),t.onmessage=null}else n.onProgress&&n.onProgress(s.progress)};const a=e.index?e.index.array:null,s=e.attributes.position.array;t.postMessage({operation:"BUILD_BVH",maxWorkerCount:this.maxWorkerCount,index:kf(a,SharedArrayBuffer),position:kf(s,SharedArrayBuffer),options:{...n,onProgress:null,includedProgressCallback:Boolean(n.onProgress),groups:[...e.groups]}})}))}}class rm{constructor(){if(Bf())return new nm;{console.warn("ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.");const t=new tm;return t.maxWorkerCount=em,t}}}function im(t,e,n=0){if(t.isInterleavedBufferAttribute){const r=t.itemSize;for(let i=0,a=t.count;i<a;i++){const a=i+n;e.setX(a,t.getX(i)),r>=2&&e.setY(a,t.getY(i)),r>=3&&e.setZ(a,t.getZ(i)),r>=4&&e.setW(a,t.getW(i))}}else{const r=e.array,i=r.constructor,a=r.BYTES_PER_ELEMENT*t.itemSize*n;new i(r.buffer,a,t.array.length).set(t.array)}}function am(t,e=null){const n=t.array.constructor,r=t.normalized,i=t.itemSize,a=null===e?t.count:e;return new Lr(new n(i*a),i,r)}function sm(t,e){if(!t&&!e)return!0;if(Boolean(t)!==Boolean(e))return!1;const n=t.count===e.count,r=t.normalized===e.normalized,i=t.array.constructor===e.array.constructor,a=t.itemSize===e.itemSize;return!!(n&&r&&i&&a)}function om(t,e){if(!t.index){const e=t.attributes.position.count,n=new Array(e);for(let t=0;t<e;t++)n[t]=t;t.setIndex(n)}if(!t.attributes.normal&&e&&e.includes("normal")&&t.computeVertexNormals(),!t.attributes.uv&&e&&e.includes("uv")){const e=t.attributes.position.count;t.setAttribute("uv",new Lr(new Float32Array(2*e),2,!1))}if(!t.attributes.uv2&&e&&e.includes("uv2")){const e=t.attributes.position.count;t.setAttribute("uv2",new Lr(new Float32Array(2*e),2,!1))}if(!t.attributes.tangent&&e&&e.includes("tangent"))if(t.attributes.uv&&t.attributes.normal)t.computeTangents();else{const e=t.attributes.position.count;t.setAttribute("tangent",new Lr(new Float32Array(4*e),4,!1))}if(!t.attributes.color&&e&&e.includes("color")){const e=t.attributes.position.count,n=new Float32Array(4*e);n.fill(1),t.setAttribute("color",new Lr(n,4))}}function lm(t){let e=0;if(0!==t.byteLength){const n=new Uint8Array(t);for(let r=0;r<t.byteLength;r++)e=(e<<5)-e+n[r],e|=0}return e}function cm(t){let e=t.uuid;const n=Object.values(t.attributes);t.index&&(n.push(t.index),e+=`index|${t.index.version}`);const r=Object.keys(n).sort();for(const t of r)e+=`${t}_${n[t].version}|`;return e}function um(t){const e=t.skeleton;return e?(e.boneTexture||e.computeBoneTexture(),`${lm(e.boneTexture.image.data.buffer)}_${e.boneTexture.uuid}`):null}class hm{constructor(t=null){this.matrixWorld=new Pn,this.geometryHash=null,this.skeletonHash=null,this.primitiveCount=-1,null!==t&&this.updateFrom(t)}updateFrom(t){const e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;this.matrixWorld.copy(t.matrixWorld),this.geometryHash=cm(e),this.primitiveCount=n,this.skeletonHash=um(t)}didChange(t){const e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===cm(e)&&this.skeletonHash===um(t)&&this.primitiveCount===n)}}const dm=new Qe,pm=new Qe,fm=new Qe,mm=new qe,gm=new Qe,vm=new Qe,_m=new qe,ym=new qe,xm=new Pn,bm=new Pn;function wm(t,e,n){const r=t.skeleton,i=t.geometry,a=r.bones,s=r.boneInverses;_m.fromBufferAttribute(i.attributes.skinIndex,e),ym.fromBufferAttribute(i.attributes.skinWeight,e),xm.elements.fill(0);for(let t=0;t<4;t++){const e=ym.getComponent(t);if(0!==e){const n=_m.getComponent(t);bm.multiplyMatrices(a[n].matrixWorld,s[n]),Tm(xm,bm,e)}}return xm.multiply(t.bindMatrix).premultiply(t.bindMatrixInverse),n.transformDirection(xm),n}function Mm(t,e,n,r,i){gm.set(0,0,0);for(let a=0,s=t.length;a<s;a++){const s=e[a],o=t[a];0!==s&&(vm.fromBufferAttribute(o,r),n?gm.addScaledVector(vm,s):gm.addScaledVector(vm.sub(i),s))}i.add(gm)}function Tm(t,e,n){const r=t.elements,i=e.elements;for(let t=0,e=i.length;t<e;t++)r[t]+=i[t]*n}class Em extends Vr{constructor(){super(),this.version=0,this.hash=null,this._diff=new hm}isCompatible(t,e){const n=t.geometry;for(let t=0;t<e.length;t++){const r=e[t],i=n.attributes[r],a=this.attributes[r];if(i&&!sm(i,a))return!1}return!0}updateFrom(t,e){const n=this._diff;return!!n.didChange(t)&&(function(t,e={},n=new Vr){e={applyWorldTransforms:!0,attributes:[],...e};const r=t.geometry,i=e.applyWorldTransforms,a=e.attributes.includes("normal"),s=e.attributes.includes("tangent"),o=r.attributes,l=n.attributes;for(const t in n.attributes)e.attributes.includes(t)&&t in r.attributes||n.deleteAttribute(t);!n.index&&r.index&&(n.index=r.index.clone()),l.position||n.setAttribute("position",am(o.position)),a&&!l.normal&&o.normal&&n.setAttribute("normal",am(o.normal)),s&&!l.tangent&&o.tangent&&n.setAttribute("tangent",am(o.tangent)),sm(r.index,n.index),sm(o.position,l.position),a&&sm(o.normal,l.normal),s&&sm(o.tangent,l.tangent);const c=o.position,u=a?o.normal:null,h=s?o.tangent:null,d=r.morphAttributes.position,p=r.morphAttributes.normal,f=r.morphAttributes.tangent,m=r.morphTargetsRelative,g=t.morphTargetInfluences,v=new Te;v.getNormalMatrix(t.matrixWorld),r.index&&n.index.array.set(r.index.array);for(let e=0,n=o.position.count;e<n;e++)dm.fromBufferAttribute(c,e),u&&pm.fromBufferAttribute(u,e),h&&(mm.fromBufferAttribute(h,e),fm.fromBufferAttribute(h,e)),g&&(d&&Mm(d,g,m,e,dm),p&&Mm(p,g,m,e,pm),f&&Mm(f,g,m,e,fm)),t.isSkinnedMesh&&(t.applyBoneTransform(e,dm),u&&wm(t,e,pm),h&&wm(t,e,fm)),i&&dm.applyMatrix4(t.matrixWorld),l.position.setXYZ(e,dm.x,dm.y,dm.z),u&&(i&&pm.applyNormalMatrix(v),l.normal.setXYZ(e,pm.x,pm.y,pm.z)),h&&(i&&fm.transformDirection(t.matrixWorld),l.tangent.setXYZW(e,fm.x,fm.y,fm.z,mm.w));for(const t in e.attributes){const r=e.attributes[t];"position"!==r&&"tangent"!==r&&"normal"!==r&&r in o&&(l[r]||n.setAttribute(r,am(o[r])),sm(o[r],l[r]),im(o[r],l[r]))}t.matrixWorld.determinant()<0&&function(t){const{index:e,attributes:n}=t;if(e)for(let t=0,n=e.count;t<n;t+=3){const n=e.getX(t),r=e.getX(t+2);e.setX(t,r),e.setX(t+2,n)}else for(const t in n){const e=n[t],r=e.itemSize;for(let t=0,n=e.count;t<n;t+=3)for(let n=0;n<r;n++){const r=e.getComponent(t,n),i=e.getComponent(t+2,n);e.setComponent(t,n,i),e.setComponent(t+2,n,r)}}}(n)}(t,e,this),n.updateFrom(t),this.version++,this.hash=`${this.uuid}_${this.version}`,!0)}}function Sm(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];Array.isArray(r.material)?e.push(...r.material):e.push(r.material)}return e}class Am{constructor(t){this.objects=null,this.useGroups=!0,this.applyWorldTransforms=!0,this.generateMissingAttributes=!0,this.overwriteIndex=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Map,this._geometryMergeSets=new WeakMap,this._mergeOrder=[],this._dummyMesh=null,this.setObjects(t||[])}_getDummyMesh(){if(!this._dummyMesh){const t=new Sr,e=new Vr;e.setAttribute("position",new Lr(new Float32Array(9),3)),this._dummyMesh=new ei(e,t)}return this._dummyMesh}_getMeshes(){const t=[];return function(e){for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible((e=>{var n;e.isMesh&&(n=e,t.push(n))}))}(this.objects),t.sort(((t,e)=>t.uuid>e.uuid?1:t.uuid<e.uuid?-1:0)),0===t.length&&t.push(this._getDummyMesh()),t}_updateIntermediateGeometries(){const{_intermediateGeometry:t}=this,e=this._getMeshes(),n=new Set(t.keys()),r={attributes:this.attributes,applyWorldTransforms:this.applyWorldTransforms};for(let i=0,a=e.length;i<a;i++){const a=e[i],s=a.uuid;n.delete(s);let o=t.get(s);o&&o.isCompatible(a,this.attributes)||(o&&o.dispose(),o=new Em,t.set(s,o)),o.updateFrom(a,r)&&this.generateMissingAttributes&&om(o,this.attributes)}n.forEach((e=>{t.delete(e)}))}setObjects(t){Array.isArray(t)?this.objects=[...t]:this.objects=[t]}generate(t=new Vr){const{useGroups:e,overwriteIndex:n,_intermediateGeometry:r,_geometryMergeSets:i}=this,a=this._getMeshes(),s=[],o=[],l=i.get(t)||[];this._updateIntermediateGeometries();let c=!1;a.length!==l.length&&(c=!0);for(let t=0,e=a.length;t<e;t++){const e=a[t],n=r.get(e.uuid);o.push(n);const i=l[t];i&&i.uuid===n.uuid?i.version!==n.version?s.push(!1):s.push(!0):(s.push(!1),c=!0)}!function(t,e,n){if(0===t.length){e.setIndex(null);const t=e.attributes;for(const n in t)e.deleteAttribute(n);for(const t in n.attributes)e.setAttribute(n.attributes[t],new Lr(new Float32Array(0),4,!1))}else!function(t,e={},n=new Vr){const{useGroups:r=!1,forceUpdate:i=!1,skipAssigningAttributes:a=[],overwriteIndex:s=!0}=e;!function(t){const e=null!==t[0].index,n=new Set(Object.keys(t[0].attributes));if(!t[0].getAttribute("position"))throw new Error("StaticGeometryGenerator: position attribute is required.");for(let r=0;r<t.length;++r){const i=t[r];let a=0;if(e!==(null!==i.index))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const t in i.attributes){if(!n.has(t))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');a++}if(a!==n.size)throw new Error("StaticGeometryGenerator: All geometries must have the same number of attributes.")}}(t);const o=null!==t[0].index,l=o?function(t){let e=0;for(let n=0,r=t.length;n<r;n++)e+=t[n].getIndex().count;return e}(t):-1,c=function(t){let e=0;for(let n=0,r=t.length;n<r;n++)e+=t[n].getAttribute("position").count;return e}(t);if(function(t,e,n){t.index&&t.index.count!==e&&t.setIndex(null);const r=t.attributes;for(const e in r)r[e].count!==n&&t.deleteAttribute(e)}(n,l,c),r){let e=0;for(let r=0,i=t.length;r<i;r++){const i=t[r];let a;a=o?i.getIndex().count:i.getAttribute("position").count,n.addGroup(e,a,r),e+=a}}if(o){let e=!1;if(n.index||(n.setIndex(new Lr(new Uint32Array(l),1,!1)),e=!0),e||s){let r=0,s=0;const o=n.getIndex();for(let n=0,l=t.length;n<l;n++){const l=t[n],c=l.getIndex();if(i||e||!a[n])for(let t=0;t<c.count;++t)o.setX(r+t,c.getX(t)+s);r+=c.count,s+=l.getAttribute("position").count}}}const u=Object.keys(t[0].attributes);for(let e=0,r=u.length;e<r;e++){let r=!1;const s=u[e];if(!n.getAttribute(s)){const e=t[0].getAttribute(s);n.setAttribute(s,am(e,c)),r=!0}let o=0;const l=n.getAttribute(s);for(let e=0,n=t.length;e<n;e++){const n=t[e],c=!i&&!r&&a[e],u=n.getAttribute(s);c||im(u,l,o),o+=u.count}}}(t,n,e);for(const t in e.attributes)e.attributes[t].needsUpdate=!0}(o,t,{useGroups:e,forceUpdate:c,skipAssigningAttributes:s,overwriteIndex:n}),c&&t.dispose(),i.set(t,o.map((t=>({version:t.version,uuid:t.uuid}))));let u=0;return c?u=2:s.includes(!1)&&(u=1),{changeType:u,materials:Sm(a),geometry:t}}}class Rm{get initialized(){return Boolean(this.bvh)}constructor(t){this.bvhOptions={},this.attributes=["position","normal","tangent","color","uv","uv2"],this.generateBVH=!0,this.bvh=null,this.geometry=new Vr,this.staticGeometryGenerator=new Am(t),this._bvhWorker=null,this._pendingGenerate=null,this._buildAsync=!1}setObjects(t){this.staticGeometryGenerator.setObjects(t)}setBVHWorker(t){this._bvhWorker=t}async generateAsync(t=null){if(!this._bvhWorker)throw new Error('PathTracingSceneGenerator: "setBVHWorker" must be called before "generateAsync" can be called.');if(this.bvh instanceof Promise)return this._pendingGenerate||(this._pendingGenerate=new Promise((async()=>(await this.bvh,this._pendingGenerate=null,this.generateAsync(t))))),this._pendingGenerate;{this._buildAsync=!0;const e=this.generate(t);return this._buildAsync=!1,e.bvh=this.bvh=await e.bvh,e}}generate(t=null){const{staticGeometryGenerator:e,geometry:n,attributes:r}=this,i=e.objects;e.attributes=r,i.forEach((t=>{t.traverse((t=>{t.isSkinnedMesh&&t.skeleton&&t.skeleton.update()}))}));const a=e.generate(n),s=a.materials,o=function(t){const e=new Set;for(let n=0,r=t.length;n<r;n++){const r=t[n];for(const t in r){const n=r[t];n&&n.isTexture&&e.add(n)}}return Array.from(e)}(s),{lights:l,iesTextures:c}=function(t){const e=[],n=new Set;for(let r=0,i=t.length;r<i;r++)t[r].traverse((t=>{t.visible&&(t.isRectAreaLight||t.isSpotLight||t.isPointLight||t.isDirectionalLight)&&(e.push(t),t.iesMap&&n.add(t.iesMap))}));const r=Array.from(n).sort(((t,e)=>t.uuid<e.uuid?1:t.uuid>e.uuid?-1:0));return{lights:e,iesTextures:r}}(i);if(0!==a.changeType&&function(t,e,n){const r=t.index,i=t.attributes.position.count,a=r?r.count:i;let s=t.groups;0===s.length&&(s=[{count:a,start:0,materialIndex:0}]);let o=t.getAttribute("materialIndex");if(!o||o.count!==i){let e;e=n.length<=255?new Uint8Array(i):new Uint16Array(i),o=new Lr(e,1,!1),t.deleteAttribute("materialIndex"),t.setAttribute("materialIndex",o)}const l=o.array;for(let t=0;t<s.length;t++){const i=s[t],o=i.start,c=i.count,u=Math.min(c,a-o),h=Array.isArray(e)?e[i.materialIndex]:e,d=n.indexOf(h);for(let t=0;t<u;t++){let e=o+t;r&&(e=r.getX(e)),l[e]=d}}}(n,s,s),this.generateBVH){if(this.bvh instanceof Promise)throw new Error("PathTracingSceneGenerator: BVH is already building asynchronously.");if(2===a.changeType){const e={strategy:2,maxLeafTris:1,indirect:!0,onProgress:t,...this.bvhOptions};this._buildAsync?this.bvh=this._bvhWorker.generate(n,e):this.bvh=new Jf(n,e)}else 1===a.changeType&&this.bvh.refit()}return{bvhChanged:0!==a.changeType,bvh:this.bvh,lights:l,iesTextures:c,geometry:n,materials:s,textures:o,objects:i}}}const Cm=new zi(-1,1,1,-1,0,1),Pm=new class extends Vr{constructor(){super(),this.setAttribute("position",new Nr([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Nr([0,2,0,0,2,0],2))}};class Im{constructor(t){this._mesh=new ei(Pm,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,Cm)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class Lm extends li{set needsUpdate(t){super.needsUpdate=!0,this.dispatchEvent({type:"recompilation"})}constructor(t){super(t);for(const t in this.uniforms)Object.defineProperty(this,t,{get(){return this.uniforms[t].value},set(e){this.uniforms[t].value=e}})}setDefine(t,e=void 0){if(null==e){if(t in this.defines)return delete this.defines[t],this.needsUpdate=!0,!0}else if(this.defines[t]!==e)return this.defines[t]=e,this.needsUpdate=!0,!0;return!1}}class Dm extends Lm{constructor(t){super({blending:0,uniforms:{target1:{value:null},target2:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}"}),this.setValues(t)}}function Om(t=1){let e="uint";return t>1&&(e="uvec"+t),`\n\t\t${e} sobolReverseBits( ${e} x ) {\n\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\n\n\t\t}\n\n\t\t${e} sobolHashCombine( uint seed, ${e} v ) {\n\n\t\t\treturn seed ^ ( v + ${e}( ( seed << 6 ) + ( seed >> 2 ) ) );\n\n\t\t}\n\n\t\t${e} sobolLaineKarrasPermutation( ${e} x, ${e} seed ) {\n\n\t\t\tx += seed;\n\t\t\tx ^= x * 0x6c50b47cu;\n\t\t\tx ^= x * 0xb82f1e52u;\n\t\t\tx ^= x * 0xc7afe638u;\n\t\t\tx ^= x * 0x8d22f6e6u;\n\t\t\treturn x;\n\n\t\t}\n\n\t\t${e} nestedUniformScrambleBase2( ${e} x, ${e} seed ) {\n\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\n\t\t\tx = sobolReverseBits( x );\n\t\t\treturn x;\n\n\t\t}\n\t`}function Nm(t=1){let e="uint",n="float",r="",i=".r",a="1u";return t>1&&(e="uvec"+t,n="vec"+t,r=t+"",2===t?(i=".rg",a="uvec2( 1u, 2u )"):3===t?(i=".rgb",a="uvec3( 1u, 2u, 3u )"):(i="",a="uvec4( 1u, 2u, 3u, 4u )")),`\n\n\t\t${n} sobol${r}( int effect ) {\n\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\n\t\t\tuint index = sobolPathIndex;\n\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\n\t\t\t${n} sobol_pt = sobolGetTexturePoint( shuffled_index )${i};\n\t\t\t${e} result = ${e}( sobol_pt * 16777216.0 );\n\n\t\t\t${e} seed2 = sobolHashCombine( seed, ${a} );\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\n\n\t\t\treturn SOBOL_FACTOR * ${n}( result >> 8 );\n\n\t\t}\n\t`}const Um=`\n\n\t// Utils\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\n\n\t${Om(1)}\n\t${Om(2)}\n\t${Om(3)}\n\t${Om(4)}\n\n\tuint sobolHash( uint x ) {\n\n\t\t// finalizer from murmurhash3\n\t\tx ^= x >> 16;\n\t\tx *= 0x85ebca6bu;\n\t\tx ^= x >> 13;\n\t\tx *= 0xc2b2ae35u;\n\t\tx ^= x >> 16;\n\t\treturn x;\n\n\t}\n\n`,Fm=`\n\n\t// Seeds\n\tuniform sampler2D sobolTexture;\n\tuint sobolPixelIndex = 0u;\n\tuint sobolPathIndex = 0u;\n\tuint sobolBounceIndex = 0u;\n\n\tuint sobolGetSeed( uint bounce, uint effect ) {\n\n\t\treturn sobolHash(\n\t\t\tsobolHashCombine(\n\t\t\t\tsobolHashCombine(\n\t\t\t\t\tsobolHash( bounce ),\n\t\t\t\t\tsobolPixelIndex\n\t\t\t\t),\n\t\t\t\teffect\n\t\t\t)\n\t\t);\n\n\t}\n\n\tvec4 sobolGetTexturePoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\tindex = index % SOBOL_MAX_POINTS;\n\n\t\t}\n\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\n\t\tuint y = index / dim.x;\n\t\tuint x = index - y * dim.x;\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\n\t\treturn texture( sobolTexture, uv );\n\n\t}\n\n\t${Nm(1)}\n\t${Nm(2)}\n\t${Nm(3)}\n\t${Nm(4)}\n\n`;class Bm extends Lm{constructor(){super({blending:0,uniforms:{resolution:{value:new Me}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:`\n\n\t\t\t\t${Um}\n\t\t\t\t\n\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n\t);\n\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\n\n\t\tuint X = 0u;\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\n\n\t\t\tuint mask = ( index >> bit ) & 1u;\n\t\t\tX ^= mask * directions[ bit ];\n\n\t\t}\n\t\treturn X;\n\n\t}\n\n\tvec4 generateSobolPoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\treturn vec4( 0.0 );\n\n\t\t}\n\n\t\t// NOTE: this sobol "direction" is also available but we can't write out 5 components\n\t\t// uint x = index & 0x00ffffffu;\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\n\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\n\n\t}\n\n\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\n\n\t\t\t\t}\n\t\t\t`})}}class km{generate(t,e=256){const n=new Ye(e,e,{type:tt,format:at,minFilter:G,magFilter:G,generateMipmaps:!1}),r=t.getRenderTarget();t.setRenderTarget(n);const i=new Im(new Bm);return i.material.resolution.set(e,e),i.render(t),t.setRenderTarget(r),i.dispose(),n}}function zm(t){switch(t){case 1:return ct;case 2:return ht;case 3:case 4:return dt}}class Hm extends Po{constructor(){super(),this.minFilter=G,this.magFilter=G,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,r=t.count;if(null!==e){if(n*r%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=r*n/e}const i=t.itemSize,a=t.count,s=t.normalized,o=t.array.constructor,l=o.BYTES_PER_ELEMENT;let c,u,h,d,p=this._forcedType,f=i;if(null===p)switch(o){case Float32Array:p=tt;break;case Uint8Array:case Uint16Array:case Uint32Array:p=Q;break;case Int8Array:case Int16Array:case Int32Array:p=J}let m=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:case 4:return"RGBA"}throw new Error}(i);switch(p){case tt:h=1,u=function(t){switch(t){case 1:return lt;case 2:return ut;case 3:case 4:return at}}(i),s&&1===l?(d=o,m+="8",o===Uint8Array?c=Y:(c=$,m+="_SNORM")):(d=Float32Array,m+="32F",c=tt);break;case J:m+=8*l+"I",h=s?Math.pow(2,8*o.BYTES_PER_ELEMENT-1):1,u=zm(i),1===l?(d=Int8Array,c=$):2===l?(d=Int16Array,c=K):(d=Int32Array,c=J);break;case Q:m+=8*l+"UI",h=s?Math.pow(2,8*o.BYTES_PER_ELEMENT-1):1,u=zm(i),1===l?(d=Uint8Array,c=Y):2===l?(d=Uint16Array,c=Z):(d=Uint32Array,c=Q)}3!==f||u!==at&&u!==dt||(f=4);const g=Math.ceil(Math.sqrt(a))||1,v=new d(f*g*g),_=t.normalized;t.normalized=!1;for(let e=0;e<a;e++){const n=f*e;v[n]=t.getX(e)/h,i>=2&&(v[n+1]=t.getY(e)/h),i>=3&&(v[n+2]=t.getZ(e)/h,4===f&&(v[n+3]=1)),i>=4&&(v[n+3]=t.getW(e)/h)}t.normalized=_,this.internalFormat=m,this.format=u,this.type=c,this.image.width=g,this.image.height=g,this.image.data=v,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=r}}class Gm extends Hm{constructor(){super(),this._forcedType=Q}}class Vm extends Hm{constructor(){super(),this._forcedType=tt}}class Wm{constructor(){this.index=new Gm,this.position=new Vm,this.bvhBounds=new Po,this.bvhContents=new Po,this._cachedIndexAttr=null,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;if(function(t,e,n){const r=t._roots;if(1!==r.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const i=r[0],a=new Uint16Array(i),s=new Uint32Array(i),o=new Float32Array(i),l=i.byteLength/Rd,c=2*Math.ceil(Math.sqrt(l/2)),u=new Float32Array(4*c*c),h=Math.ceil(Math.sqrt(l)),d=new Uint32Array(2*h*h);for(let t=0;t<l;t++){const e=t*Rd/4,n=2*e,r=e;for(let e=0;e<3;e++)u[8*t+0+e]=o[r+0+e],u[8*t+4+e]=o[r+3+e];if(Zd(n,a)){const r=Qd(n,a),i=Jd(e,s),o=4294901760|r;d[2*t+0]=o,d[2*t+1]=i}else{const n=4*ep(e,s)/Rd,r=np(e,s);d[2*t+0]=r,d[2*t+1]=n}}e.image.data=u,e.image.width=c,e.image.height=c,e.format=at,e.type=tt,e.internalFormat="RGBA32F",e.minFilter=G,e.magFilter=G,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),n.image.data=d,n.image.width=h,n.image.height=h,n.format=ht,n.type=Q,n.internalFormat="RG32UI",n.minFilter=G,n.magFilter=G,n.generateMipmaps=!1,n.needsUpdate=!0,n.dispose()}(t,this.bvhBounds,this.bvhContents),this.position.updateFrom(e.attributes.position),t.indirect){const n=t._indirectBuffer;if(null===this._cachedIndexAttr||this._cachedIndexAttr.count!==n.length)if(e.index)this._cachedIndexAttr=e.index.clone();else{const t=Od(Ld(e));this._cachedIndexAttr=new Lr(t,1,!1)}!function(t,e,n){const r=n.array,i=t.index?t.index.array:null;for(let t=0,n=e.length;t<n;t++){const n=3*t,a=3*e[t];for(let t=0;t<3;t++)r[n+t]=i?i[a+t]:a+t}}(e,n,this._cachedIndexAttr),this.index.updateFrom(this._cachedIndexAttr)}else this.index.updateFrom(e.index)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:r}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),r&&r.dispose()}}class jm extends pi{set bokehSize(t){this.fStop=this.getFocalLength()/t}get bokehSize(){return this.getFocalLength()/this.fStop}constructor(...t){super(...t),this.fStop=1.4,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=25,this.anamorphicRatio=1}copy(t,e){return super.copy(t,e),this.fStop=t.fStop,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio,this}}class qm{constructor(){this.bokehSize=0,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=10,this.anamorphicRatio=1}updateFrom(t){t instanceof jm?(this.bokehSize=t.bokehSize,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio):(this.bokehSize=0,this.apertureRotation=0,this.apertureBlades=0,this.focusDistance=10,this.anamorphicRatio=1)}}function Xm(t){const e=new Uint16Array(t.length);for(let n=0,r=t.length;n<r;++n)e[n]=Cr.toHalfFloat(t[n]);return e}function Ym(t,e,n=0,r=t.length){let i=n,a=n+r-1;for(;i<a;){const n=i+a>>1;t[n]<e?i=n+1:a=n}return i-n}class $m{constructor(){const t=new Po(Xm(new Float32Array([0,0,0,0])),1,1);t.type=et,t.format=at,t.minFilter=j,t.magFilter=j,t.wrapS=k,t.wrapT=k,t.generateMipmaps=!1,t.needsUpdate=!0;const e=new Po(Xm(new Float32Array([0,1])),1,2);e.type=et,e.format=lt,e.minFilter=j,e.magFilter=j,e.generateMipmaps=!1,e.needsUpdate=!0;const n=new Po(Xm(new Float32Array([0,0,1,1])),2,2);n.type=et,n.format=lt,n.minFilter=j,n.magFilter=j,n.generateMipmaps=!1,n.needsUpdate=!0,this.map=t,this.marginalWeights=e,this.conditionalWeights=n,this.totalSum=0}dispose(){this.marginalWeights.dispose(),this.conditionalWeights.dispose(),this.map.dispose()}updateFrom(t){const e=function(t,e=1016){const n=t.clone();n.source=new Ge({...n.image});const{width:r,height:i,data:a}=n.image;let s=a;if(n.type!==e){let t;s=e===et?new Uint16Array(a.length):new Float32Array(a.length),t=a instanceof Int8Array||a instanceof Int16Array||a instanceof Int32Array?2**(8*a.BYTES_PER_ELEMENT-1)-1:2**(8*a.BYTES_PER_ELEMENT)-1;for(let r=0,i=a.length;r<i;r++){let i=a[r];n.type===et&&(i=Cr.fromHalfFloat(a[r])),n.type!==tt&&n.type!==et&&(i/=t),e===et&&(s[r]=Cr.toHalfFloat(i))}n.image.data=s,n.type=e}if(n.flipY){const t=s;s=s.slice();for(let e=0;e<i;e++)for(let n=0;n<r;n++){const a=4*(e*r+n),o=4*((i-e-1)*r+n);s[o+0]=t[a+0],s[o+1]=t[a+1],s[o+2]=t[a+2],s[o+3]=t[a+3]}n.flipY=!1,n.image.data=s}return n}(t);e.wrapS=k,e.wrapT=z;const{width:n,height:r,data:i}=e.image,a=new Float32Array(n*r),s=new Float32Array(n*r),o=new Float32Array(r),l=new Float32Array(r);let c=0,u=0;for(let t=0;t<r;t++){let e=0;for(let r=0;r<n;r++){const o=t*n+r,l=(h=Cr.fromHalfFloat(i[4*o+0]),d=Cr.fromHalfFloat(i[4*o+1]),p=Cr.fromHalfFloat(i[4*o+2]),.2126*h+.7152*d+.0722*p);e+=l,c+=l,a[o]=l,s[o]=e}if(0!==e)for(let r=t*n,i=t*n+n;r<i;r++)a[r]/=e,s[r]/=e;u+=e,o[t]=e,l[t]=u}var h,d,p;if(0!==u)for(let t=0,e=o.length;t<e;t++)o[t]/=u,l[t]/=u;const f=new Uint16Array(r),m=new Uint16Array(n*r);for(let t=0;t<r;t++){const e=Ym(l,(t+1)/r);f[t]=Cr.toHalfFloat((e+.5)/r)}for(let t=0;t<r;t++)for(let e=0;e<n;e++){const r=t*n+e,i=Ym(s,(e+1)/n,t*n,n);m[r]=Cr.toHalfFloat((i+.5)/n)}this.dispose();const{marginalWeights:g,conditionalWeights:v}=this;g.image={width:r,height:1,data:f},g.needsUpdate=!0,v.image={width:n,height:r,data:m},v.needsUpdate=!0,this.totalSum=c,this.map=e}}const Km=new Qe,Zm=new Qe,Jm=new Pn,Qm=new Je,tg=new Qe,eg=new Qe,ng=new Qe(0,1,0);class rg{constructor(){const t=new Po(new Float32Array(4),1,1);t.format=at,t.type=tt,t.wrapS=z,t.wrapT=z,t.generateMipmaps=!1,t.minFilter=G,t.magFilter=G,this.tex=t,this.count=0}updateFrom(t,e=[]){const n=this.tex,r=Math.max(6*t.length,1),i=Math.ceil(Math.sqrt(r));n.image.width!==i&&(n.dispose(),n.image.data=new Float32Array(i*i*4),n.image.width=i,n.image.height=i);const a=n.image.data;for(let n=0,r=t.length;n<r;n++){const r=t[n],i=6*n*4;let s=0;for(let t=0;t<24;t++)a[i+t]=0;r.getWorldPosition(Zm),a[i+s++]=Zm.x,a[i+s++]=Zm.y,a[i+s++]=Zm.z;let o=0;if(r.isRectAreaLight&&r.isCircular?o=1:r.isSpotLight?o=2:r.isDirectionalLight?o=3:r.isPointLight&&(o=4),a[i+s++]=o,a[i+s++]=r.color.r,a[i+s++]=r.color.g,a[i+s++]=r.color.b,a[i+s++]=r.intensity,r.getWorldQuaternion(Qm),r.isRectAreaLight)Km.set(r.width,0,0).applyQuaternion(Qm),a[i+s++]=Km.x,a[i+s++]=Km.y,a[i+s++]=Km.z,s++,Zm.set(0,r.height,0).applyQuaternion(Qm),a[i+s++]=Zm.x,a[i+s++]=Zm.y,a[i+s++]=Zm.z,a[i+s++]=Km.cross(Zm).length()*(r.isCircular?Math.PI/4:1);else if(r.isSpotLight){const t=r.radius||0;tg.setFromMatrixPosition(r.matrixWorld),eg.setFromMatrixPosition(r.target.matrixWorld),Jm.lookAt(tg,eg,ng),Qm.setFromRotationMatrix(Jm),Km.set(1,0,0).applyQuaternion(Qm),a[i+s++]=Km.x,a[i+s++]=Km.y,a[i+s++]=Km.z,s++,Zm.set(0,1,0).applyQuaternion(Qm),a[i+s++]=Zm.x,a[i+s++]=Zm.y,a[i+s++]=Zm.z,a[i+s++]=Math.PI*t*t,a[i+s++]=t,a[i+s++]=r.decay,a[i+s++]=r.distance,a[i+s++]=Math.cos(r.angle),a[i+s++]=Math.cos(r.angle*(1-r.penumbra)),a[i+s++]=r.iesMap?e.indexOf(r.iesMap):-1}else if(r.isPointLight){const t=Km.setFromMatrixPosition(r.matrixWorld);a[i+s++]=t.x,a[i+s++]=t.y,a[i+s++]=t.z,s++,s+=4,s+=1,a[i+s++]=r.decay,a[i+s++]=r.distance}else if(r.isDirectionalLight){const t=Km.setFromMatrixPosition(r.matrixWorld),e=Zm.setFromMatrixPosition(r.target.matrixWorld);eg.subVectors(t,e).normalize(),a[i+s++]=eg.x,a[i+s++]=eg.y,a[i+s++]=eg.z}}this.count=t.length;const s=lm(a.buffer);return this.hash!==s&&(this.hash=s,n.needsUpdate=!0,!0)}}function ig(t,e,n,r,i){if(e>r)throw new Error;const a=t.length/e,s=8*t.constructor.BYTES_PER_ELEMENT;let o=1;switch(t.constructor){case Uint8Array:case Uint16Array:case Uint32Array:o=2**s-1;break;case Int8Array:case Int16Array:case Int32Array:o=2**(s-1)-1}for(let s=0;s<a;s++){const a=4*s,l=e*s;for(let s=0;s<r;s++)n[i+a+s]=e>=s+1?t[l+s]/o:0}}class ag extends $e{constructor(){super(),this._textures=[],this.type=tt,this.format=at,this.internalFormat="RGBA32F"}updateAttribute(t,e){const n=this._textures[t];n.updateFrom(e);const r=n.image,i=this.image;if(r.width!==i.width||r.height!==i.height)throw new Error("FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.");const{width:a,height:s,data:o}=i,l=a*s*4*t;let c=e.itemSize;3===c&&(c=4),ig(n.image.data,c,o,4,l),this.dispose(),this.needsUpdate=!0}setAttributes(t){const e=t[0].count,n=t.length;for(let r=0,i=n;r<i;r++)if(t[r].count!==e)throw new Error("FloatAttributeTextureArray: All attributes must have the same item count.");const r=this._textures;for(;r.length<n;){const t=new Vm;r.push(t)}for(;r.length>n;)r.pop();for(let e=0,i=n;e<i;e++)r[e].updateFrom(t[e]);const i=r[0].image,a=this.image;i.width===a.width&&i.height===a.height&&i.depth===n||(a.width=i.width,a.height=i.height,a.depth=n,a.data=new Float32Array(a.width*a.height*a.depth*4));const{data:s,width:o,height:l}=a;for(let e=0,i=n;e<i;e++){const n=r[e],i=o*l*4*e;let a=t[e].itemSize;3===a&&(a=4),ig(n.image.data,a,s,4,i)}this.dispose(),this.needsUpdate=!0}}class sg extends ag{updateNormalAttribute(t){this.updateAttribute(0,t)}updateTangentAttribute(t){this.updateAttribute(1,t)}updateUvAttribute(t){this.updateAttribute(2,t)}updateColorAttribute(t){this.updateAttribute(3,t)}updateFrom(t,e,n,r){this.setAttributes([t,e,n,r])}}function og(t,e){return t.uuid<e.uuid?1:t.uuid>e.uuid?-1:0}function lg(t){return`${t.source.uuid}:${t.colorSpace}`}class cg{constructor(){this._features={}}isUsed(t){return t in this._features}setUsed(t,e=!0){!1===e?delete this._features[t]:this._features[t]=!0}reset(){this._features={}}}class ug extends Po{constructor(){super(new Float32Array(4),1,1),this.format=at,this.type=tt,this.wrapS=z,this.wrapT=z,this.minFilter=G,this.magFilter=G,this.generateMipmaps=!1,this.features=new cg}updateFrom(t,e){function n(t,e,n=-1){if(e in t&&t[e]){const n=lg(t[e]);return u[n]}return n}function r(t,e,n){return e in t?t[e]:n}function i(t,e,n,r){const i=t[e]&&t[e].isTexture?t[e]:null;if(i){i.matrixAutoUpdate&&i.updateMatrix();const t=i.matrix.elements;let e=0;n[r+e++]=t[0],n[r+e++]=t[3],n[r+e++]=t[6],e++,n[r+e++]=t[1],n[r+e++]=t[4],n[r+e++]=t[7],e++}return 8}let a=0;const s=45*t.length,o=Math.ceil(Math.sqrt(s))||1,{image:l,features:c}=this,u={};for(let t=0,n=e.length;t<n;t++)u[lg(e[t])]=t;l.width!==o&&(this.dispose(),l.data=new Float32Array(o*o*4),l.width=o,l.height=o);const h=l.data;c.reset();for(let e=0,s=t.length;e<s;e++){const s=t[e];if(s.isFogVolumeMaterial){c.setUsed("FOG");for(let t=0;t<180;t++)h[a+t]=0;h[a+0+0]=s.color.r,h[a+0+1]=s.color.g,h[a+0+2]=s.color.b,h[a+8+3]=r(s,"emissiveIntensity",0),h[a+12+0]=s.emissive.r,h[a+12+1]=s.emissive.g,h[a+12+2]=s.emissive.b,h[a+52+1]=s.density,h[a+52+3]=0,h[a+56+2]=4,a+=180;continue}h[a++]=s.color.r,h[a++]=s.color.g,h[a++]=s.color.b,h[a++]=n(s,"map"),h[a++]=r(s,"metalness",0),h[a++]=n(s,"metalnessMap"),h[a++]=r(s,"roughness",0),h[a++]=n(s,"roughnessMap"),h[a++]=r(s,"ior",1.5),h[a++]=r(s,"transmission",0),h[a++]=n(s,"transmissionMap"),h[a++]=r(s,"emissiveIntensity",0),"emissive"in s?(h[a++]=s.emissive.r,h[a++]=s.emissive.g,h[a++]=s.emissive.b):(h[a++]=0,h[a++]=0,h[a++]=0),h[a++]=n(s,"emissiveMap"),h[a++]=n(s,"normalMap"),"normalScale"in s?(h[a++]=s.normalScale.x,h[a++]=s.normalScale.y):(h[a++]=1,h[a++]=1),h[a++]=r(s,"clearcoat",0),h[a++]=n(s,"clearcoatMap"),h[a++]=r(s,"clearcoatRoughness",0),h[a++]=n(s,"clearcoatRoughnessMap"),h[a++]=n(s,"clearcoatNormalMap"),"clearcoatNormalScale"in s?(h[a++]=s.clearcoatNormalScale.x,h[a++]=s.clearcoatNormalScale.y):(h[a++]=1,h[a++]=1),a++,h[a++]=r(s,"sheen",0),"sheenColor"in s?(h[a++]=s.sheenColor.r,h[a++]=s.sheenColor.g,h[a++]=s.sheenColor.b):(h[a++]=0,h[a++]=0,h[a++]=0),h[a++]=n(s,"sheenColorMap"),h[a++]=r(s,"sheenRoughness",0),h[a++]=n(s,"sheenRoughnessMap"),h[a++]=n(s,"iridescenceMap"),h[a++]=n(s,"iridescenceThicknessMap"),h[a++]=r(s,"iridescence",0),h[a++]=r(s,"iridescenceIOR",1.3);const o=r(s,"iridescenceThicknessRange",[100,400]);h[a++]=o[0],h[a++]=o[1],"specularColor"in s?(h[a++]=s.specularColor.r,h[a++]=s.specularColor.g,h[a++]=s.specularColor.b):(h[a++]=1,h[a++]=1,h[a++]=1),h[a++]=n(s,"specularColorMap"),h[a++]=r(s,"specularIntensity",1),h[a++]=n(s,"specularIntensityMap");const l=0===r(s,"thickness",0)&&r(s,"attenuationDistance",1/0)===1/0;if(h[a++]=Number(l),a++,"attenuationColor"in s?(h[a++]=s.attenuationColor.r,h[a++]=s.attenuationColor.g,h[a++]=s.attenuationColor.b):(h[a++]=1,h[a++]=1,h[a++]=1),h[a++]=r(s,"attenuationDistance",1/0),h[a++]=n(s,"alphaMap"),h[a++]=s.opacity,h[a++]=s.alphaTest,!l&&s.transmission>0)h[a++]=0;else switch(s.side){case 0:h[a++]=1;break;case 1:h[a++]=-1;break;case 2:h[a++]=0}h[a++]=Number(r(s,"matte",!1)),h[a++]=Number(r(s,"castShadow",!0)),h[a++]=Number(s.vertexColors)|Number(s.flatShading)<<1,h[a++]=Number(s.transparent),a+=i(s,"map",h,a),a+=i(s,"metalnessMap",h,a),a+=i(s,"roughnessMap",h,a),a+=i(s,"transmissionMap",h,a),a+=i(s,"emissiveMap",h,a),a+=i(s,"normalMap",h,a),a+=i(s,"clearcoatMap",h,a),a+=i(s,"clearcoatNormalMap",h,a),a+=i(s,"clearcoatRoughnessMap",h,a),a+=i(s,"sheenColorMap",h,a),a+=i(s,"sheenRoughnessMap",h,a),a+=i(s,"iridescenceMap",h,a),a+=i(s,"iridescenceThicknessMap",h,a),a+=i(s,"specularColorMap",h,a),a+=i(s,"specularIntensityMap",h,a)}const d=lm(h.buffer);return this.hash!==d&&(this.hash=d,this.needsUpdate=!0,!0)}}const hg=new wr;function dg(t){return t?`${t.uuid}:${t.version}`:null}class pg extends Ke{constructor(t,e,n){const r={format:at,type:Y,minFilter:j,magFilter:j,wrapS:k,wrapT:k,generateMipmaps:!1,...n};super(t,e,1,r),function(t,e){for(const n in e)n in t&&(t[n]=e[n])}(this.texture,r),this.texture.setTextures=(...t)=>{this.setTextures(...t)},this.hashes=[null];const i=new Im(new fg);this.fsQuad=i}setTextures(t,e,n=this.width,r=this.height){const i=t.getRenderTarget(),a=t.toneMapping,s=t.getClearAlpha();t.getClearColor(hg);const o=e.length||1;n===this.width&&r===this.height&&this.depth===o||(this.setSize(n,r,o),this.hashes=new Array(o).fill(null)),t.setClearColor(0,0),t.toneMapping=0;const l=this.fsQuad,c=this.hashes;let u=!1;for(let n=0,r=o;n<r;n++){const r=e[n],i=dg(r);r&&(c[n]!==i||r.isWebGLRenderTarget)&&(r.matrixAutoUpdate=!1,r.matrix.identity(),l.material.map=r,t.setRenderTarget(this,n),l.render(t),r.updateMatrix(),r.matrixAutoUpdate=!0,c[n]=i,u=!0)}return l.material.map=null,t.setClearColor(hg,s),t.setRenderTarget(i),t.toneMapping=a,u}dispose(){super.dispose(),this.fsQuad.dispose()}}class fg extends li{get map(){return this.uniforms.map.value}set map(t){this.uniforms.map.value=t}constructor(){super({uniforms:{map:{value:null}},vertexShader:"\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUv );\n\n\t\t\t\t}\n\t\t\t"})}}class mg{constructor(t,e,n=Math.random){const r=t**e,i=new Uint16Array(r);let a=r;for(let t=0;t<r;t++)i[t]=t;this.samples=new Float32Array(e),this.strataCount=t,this.reset=function(){for(let t=0;t<r;t++)i[t]=t;a=0},this.reshuffle=function(){a=0},this.next=function(){const{samples:r}=this;a>=i.length&&(function(t,e=Math.random()){for(let n=t.length-1;n>0;n--){const r=Math.floor(e()*(n+1)),i=t[n];t[n]=t[r],t[r]=i}}(i,n),this.reshuffle());let s=i[a++];for(let i=0;i<e;i++)r[i]=(s%t+n())/t,s=Math.floor(s/t);return r}}}class gg{constructor(t,e,n=Math.random){let r=0;for(const t of e)r+=t;const i=new Float32Array(r),a=[];let s=0;for(const r of e){const e=new mg(t,r,n);e.samples=new Float32Array(i.buffer,s,e.samples.length),s+=4*e.samples.length,a.push(e)}this.samples=i,this.strataCount=t,this.next=function(){for(const t of a)t.next();return i},this.reshuffle=function(){for(const t of a)t.reshuffle()},this.reset=function(){for(const t of a)t.reset()}}}class vg{constructor(t=0){this.m=2147483648,this.a=1103515245,this.c=12345,this.seed=t}nextInt(){return this.seed=(this.a*this.seed+this.c)%this.m,this.seed}nextFloat(){return this.nextInt()/(this.m-1)}}class _g extends Po{constructor(t=1,e=1,n=8){super(new Float32Array(1),1,1,at,tt),this.minFilter=G,this.magFilter=G,this.strata=n,this.sampler=null,this.generator=new vg,this.stableNoise=!1,this.random=()=>this.stableNoise?this.generator.nextFloat():Math.random(),this.init(t,e,n)}init(t=this.image.height,e=this.image.width,n=this.strata){const{image:r}=this;if(r.width===e&&r.height===t&&null!==this.sampler)return;const i=new Array(t*e).fill(4),a=new gg(n,i,this.random);r.width=e,r.height=t,r.data=a.samples,this.sampler=a,this.dispose(),this.next()}next(){this.sampler.next(),this.needsUpdate=!0}reset(){this.sampler.reset(),this.generator.seed=0}}class yg{constructor(t){this.count=0,this.size=-1,this.sigma=-1,this.radius=-1,this.lookupTable=null,this.score=null,this.binaryPattern=null,this.resize(t),this.setSigma(1.5)}findVoid(){const{score:t,binaryPattern:e}=this;let n=1/0,r=-1;for(let i=0,a=e.length;i<a;i++){if(0!==e[i])continue;const a=t[i];a<n&&(n=a,r=i)}return r}findCluster(){const{score:t,binaryPattern:e}=this;let n=-1/0,r=-1;for(let i=0,a=e.length;i<a;i++){if(1!==e[i])continue;const a=t[i];a>n&&(n=a,r=i)}return r}setSigma(t){if(t===this.sigma)return;const e=~~(Math.sqrt(20*t**2)+1),n=2*e+1,r=new Float32Array(n*n),i=t*t;for(let t=-e;t<=e;t++)for(let a=-e;a<=e;a++){const s=t*t+a*a;r[(e+a)*n+t+e]=Math.E**(-s/(2*i))}this.lookupTable=r,this.sigma=t,this.radius=e}resize(t){this.size!==t&&(this.size=t,this.score=new Float32Array(t*t),this.binaryPattern=new Uint8Array(t*t))}invert(){const{binaryPattern:t,score:e,size:n}=this;e.fill(0);for(let e=0,r=t.length;e<r;e++)if(0===t[e]){const r=~~(e/n),i=e-r*n;this.updateScore(i,r,1),t[e]=1}else t[e]=0}updateScore(t,e,n){const{size:r,score:i,lookupTable:a}=this,s=this.radius,o=2*s+1;for(let l=-s;l<=s;l++)for(let c=-s;c<=s;c++){const u=a[(s+c)*o+l+s];let h=t+l;h=h<0?r+h:h%r;let d=e+c;d=d<0?r+d:d%r,i[d*r+h]+=n*u}}addPointIndex(t){this.binaryPattern[t]=1;const e=this.size,n=~~(t/e),r=t-n*e;this.updateScore(r,n,1),this.count++}removePointIndex(t){this.binaryPattern[t]=0;const e=this.size,n=~~(t/e),r=t-n*e;this.updateScore(r,n,-1),this.count--}copy(t){this.resize(t.size),this.score.set(t.score),this.binaryPattern.set(t.binaryPattern),this.setSigma(t.sigma),this.count=t.count}}class xg{constructor(){this.random=Math.random,this.sigma=1.5,this.size=64,this.majorityPointsRatio=.1,this.samples=new yg(1),this.savedSamples=new yg(1)}generate(){const{samples:t,savedSamples:e,sigma:n,majorityPointsRatio:r,size:i}=this;t.resize(i),t.setSigma(n);const a=Math.floor(i*i*r),s=t.binaryPattern;!function(t,e){t.fill(0);for(let n=0;n<e;n++)t[n]=1}(s,a),function(t,e=Math.random){for(let n=t.length-1;n>0;n--){const r=~~((e()-1e-6)*n),i=t[n];t[n]=t[r],t[r]=i}}(s,this.random);for(let e=0,n=s.length;e<n;e++)1===s[e]&&t.addPointIndex(e);for(;;){const e=t.findCluster();t.removePointIndex(e);const n=t.findVoid();if(e===n){t.addPointIndex(e);break}t.addPointIndex(n)}const o=new Uint32Array(i*i);let l;for(e.copy(t),l=t.count-1;l>=0;){const e=t.findCluster();t.removePointIndex(e),o[e]=l,l--}const c=i*i;for(l=e.count;l<c/2;){const t=e.findVoid();e.addPointIndex(t),o[t]=l,l++}for(e.invert();l<c;){const t=e.findCluster();e.removePointIndex(t),o[t]=l,l++}return{data:o,maxValue:c}}}class bg extends Po{constructor(t=64,e=1){super(new Float32Array(4),1,1,at,tt),this.minFilter=G,this.magFilter=G,this.size=t,this.channels=e,this.update()}update(){const t=this.channels,e=this.size,n=new xg;n.channels=t,n.size=e;const r=function(t){return t>=3?4:t}(t),i=function(t){switch(t){case 1:return lt;case 2:return ut;default:return at}}(r);this.image.width===e&&i===this.format||(this.image.width=e,this.image.height=e,this.image.data=new Float32Array(e**2*r),this.format=i,this.dispose());const a=this.image.data;for(let e=0,i=t;e<i;e++){const t=n.generate(),i=t.data,s=t.maxValue;for(let t=0,n=i.length;t<n;t++){const n=i[t]/s;a[t*r+e]=n}}this.needsUpdate=!0}}const wg="\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n",Mg="\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 WHITE_NOISE_SEED;\n\n\tvoid rng_initialize( vec2 p, int frame ) {\n\n\t\t// white noise seed\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat pcgRand() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 pcgRand2() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 pcgRand3() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 pcgRand4() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\n\n\t}\n";class Tg extends Lm{onBeforeRender(){this.setDefine("FEATURE_DOF",0===this.physicalCamera.bokehSize?0:1),this.setDefine("FEATURE_BACKGROUND_MAP",this.backgroundMap?1:0),this.setDefine("FEATURE_FOG",this.materials.features.isUsed("FOG")?1:0)}constructor(t){super({transparent:!0,depthWrite:!1,defines:{FEATURE_MIS:1,FEATURE_RUSSIAN_ROULETTE:1,FEATURE_DOF:1,FEATURE_BACKGROUND_MAP:0,FEATURE_FOG:1,RANDOM_TYPE:2,CAMERA_TYPE:0,DEBUG_MODE:0,ATTR_NORMAL:0,ATTR_TANGENT:1,ATTR_UV:2,ATTR_COLOR:3},uniforms:{resolution:{value:new Me},opacity:{value:1},bounces:{value:10},transmissiveBounces:{value:10},filterGlossyFactor:{value:0},physicalCamera:{value:new qm},cameraWorldMatrix:{value:new Pn},invProjectionMatrix:{value:new Pn},bvh:{value:new Wm},attributesArray:{value:new sg},materialIndexAttribute:{value:new Gm},materials:{value:new ug},textures:{value:(new pg).texture},lights:{value:new rg},iesProfiles:{value:new pg(360,180,{type:et,wrapS:z,wrapT:z}).texture},environmentIntensity:{value:1},environmentRotation:{value:new Pn},envMapInfo:{value:new $m},backgroundBlur:{value:0},backgroundMap:{value:null},backgroundAlpha:{value:1},backgroundIntensity:{value:1},backgroundRotation:{value:new Pn},seed:{value:0},sobolTexture:{value:null},stratifiedTexture:{value:new _g},stratifiedOffsetTexture:{value:new bg(64,1)}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\t\t\t\t#define INFINITY 1e20\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t// bvh intersection\n\t\t\t\t\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\n\t\t\t\t\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n\n\t\t\t\t\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\tbvhIntersectFirstHit(\t\tbvh,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\t_bvhIntersectFirstHit(\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\n\n\t\t\t\t// uniform structs\n\t\t\t\t\n\n\tstruct PhysicalCamera {\n\n\t\tfloat focusDistance;\n\t\tfloat anamorphicRatio;\n\t\tfloat bokehSize;\n\t\tint apertureBlades;\n\t\tfloat apertureRotation;\n\n\t};\n\n\n\t\t\t\t\n\n\t#define RECT_AREA_LIGHT_TYPE 0\n\t#define CIRC_AREA_LIGHT_TYPE 1\n\t#define SPOT_LIGHT_TYPE 2\n\t#define DIR_LIGHT_TYPE 3\n\t#define POINT_LIGHT_TYPE 4\n\n\tstruct LightsInfo {\n\n\t\tsampler2D tex;\n\t\tuint count;\n\n\t};\n\n\tstruct Light {\n\n\t\tvec3 position;\n\t\tint type;\n\n\t\tvec3 color;\n\t\tfloat intensity;\n\n\t\tvec3 u;\n\t\tvec3 v;\n\t\tfloat area;\n\n\t\t// spot light fields\n\t\tfloat radius;\n\t\tfloat near;\n\t\tfloat decay;\n\t\tfloat distance;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint iesProfile;\n\n\t};\n\n\tLight readLightInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 6u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\n\t\tLight l;\n\t\tl.position = s0.rgb;\n\t\tl.type = int( round( s0.a ) );\n\n\t\tl.color = s1.rgb;\n\t\tl.intensity = s1.a;\n\n\t\tl.u = s2.rgb;\n\t\tl.v = s3.rgb;\n\t\tl.area = s3.a;\n\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\t\tl.radius = s4.r;\n\t\t\tl.decay = s4.g;\n\t\t\tl.distance = s4.b;\n\t\t\tl.coneCos = s4.a;\n\n\t\t\tl.penumbraCos = s5.r;\n\t\t\tl.iesProfile = int( round( s5.g ) );\n\n\t\t} else {\n\n\t\t\tl.radius = 0.0;\n\t\t\tl.decay = 0.0;\n\t\t\tl.distance = 0.0;\n\n\t\t\tl.coneCos = 0.0;\n\t\t\tl.penumbraCos = 0.0;\n\t\t\tl.iesProfile = - 1;\n\n\t\t}\n\n\t\treturn l;\n\n\t}\n\n\n\t\t\t\t\n\n\tstruct EquirectHdrInfo {\n\n\t\tsampler2D marginalWeights;\n\t\tsampler2D conditionalWeights;\n\t\tsampler2D map;\n\n\t\tfloat totalSum;\n\n\t};\n\n\n\t\t\t\t\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tfloat clearcoat;\n\t\tint clearcoatMap;\n\t\tint clearcoatNormalMap;\n\t\tvec2 clearcoatNormalScale;\n\t\tfloat clearcoatRoughness;\n\t\tint clearcoatRoughnessMap;\n\n\t\tint iridescenceMap;\n\t\tint iridescenceThicknessMap;\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThicknessMinimum;\n\t\tfloat iridescenceThicknessMaximum;\n\n\t\tvec3 specularColor;\n\t\tint specularColorMap;\n\n\t\tfloat specularIntensity;\n\t\tint specularIntensityMap;\n\t\tbool thinFilm;\n\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\tint alphaMap;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tint sheenColorMap;\n\t\tfloat sheenRoughness;\n\t\tint sheenRoughnessMap;\n\n\t\tbool vertexColors;\n\t\tbool flatShading;\n\t\tbool transparent;\n\t\tbool fogVolume;\n\n\t\tmat3 mapTransform;\n\t\tmat3 metalnessMapTransform;\n\t\tmat3 roughnessMapTransform;\n\t\tmat3 transmissionMapTransform;\n\t\tmat3 emissiveMapTransform;\n\t\tmat3 normalMapTransform;\n\t\tmat3 clearcoatMapTransform;\n\t\tmat3 clearcoatNormalMapTransform;\n\t\tmat3 clearcoatRoughnessMapTransform;\n\t\tmat3 sheenColorMapTransform;\n\t\tmat3 sheenRoughnessMapTransform;\n\t\tmat3 iridescenceMapTransform;\n\t\tmat3 iridescenceThicknessMapTransform;\n\t\tmat3 specularColorMapTransform;\n\t\tmat3 specularIntensityMapTransform;\n\n\t};\n\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\n\n\t\tmat3 textureTransform;\n\n\t\tvec4 row1 = texelFetch1D( tex, index );\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\n\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\n\n\t\treturn textureTransform;\n\n\t}\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 45u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.clearcoat = s4.a;\n\t\tm.clearcoatMap = int( round( s5.r ) );\n\t\tm.clearcoatRoughness = s5.g;\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\n\t\tm.clearcoatNormalScale = s6.rg;\n\n\t\tm.sheen = s6.a;\n\t\tm.sheenColor = s7.rgb;\n\t\tm.sheenColorMap = int( round( s7.a ) );\n\t\tm.sheenRoughness = s8.r;\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\n\n\t\tm.iridescenceMap = int( round( s8.b ) );\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\n\t\tm.iridescence = s9.r;\n\t\tm.iridescenceIor = s9.g;\n\t\tm.iridescenceThicknessMinimum = s9.b;\n\t\tm.iridescenceThicknessMaximum = s9.a;\n\n\t\tm.specularColor = s10.rgb;\n\t\tm.specularColorMap = int( round( s10.a ) );\n\n\t\tm.specularIntensity = s11.r;\n\t\tm.specularIntensityMap = int( round( s11.g ) );\n\t\tm.thinFilm = bool( s11.b );\n\n\t\tm.attenuationColor = s12.rgb;\n\t\tm.attenuationDistance = s12.a;\n\n\t\tm.alphaMap = int( round( s13.r ) );\n\n\t\tm.opacity = s13.g;\n\t\tm.alphaTest = s13.b;\n\t\tm.side = s13.a;\n\n\t\tm.matte = bool( s14.r );\n\t\tm.castShadow = bool( s14.g );\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\n\t\tm.transparent = bool( s14.a );\n\n\t\tuint firstTextureTransformIdx = i + 15u;\n\n\t\t// mat3( 1.0 ) is an identity matrix\n\t\tm.mapTransform = m.map == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx );\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\n\n\t\treturn m;\n\n\t}\n\n\n\t\t\t\t\n\n\tstruct SurfaceRecord {\n\n\t\t// surface type\n\t\tbool volumeParticle;\n\n\t\t// geometry\n\t\tvec3 faceNormal;\n\t\tbool frontFace;\n\t\tvec3 normal;\n\t\tmat3 normalBasis;\n\t\tmat3 normalInvBasis;\n\n\t\t// cached properties\n\t\tfloat eta;\n\t\tfloat f0;\n\n\t\t// material\n\t\tfloat roughness;\n\t\tfloat filteredRoughness;\n\t\tfloat metalness;\n\t\tvec3 color;\n\t\tvec3 emission;\n\n\t\t// transmission\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tbool thinFilm;\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\t// clearcoat\n\t\tvec3 clearcoatNormal;\n\t\tmat3 clearcoatBasis;\n\t\tmat3 clearcoatInvBasis;\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tfloat filteredClearcoatRoughness;\n\n\t\t// sheen\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\n\t\t// iridescence\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThickness;\n\n\t\t// specular\n\t\tvec3 specularColor;\n\t\tfloat specularIntensity;\n\t};\n\n\tstruct ScatterRecord {\n\t\tfloat specularPdf;\n\t\tfloat pdf;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\n\n\t\t\t\t// random\n\t\t\t\t#if RANDOM_TYPE == 2 \t// Stratified List\n\n\t\t\t\t\t\n\n\tuniform sampler2D stratifiedTexture;\n\tuniform sampler2D stratifiedOffsetTexture;\n\n\tuint sobolPixelIndex = 0u;\n\tuint sobolPathIndex = 0u;\n\tuint sobolBounceIndex = 0u;\n\tvec4 pixelSeed = vec4( 0 );\n\n\tvec4 rand4( int v ) {\n\n\t\tivec2 uv = ivec2( v, sobolBounceIndex );\n\t\tvec4 stratifiedSample = texelFetch( stratifiedTexture, uv, 0 );\n\t\treturn fract( stratifiedSample + pixelSeed.r ); // blue noise + stratified samples\n\n\t}\n\n\tvec3 rand3( int v ) {\n\n\t\treturn rand4( v ).xyz;\n\n\t}\n\n\tvec2 rand2( int v ) {\n\n\t\treturn rand4( v ).xy;\n\n\t}\n\n\tfloat rand( int v ) {\n\n\t\treturn rand4( v ).x;\n\n\t}\n\n\tvoid rng_initialize( vec2 screenCoord, int frame ) {\n\n\t\t// tile the small noise texture across the entire screen\n\t\tivec2 noiseSize = ivec2( textureSize( stratifiedOffsetTexture, 0 ) );\n\t\tivec2 pixel = ivec2( screenCoord.xy ) % noiseSize;\n\t\tvec2 pixelWidth = 1.0 / vec2( noiseSize );\n\t\tvec2 uv = vec2( pixel ) * pixelWidth + pixelWidth * 0.5;\n\n\t\t// note that using "texelFetch" here seems to break Android for some reason\n\t\tpixelSeed = texture( stratifiedOffsetTexture, uv );\n\n\t}\n\n\n\n\t\t\t\t#elif RANDOM_TYPE == 1 \t// Sobol\n\n\t\t\t\t\t${Mg}\n\t\t\t\t\t${Um}\n\t\t\t\t\t${Fm}\n\n\t\t\t\t\t#define rand(v) sobol(v)\n\t\t\t\t\t#define rand2(v) sobol2(v)\n\t\t\t\t\t#define rand3(v) sobol3(v)\n\t\t\t\t\t#define rand4(v) sobol4(v)\n\n\t\t\t\t#else \t\t\t\t\t// PCG\n\n\t\t\t\t${Mg}\n\n\t\t\t\t\t// Using the sobol functions seems to break the the compiler on MacOS\n\t\t\t\t\t// - specifically the "sobolReverseBits" function.\n\t\t\t\t\tuint sobolPixelIndex = 0u;\n\t\t\t\t\tuint sobolPathIndex = 0u;\n\t\t\t\t\tuint sobolBounceIndex = 0u;\n\n\t\t\t\t\t#define rand(v) pcgRand()\n\t\t\t\t\t#define rand2(v) pcgRand2()\n\t\t\t\t\t#define rand3(v) pcgRand3()\n\t\t\t\t\t#define rand4(v) pcgRand4()\n\n\t\t\t\t#endif\n\n\t\t\t\t// common\n\t\t\t\t\n\n\t// add texel fetch functions for texture arrays\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\n\n\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\tuvec2 uv;\n\t\tuv.x = index % width;\n\t\tuv.y = index / width;\n\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\n\n\t}\n\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\n\n\t\treturn\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\n\n\t}\n\n\n\t\t\t\t\n\n\tbool totalInternalReflection( float cosTheta, float eta ) {\n\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\treturn eta * sinTheta > 1.0;\n\n\t}\n\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\n\tfloat schlickFresnel( float cosine, float f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\n\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat ni = eta;\n\t\tfloat nt = 1.0;\n\n\t\t// Check for total internal reflection\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\n\t\tif( sinThetaTSq >= 1.0 ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\n\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\n\n\t}\n\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\n\tfloat iorRatioToF0( float eta ) {\n\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\n\n\t}\n\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn f90;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\n\n\t}\n\n\t// TODO: disney fresnel was removed and replaced with this fresnel function to better align with\n\t// the glTF but is causing blown out pixels. Should be revisited\n\t// float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\n\n\t// \tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t// \t\treturn 1.0;\n\n\t// \t}\n\n\t// \treturn schlickFresnel( cosTheta, f0 );\n\n\t// }\n\n\t// https://schuttejoe.github.io/post/disneybsdf/\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\n\n\t\tfloat dotHV = dot( wo, wh );\n\t\tif ( totalInternalReflection( dotHV, eta ) ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat dotHL = dot( wi, wh );\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\n\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\n\n\t}\n\n\n\t\t\t\t${wg}\n\t\t\t\t\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n\n\t\t\t\t\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the rectangle on that same plane.\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\n\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = p - center;\n\n\t\t\t// check if p falls inside the rectangle\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\n\n\t\t\t\tfloat a2 = dot( v, vi );\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\n\n\t\t\t\t\tdist = t;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\n\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = hit - position;\n\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tfloat a2 = dot( v, vi );\n\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\n\n\t\t\t\tdist = t;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\n\t\t\t\t// environment\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\t\t\t\tuniform mat4 environmentRotation;\n\t\t\t\tuniform float environmentIntensity;\n\n\t\t\t\t// lighting\n\t\t\t\tuniform sampler2DArray iesProfiles;\n\t\t\t\tuniform LightsInfo lights;\n\n\t\t\t\t// background\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\tuniform sampler2D backgroundMap;\n\t\t\t\tuniform mat4 backgroundRotation;\n\t\t\t\tuniform float backgroundIntensity;\n\n\t\t\t\t#endif\n\n\t\t\t\t// camera\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\t// geometry\n\t\t\t\tuniform sampler2DArray attributesArray;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tuniform BVH bvh;\n\n\t\t\t\t// path tracer\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform int transmissiveBounces;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\n\t\t\t\t// image\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t// globals\n\t\t\t\tmat3 envRotation3x3;\n\t\t\t\tmat3 invEnvRotation3x3;\n\t\t\t\tfloat lightsDenom;\n\n\t\t\t\t// sampling\n\t\t\t\t\n\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick the point in the parallelogram\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\tvec2 sampleCircle( vec2 uv ) {\n\n\t\tfloat angle = 2.0 * PI * uv.x;\n\t\tfloat radius = sqrt( uv.y );\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t}\n\n\tvec3 sampleSphere( vec2 uv ) {\n\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\n\t\tfloat t = uv.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\n\n\t\tsides = max( sides, 3 );\n\n\t\tvec3 r = uvw;\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\n\t\tfloat segment = floor( float( sides ) * r.x );\n\n\t\tfloat angle1 = anglePerSegment * segment;\n\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\treturn sampleTriangle( a, b, c, r.yz );\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\n\n\t\treturn blades == 0 ?\n\t\t\tsampleCircle( uvw.xy ) :\n\t\t\tsampleRegularPolygon( blades, uvw );\n\n\t}\n\n\n\n\t\t\t\t\n\n\t// samples the the given environment map in the given direction\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\n\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\n\n\t}\n\n\t// gets the pdf of the given direction to sample\n\tfloat equirectDirectionPdf( vec3 direction ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tfloat theta = uv.y * PI;\n\t\tfloat sinTheta = sin( theta );\n\t\tif ( sinTheta == 0.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n\t}\n\n\t// samples the color given env map with CDF and returns the pdf of the direction\n\tfloat sampleEquirect( vec3 direction, inout vec3 color ) {\n\n\t\tfloat totalSum = envMapInfo.totalSum;\n\t\tif ( totalSum == 0.0 ) {\n\n\t\t\tcolor = vec3( 0.0 );\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\n\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\t// samples a direction of the envmap with color and retrieves pdf\n\tfloat sampleEquirectProbability( vec2 r, inout vec3 color, inout vec3 direction ) {\n\n\t\t// sample env map cdf\n\t\tfloat v = texture2D( envMapInfo.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\t\tfloat u = texture2D( envMapInfo.conditionalWeights, vec2( r.y, v ) ).x;\n\t\tvec2 uv = vec2( u, v );\n\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\n\t\tdirection = derivedDirection;\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\n\n\t\tfloat totalSum = envMapInfo.totalSum;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\t\t\t\t\n\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n\t}\n\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t}\n\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\n\n\t\tfloat cosTheta = dot( posToLight, lightDir );\n\t\tfloat angle = acos( cosTheta ) / PI;\n\n\t\treturn texture2D( iesProfiles, vec3( angle, 0.0, iesProfile ) ).r;\n\n\t}\n\n\tstruct LightRecord {\n\n\t\tfloat dist;\n\t\tvec3 direction;\n\t\tfloat pdf;\n\t\tvec3 emission;\n\t\tint type;\n\n\t};\n\n\tbool intersectLightAtIndex( sampler2D lights, vec3 rayOrigin, vec3 rayDirection, uint l, inout LightRecord lightRec ) {\n\n\t\tbool didHit = false;\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\n\t\t// check for backface\n\t\tvec3 normal = normalize( cross( u, v ) );\n\t\tif ( dot( normal, rayDirection ) > 0.0 ) {\n\n\t\t\tu *= 1.0 / dot( u, u );\n\t\t\tv *= 1.0 / dot( v, v );\n\n\t\t\tfloat dist;\n\n\t\t\t// MIS / light intersection is not supported for punctual lights.\n\t\t\tif(\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\n\t\t\t) {\n\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\tdidHit = true;\n\t\t\t\tlightRec.dist = dist;\n\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\tlightRec.emission = light.color * light.intensity;\n\t\t\t\tlightRec.direction = rayDirection;\n\t\t\t\tlightRec.type = light.type;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn didHit;\n\n\t}\n\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tvec3 randomPos;\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\n\n\t\t\t// rectangular area light\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\n\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\n\n\t\t\t// circular area light\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\t\tfloat x = r * cos( theta );\n\t\t\tfloat y = r * sin( theta );\n\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\n\n\t\t}\n\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\t\tvec3 direction = toLight / dist;\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.emission = light.color * light.intensity;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\n\t\t// TODO: the denominator is potentially zero\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tfloat radius = light.radius * sqrt( ruv.x );\n\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\tfloat x = radius * cos( theta );\n\t\tfloat y = radius * sin( theta );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\t\tvec3 normal = normalize( cross( u, v ) );\n\n\t\tfloat angle = acos( light.coneCos );\n\t\tfloat angleTan = tan( angle );\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\n\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / max( dist, EPSILON );\n\t\tfloat cosTheta = dot( direction, normal );\n\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\n\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\n\t\tlightRec.pdf = 1.0;\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\n\n\t\tLightRecord result;\n\n\t\t// pick a random light\n\t\tuint l = uint( ruv.x * float( lightCount ) );\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\n\n\t\t\tresult = randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\n\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec3 lightRay = light.u - rayOrigin;\n\t\t\tfloat lightDist = length( lightRay );\n\t\t\tfloat cutoffDistance = light.distance;\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\n\t\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\n\n\t\t\t}\n\n\t\t\tLightRecord rec;\n\t\t\trec.direction = normalize( lightRay );\n\t\t\trec.dist = length( lightRay );\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\n\t\t\trec.type = light.type;\n\t\t\tresult = rec;\n\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\n\n\t\t\tLightRecord rec;\n\t\t\trec.dist = 1e10;\n\t\t\trec.direction = light.u;\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity;\n\t\t\trec.type = light.type;\n\n\t\t\tresult = rec;\n\n\t\t} else {\n\n\t\t\t// sample the light\n\t\t\tresult = randomAreaLightSample( light, rayOrigin, ruv.yz );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\n\n\t\t\t\t\n\n#ifndef FOG_CHECK_ITERATIONS\n#define FOG_CHECK_ITERATIONS 30\n#endif\n\n// returns whether the given material is a fog material or not\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\n\n\tuint i = materialIndex * 45u;\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\n\treturn bool( int( s14.b ) & 4 );\n\n}\n\n// returns true if we're within the first fog volume we hit\nbool bvhIntersectFogVolumeHit(\n\tvec3 rayOrigin, vec3 rayDirection,\n\tusampler2D materialIndexAttribute, sampler2D materials,\n\tinout Material material\n) {\n\n\tmaterial.fogVolume = false;\n\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\n\n\t\t// find nearest hit\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tif ( hit ) {\n\n\t\t\t// if it's a fog volume return whether we hit the front or back face\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\n\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\n\t\t\t\treturn side == - 1.0;\n\n\t\t\t} else {\n\n\t\t\t\t// move the ray forward\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n\n\t\t\t\t\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n\n\t\t\t\t\n\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetD( float cosThetaH, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat invAlpha = 1.0 / alpha;\n\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n\t}\n\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n\t}\n\n\tfloat velvetL( float x, float alpha ) {\n\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n\t}\n\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetLambda( float cosTheta, float alpha ) {\n\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n\t}\n\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n\t}\n\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\t\tcosTheta = saturate( cosTheta );\n\n\t\tfloat c = 1.0 - cosTheta;\n\t\tfloat c3 = c * c * c;\n\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n\t}\n\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n\t}\n\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\t\treturn 1.0 - maxSheenColor * eWo;\n\n\t}\n\n\n\t\t\t\t\n\n\t// XYZ to sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\t\treturn srgb;\n\n\t}\n\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\treturn vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIor < outsideIOR ) {\n\n\t\t\tphi12 = PI;\n\n\t\t}\n\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\t\tphi23[ 0 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\t\tphi23[ 1 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\t\tphi23[ 2 ] = PI;\n\n\t\t}\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n\n\t\t\t\t\n\n\t// returns the hit distance given the material density\n\tfloat intersectFogVolume( Material material, float u ) {\n\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\n\n\t}\n\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\n\n\t\tScatterRecord sampleRec;\n\t\tsampleRec.specularPdf = 0.0;\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\n\t\tsampleRec.direction = sampleSphere( uv );\n\t\tsampleRec.color = surf.color;\n\t\treturn sampleRec;\n\n\t}\n\n\n\t\t\t\t\n\n\t// diffuse\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\n\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\n\n\t\t// TODO: subsurface approx?\n\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\n\n\t\treturn wi.z / PI;\n\n\t}\n\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tvec3 lightDirection = sampleSphere( rand2( 11 ) );\n\t\tlightDirection.z += 1.0;\n\t\tlightDirection = normalize( lightDirection );\n\n\t\treturn lightDirection;\n\n\t}\n\n\t// specular\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\n\t\tfloat metalness = surf.metalness;\n\t\tfloat roughness = surf.filteredRoughness;\n\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\n\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\n\n\t\t// PDF\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\n\t\tfloat incidentTheta = acos( wo.z );\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\n\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\n\n\t}\n\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\trand2( 12 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\n\t// transmission\n\t/*\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\t\tbool thinFilm = surf.thinFilm;\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( filteredRoughness ),\n\t\t\trand2( 13 )\n\t\t);\n\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\n\t\treturn normalize( lightDirection );\n\n\t}\n\t*/\n\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\t// PDF\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\t// float F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\t\t// if ( F >= 1.0 ) {\n\n\t\t// \treturn 0.0;\n\n\t\t// }\n\n\t\t// return 1.0 / ( 1.0 - F );\n\n\t\t// reverted to previous to transmission. The above was causing black pixels\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\t\tfloat cosTheta = min( wo.z, 1.0 );\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\tfloat reflectance = schlickFresnel( cosTheta, f0 );\n\t\tbool cannotRefract = eta * sinTheta > 1.0;\n\t\tif ( cannotRefract ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 1.0 - reflectance );\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( rand2( 13 ) ) * roughness );\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\t\treturn normalize( lightDirection );\n\n\t}\n\n\t// clearcoat\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tfloat ior = 1.5;\n\t\tfloat f0 = iorRatioToF0( ior );\n\t\tbool frontFace = surf.frontFace;\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\n\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n\t\t// PDF\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\n\n\t}\n\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\trand2( 14 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\t// sheen\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\n\n\t\tfloat cosThetaO = saturateCos( wo.z );\n\t\tfloat cosThetaI = saturateCos( wi.z );\n\t\tfloat cosThetaH = wh.z;\n\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\t\tvec3 color = surf.sheenColor;\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\t\tcolor *= wi.z;\n\n\t\treturn color;\n\n\t}\n\n\t// bsdf\n\tvoid getLobeWeights(\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\n\t\tinout float diffuseWeight, inout float specularWeight, inout float transmissionWeight, inout float clearcoatWeight\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\t\t// float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tfloat fEstimate = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\t\tdiffuseWeight /= totalWeight;\n\t\tspecularWeight /= totalWeight;\n\t\ttransmissionWeight /= totalWeight;\n\t\tclearcoatWeight /= totalWeight;\n\t}\n\n\tfloat bsdfEval(\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, inout float specularPdf, inout vec3 color\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\n\t\tfloat spdf = 0.0;\n\t\tfloat dpdf = 0.0;\n\t\tfloat tpdf = 0.0;\n\t\tfloat cpdf = 0.0;\n\t\tcolor = vec3( 0.0 );\n\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\n\n\t\t// diffuse\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\t// ggx specular\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tvec3 outColor;\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\n\t\t\tcolor += outColor;\n\n\t\t}\n\n\t\t// transmission\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\n\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\n\n\t\t}\n\n\t\t// sheen\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\n\n\t\t// clearcoat\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\n\n\t\t}\n\n\t\tfloat pdf =\n\t\t\tdpdf * diffuseWeight\n\t\t\t+ spdf * specularWeight\n\t\t\t+ tpdf * transmissionWeight\n\t\t\t+ cpdf * clearcoatWeight;\n\n\t\t// retrieve specular rays for the shadows flag\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\t\treturn pdf;\n\n\t}\n\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tcolor = surf.color / ( 4.0 * PI );\n\t\t\treturn 1.0 / ( 4.0 * PI );\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\n\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\n\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat specularPdf;\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\n\n\t}\n\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tScatterRecord sampleRec;\n\t\t\tsampleRec.specularPdf = 0.0;\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\n\t\t\tsampleRec.direction = sampleSphere( rand2( 16 ) );\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\n\t\t\treturn sampleRec;\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tmat3 normalBasis = surf.normalBasis;\n\t\tmat3 invBasis = surf.normalInvBasis;\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\n\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat pdf[4];\n\t\tpdf[0] = diffuseWeight;\n\t\tpdf[1] = specularWeight;\n\t\tpdf[2] = transmissionWeight;\n\t\tpdf[3] = clearcoatWeight;\n\n\t\tfloat cdf[4];\n\t\tcdf[0] = pdf[0];\n\t\tcdf[1] = pdf[1] + cdf[0];\n\t\tcdf[2] = pdf[2] + cdf[1];\n\t\tcdf[3] = pdf[3] + cdf[2];\n\n\t\tif( cdf[3] != 0.0 ) {\n\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\t\tcdf[0] *= invMaxCdf;\n\t\t\tcdf[1] *= invMaxCdf;\n\t\t\tcdf[2] *= invMaxCdf;\n\t\t\tcdf[3] *= invMaxCdf;\n\n\t\t} else {\n\n\t\t\tcdf[0] = 1.0;\n\t\t\tcdf[1] = 0.0;\n\t\t\tcdf[2] = 0.0;\n\t\t\tcdf[3] = 0.0;\n\n\t\t}\n\n\t\tvec3 wi;\n\t\tvec3 clearcoatWi;\n\n\t\tfloat r = rand( 15 );\n\t\tif ( r <= cdf[0] ) { // diffuse\n\n\t\t\twi = diffuseDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[1] ) { // specular\n\n\t\t\twi = specularDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\n\n\t\t\twi = transmissionDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\n\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t\t}\n\n\t\tScatterRecord result;\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\n\t\tresult.direction = normalize( surf.normalBasis * wi );\n\n\t\treturn result;\n\n\t}\n\n\n\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\n\n\t\t\t\t\treturn clamp(\n\t\t\t\t\t\tmax(\n\t\t\t\t\t\t\troughness,\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t1.0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\n\n\t\t\t\t\tvec3 sampleDir = sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur;\n\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\t\tsampleDir = normalize( mat3( backgroundRotation ) * direction + sampleDir );\n\t\t\t\t\treturn backgroundIntensity * sampleEquirectColor( backgroundMap, sampleDir );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tsampleDir = normalize( envRotation3x3 * direction + sampleDir );\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t\n\n\tstruct Ray {\n\n\t\tvec3 origin;\n\t\tvec3 direction;\n\n\t};\n\n\tstruct SurfaceHit {\n\n\t\tuvec4 faceIndices;\n\t\tvec3 barycoord;\n\t\tvec3 faceNormal;\n\t\tfloat side;\n\t\tfloat dist;\n\n\t};\n\n\tstruct RenderState {\n\n\t\tbool firstRay;\n\t\tbool transmissiveRay;\n\t\tbool isShadowRay;\n\t\tfloat accumulatedRoughness;\n\t\tint transmissiveTraversals;\n\t\tint traversals;\n\t\tuint depth;\n\t\tvec3 throughputColor;\n\t\tMaterial fogMaterial;\n\n\t};\n\n\tRenderState initRenderState() {\n\n\t\tRenderState result;\n\t\tresult.firstRay = true;\n\t\tresult.transmissiveRay = true;\n\t\tresult.isShadowRay = false;\n\t\tresult.accumulatedRoughness = 0.0;\n\t\tresult.transmissiveTraversals = 0;\n\t\tresult.traversals = 0;\n\t\tresult.throughputColor = vec3( 1.0 );\n\t\tresult.depth = 0u;\n\t\tresult.fogMaterial.fogVolume = false;\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t}\n\n\tRay getCameraRay() {\n\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t// around this pixel's UV coordinate for AA\n\t\tvec2 ruv = rand2( 0 );\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\n\t\tRay ray;\n\n\t\t#if CAMERA_TYPE == 2\n\n\t\t\t// Equirectangular projection\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\tray.direction = normalize( rayDirection4.xyz );\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t#else\n\n\t\t\t// get [- 1, 1] normalized device coordinates\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\t\t\tray.origin = ndcToRayOrigin( ndc );\n\n\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t// Orthographic projection\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\n\t\t\t\tray.direction = normalize( ray.direction );\n\n\t\t\t#else\n\n\t\t\t\t// Perspective projection\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#if FEATURE_DOF\n\t\t{\n\n\t\t\t// depth of field\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\n\n\t\t\t// get the aperture sample\n\t\t\t// if blades === 0 then we assume a circle\n\t\t\tvec3 shapeUVW= rand3( 1 );\n\t\t\tint blades = physicalCamera.apertureBlades;\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t// rotate the aperture shape\n\t\t\tapertureSample =\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\n\n\t\t\t// create the new ray\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\tray.direction = focalPoint - ray.origin;\n\n\t\t}\n\t\t#endif\n\n\t\tray.direction = normalize( ray.direction );\n\n\t\treturn ray;\n\n\t}\n\n\n\t\t\t\t\n\n\t#define NO_HIT 0\n\t#define SURFACE_HIT 1\n\t#define LIGHT_HIT 2\n\t#define FOG_HIT 3\n\n\t// Passing the global variable 'lights' into this function caused shader program errors.\n\t// So global variables like 'lights' and 'bvh' were moved out of the function parameters.\n\t// For more information, refer to: https://github.com/gkjohnson/three-gpu-pathtracer/pull/457\n\tint traceScene(\n\t\tRay ray, Material fogMaterial, inout SurfaceHit surfaceHit\n\t) {\n\n\t\tint result = NO_HIT;\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\n\n\t\t#if FEATURE_FOG\n\n\t\tif ( fogMaterial.fogVolume ) {\n\n\t\t\t// offset the distance so we don't run into issues with particles on the same surface\n\t\t\t// as other objects\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, rand( 1 ) );\n\t\t\tif ( particleDist + RAY_OFFSET < surfaceHit.dist ) {\n\n\t\t\t\tsurfaceHit.side = 1.0;\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\n\t\t\t\tsurfaceHit.dist = particleDist;\n\t\t\t\treturn FOG_HIT;\n\n\t\t\t}\n\n\t\t}\n\n\t\t#endif\n\n\t\tif ( hit ) {\n\n\t\t\tresult = SURFACE_HIT;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t// returns true if a solid surface was hit\n\tbool attenuateHit(\n\t\tRenderState state,\n\t\tRay ray, float rayDist,\n\t\tout vec3 color\n\t) {\n\n\t\t// store the original bounce index so we can reset it after\n\t\tuint originalBounceIndex = sobolBounceIndex;\n\n\t\tint traversals = state.traversals;\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\n\t\tbool isShadowRay = state.isShadowRay;\n\t\tMaterial fogMaterial = state.fogMaterial;\n\n\t\tvec3 startPoint = ray.origin;\n\n\t\t// hit results\n\t\tSurfaceHit surfaceHit;\n\n\t\tcolor = vec3( 1.0 );\n\n\t\tbool result = true;\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\tsobolBounceIndex ++;\n\n\t\t\tint hitType = traceScene( ray, fogMaterial, surfaceHit );\n\n\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\n\t\t\t\tif ( totalDist > rayDist ) {\n\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t// adjust the ray to the new surface\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\tif ( material.fogVolume ) {\n\n\t\t\t\t\tfogMaterial = material;\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t\t\t// albedo\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMap\n\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t}\n\n\t\t\t\t// transmission\n\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t}\n\n\t\t\t\t// metalness\n\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t}\n\n\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\tif (\n\t\t\t\t\ttransmissionFactor < rand( 9 ) && ! (\n\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\n\n\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 10 )\n\t\t\t\t\t)\n\t\t\t\t) {\n\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\n\n\t\t\t\t\t// only attenuate by surface color on the way in\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\n\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\n\n\t\t\t\t}\n\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\n\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the bounce index\n\t\tsobolBounceIndex = originalBounceIndex;\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\n\n\t\tvec3 result = vec3( 0.0 );\n\n\t\t// uniformly pick a light or environment map\n\t\tif( lightsDenom != 0.0 && rand( 5 ) < float( lights.count ) / lightsDenom ) {\n\n\t\t\t// sample a light or environment\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, rand3( 6 ) );\n\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tlightRec.pdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the light area\n\t\t\tRay lightRay;\n\t\t\tlightRay.origin = rayOrigin;\n\t\t\tlightRay.direction = lightRec.direction;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tlightRec.pdf > 0.0 &&\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( state, lightRay, lightRec.dist, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\tresult = attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\n\n\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\tvec3 envColor, envDirection;\n\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 7 ), envColor, envDirection );\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\n\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t// results so we ignore the sample in this case.\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tenvPdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the surface\n\t\t\tRay envRay;\n\t\t\tenvRay.origin = rayOrigin;\n\t\t\tenvRay.direction = envDirection;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( state, envRay, INFINITY, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tenvPdf /= lightsDenom;\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\tresult = attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Function changed to have a single return statement to potentially help with crashes on Mac OS.\n\t\t// See issue #470\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\t#define SKIP_SURFACE 0\n\t#define HIT_SURFACE 1\n\tint getSurfaceRecord(\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\n\t\tfloat accumulatedRoughness,\n\t\tinout SurfaceRecord surf\n\t) {\n\n\t\tif ( material.fogVolume ) {\n\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\n\n\t\t\tSurfaceRecord fogSurface;\n\t\t\tfogSurface.volumeParticle = true;\n\t\t\tfogSurface.color = material.color;\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\n\t\t\tfogSurface.normal = normal;\n\t\t\tfogSurface.faceNormal = normal;\n\t\t\tfogSurface.clearcoatNormal = normal;\n\n\t\t\tsurf = fogSurface;\n\t\t\treturn HIT_SURFACE;\n\n\t\t}\n\n\t\t// uv coord for textures\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t// albedo\n\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\tif ( material.map != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t}\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\talbedo *= vertexColor;\n\n\t\t}\n\n\t\t// alphaMap\n\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t}\n\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t// and it's single sided.\n\t\t// - alpha test is disabled when it === 0\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\tfloat alphaTest = material.alphaTest;\n\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\tif (\n\t\t\t// material sidedness\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\n\n\t\t\t// alpha test\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t// opacity\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 3 )\n\t\t) {\n\n\t\t\treturn SKIP_SURFACE;\n\n\t\t}\n\n\t\t// fetch the interpolated smooth normal\n\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\tattributesArray,\n\t\t\tATTR_NORMAL,\n\t\t\tsurfaceHit.barycoord,\n\t\t\tsurfaceHit.faceIndices.xyz\n\t\t).xyz );\n\n\t\t// roughness\n\t\tfloat roughness = material.roughness;\n\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t}\n\n\t\t// metalness\n\t\tfloat metalness = material.metalness;\n\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t}\n\n\t\t// emission\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t}\n\n\t\t// transmission\n\t\tfloat transmission = material.transmission;\n\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t}\n\n\t\t// normal\n\t\tif ( material.flatShading ) {\n\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\n\t\t\t// interpolated vertex normals.\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\n\n\t\t}\n\n\t\tvec3 baseNormal = normal;\n\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnormal *= surfaceHit.side;\n\n\t\t// clearcoat\n\t\tfloat clearcoat = material.clearcoat;\n\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t}\n\n\t\t// clearcoatRoughness\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t}\n\n\t\t// clearcoatNormal\n\t\tvec3 clearcoatNormal = baseNormal;\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tclearcoatNormal *= surfaceHit.side;\n\n\t\t// sheenColor\n\t\tvec3 sheenColor = material.sheenColor;\n\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// sheenRoughness\n\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t}\n\n\t\t// iridescence\n\t\tfloat iridescence = material.iridescence;\n\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t}\n\n\t\t// iridescence thickness\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t}\n\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t// specular color\n\t\tvec3 specularColor = material.specularColor;\n\t\tif ( material.specularColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// specular intensity\n\t\tfloat specularIntensity = material.specularIntensity;\n\t\tif ( material.specularIntensityMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\n\n\t\t}\n\n\t\tsurf.volumeParticle = false;\n\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\n\t\tsurf.normal = normal;\n\n\t\tsurf.metalness = metalness;\n\t\tsurf.color = albedo.rgb;\n\t\tsurf.emission = emission;\n\n\t\tsurf.ior = material.ior;\n\t\tsurf.transmission = transmission;\n\t\tsurf.thinFilm = material.thinFilm;\n\t\tsurf.attenuationColor = material.attenuationColor;\n\t\tsurf.attenuationDistance = material.attenuationDistance;\n\n\t\tsurf.clearcoatNormal = clearcoatNormal;\n\t\tsurf.clearcoat = clearcoat;\n\n\t\tsurf.sheen = material.sheen;\n\t\tsurf.sheenColor = sheenColor;\n\n\t\tsurf.iridescence = iridescence;\n\t\tsurf.iridescenceIor = material.iridescenceIor;\n\t\tsurf.iridescenceThickness = iridescenceThickness;\n\n\t\tsurf.specularColor = specularColor;\n\t\tsurf.specularIntensity = specularIntensity;\n\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\n\t\t// applied by its brdf function\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\n\t\tsurf.roughness = roughness * roughness;\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\n\t\tsurf.sheenRoughness = sheenRoughness;\n\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t// then we can just always assume this is a front face.\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\n\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t// The accumulated roughness value is scaled by a user setting and a "magic value" of 5.0.\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t// sharp internal reflections\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\n\n\t\t// get the normal frames\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\n\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\n\n\t\treturn HIT_SURFACE;\n\n\t}\n\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// init\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | uint( gl_FragCoord.y );\n\t\t\t\t\tsobolPathIndex = uint( seed );\n\n\t\t\t\t\t// get camera ray\n\t\t\t\t\tRay ray = getCameraRay();\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\n\t\t\t\t\tlightsDenom =\n\t\t\t\t\t\t( environmentIntensity == 0.0 || envMapInfo.totalSum == 0.0 ) && lights.count != 0u ?\n\t\t\t\t\t\t\tfloat( lights.count ) :\n\t\t\t\t\t\t\tfloat( lights.count + 1u );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\n\n\t\t\t\t\t// surface results\n\t\t\t\t\tSurfaceHit surfaceHit;\n\t\t\t\t\tScatterRecord scatterRec;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tRenderState state = initRenderState();\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\n\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\n\t\t\t\t\t\tray.origin, - ray.direction,\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\n\t\t\t\t\t\tstate.fogMaterial\n\t\t\t\t\t);\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tsobolBounceIndex ++;\n\n\t\t\t\t\t\tstate.depth ++;\n\t\t\t\t\t\tstate.traversals = bounces - i;\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\n\n\t\t\t\t\t\tint hitType = traceScene( ray, state.fogMaterial, surfaceHit );\n\n\t\t\t\t\t\t// check if we intersect any lights and accumulate the light contribution\n\t\t\t\t\t\t// TODO: we can add support for light surface rendering in the else condition if we\n\t\t\t\t\t\t// add the ability to toggle visibility of the the light\n\t\t\t\t\t\tif ( ! state.firstRay && ! state.transmissiveRay ) {\n\n\t\t\t\t\t\t\tLightRecord lightRec;\n\t\t\t\t\t\t\tfloat lightDist = hitType == NO_HIT ? INFINITY : surfaceHit.dist;\n\t\t\t\t\t\t\tfor ( uint i = 0u; i < lights.count; i ++ ) {\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tintersectLightAtIndex( lights.tex, ray.origin, ray.direction, i, lightRec ) &&\n\t\t\t\t\t\t\t\t\tlightRec.dist < lightDist\n\t\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\t\t// NOTE: Only area lights are supported for forward sampling and can be hit\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hitType == NO_HIT ) {\n\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( ray.direction, rand2( 2 ) ) * state.throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envRotation3x3 * ray.direction, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\n\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\n\n\t\t\t\t\t\t\tstate.fogMaterial = material;\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// early out if this is a matte material\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSurfaceRecord surf;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgetSurfaceRecord(\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\n\t\t\t\t\t\t\t\tsurf\n\t\t\t\t\t\t\t) == SKIP_SURFACE\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < rand( 4 );\n\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t// next event estimation\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate emissive color\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\n\t\t\t\t\t\t// perform this separate from a bounce\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\n\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\n\t\t\t\t\t\t\ti --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// handle throughput color transformation\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\n\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\n\n\t\t\t\t\t\t// russian roulette path termination\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\n\t\t\t\t\t\tuint minBounces = 3u;\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\n\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\n\t\t\t\t\t\trrProb = sqrt( rrProb );\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\n\t\t\t\t\t\tif ( rand( 8 ) > rrProb ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// prepare for next ray\n\t\t\t\t\t\tray.direction = scatterRec.direction;\n\t\t\t\t\t\tray.origin = hitPoint;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t\t#if DEBUG_MODE == 1\n\n\t\t\t\t\t// output the number of rays checked in the path and number of\n\t\t\t\t\t// transmissive rays encountered.\n\t\t\t\t\tgl_FragColor.rgb = vec3(\n\t\t\t\t\t\tfloat( state.depth ),\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\n\t\t\t\t\t\t0.0\n\t\t\t\t\t);\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}}function*Eg(){const{_renderer:t,_fsQuad:e,_blendQuad:n,_primaryTarget:r,_blendTargets:i,_sobolTarget:a,_subframe:s,alpha:o,material:l}=this,c=new qe,u=new qe,h=n.material;let[d,p]=i;for(;;){o?(h.opacity=this._opacityFactor/(this.samples+1),l.blending=0,l.opacity=1):(l.opacity=this._opacityFactor/(this.samples+1),l.blending=1);const[i,f,m,g]=s,v=r.width,_=r.height;l.resolution.set(v*m,_*g),l.sobolTexture=a.texture,l.stratifiedTexture.init(20,l.bounces+l.transmissiveBounces+5),l.stratifiedTexture.next(),l.seed++;const y=this.tiles.x||1,x=this.tiles.y||1,b=y*x,w=Math.ceil(v*m),M=Math.ceil(_*g),T=Math.floor(i*v),E=Math.floor(f*_),S=Math.ceil(w/y),A=Math.ceil(M/x);for(let i=0;i<x;i++)for(let a=0;a<y;a++){const s=t.getRenderTarget(),l=t.autoClear,f=t.getScissorTest();t.getScissor(c),t.getViewport(u);let m=a,g=i;if(!this.stableTiles){const t=this._currentTile%(y*x);m=t%y,g=~~(t/y),this._currentTile=t+1}const v=x-g-1;r.scissor.set(T+m*S,E+v*A,Math.min(S,w-m*S),Math.min(A,M-v*A)),r.viewport.set(T,E,w,M),t.setRenderTarget(r),t.setScissorTest(!0),t.autoClear=!1,e.render(t),t.setViewport(u),t.setScissor(c),t.setScissorTest(f),t.setRenderTarget(s),t.autoClear=l,o&&(h.target1=d.texture,h.target2=r.texture,t.setRenderTarget(p),n.render(t),t.setRenderTarget(s)),this.samples+=1/b,a===y-1&&i===x-1&&(this.samples=Math.round(this.samples)),yield}[d,p]=[p,d]}}const Sg=new wr;class Ag{get material(){return this._fsQuad.material}set material(t){this._fsQuad.material.removeEventListener("recompilation",this._compileFunction),t.addEventListener("recompilation",this._compileFunction),this._fsQuad.material=t}get target(){return this._alpha?this._blendTargets[1]:this._primaryTarget}set alpha(t){this._alpha!==t&&(t||(this._blendTargets[0].dispose(),this._blendTargets[1].dispose()),this._alpha=t,this.reset())}get alpha(){return this._alpha}get isCompiling(){return Boolean(this._compilePromise)}constructor(t){this.camera=null,this.tiles=new Me(3,3),this.stableNoise=!1,this.stableTiles=!0,this.samples=0,this._subframe=new qe(0,0,1,1),this._opacityFactor=1,this._renderer=t,this._alpha=!1,this._fsQuad=new Im(new Tg),this._blendQuad=new Im(new Dm),this._task=null,this._currentTile=0,this._compilePromise=null,this._sobolTarget=(new km).generate(t),this._primaryTarget=new Ye(1,1,{format:at,type:tt,magFilter:G,minFilter:G}),this._blendTargets=[new Ye(1,1,{format:at,type:tt,magFilter:G,minFilter:G}),new Ye(1,1,{format:at,type:tt,magFilter:G,minFilter:G})],this._compileFunction=()=>{const t=this.compileMaterial(this._fsQuad._mesh);t.then((()=>{this._compilePromise===t&&(this._compilePromise=null)})),this._compilePromise=t},this.material.addEventListener("recompilation",this._compileFunction)}compileMaterial(){return this._renderer.compileAsync(this._fsQuad._mesh)}setCamera(t){const{material:e}=this;e.cameraWorldMatrix.copy(t.matrixWorld),e.invProjectionMatrix.copy(t.projectionMatrixInverse),e.physicalCamera.updateFrom(t);let n=0;t.projectionMatrix.elements[15]>0&&(n=1),t.isEquirectCamera&&(n=2),e.setDefine("CAMERA_TYPE",n),this.camera=t}setSize(t,e){t=Math.ceil(t),e=Math.ceil(e),this._primaryTarget.width===t&&this._primaryTarget.height===e||(this._primaryTarget.setSize(t,e),this._blendTargets[0].setSize(t,e),this._blendTargets[1].setSize(t,e),this.reset())}getSize(t){t.x=this._primaryTarget.width,t.y=this._primaryTarget.height}dispose(){this._primaryTarget.dispose(),this._blendTargets[0].dispose(),this._blendTargets[1].dispose(),this._sobolTarget.dispose(),this._fsQuad.dispose(),this._blendQuad.dispose(),this._task=null}reset(){const{_renderer:t,_primaryTarget:e,_blendTargets:n}=this,r=t.getRenderTarget(),i=t.getClearAlpha();t.getClearColor(Sg),t.setRenderTarget(e),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[0]),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[1]),t.setClearColor(0,0),t.clearColor(),t.setClearColor(Sg,i),t.setRenderTarget(r),this.samples=0,this._task=null,this.material.stratifiedTexture.stableNoise=this.stableNoise,this.stableNoise&&(this.material.seed=0,this.material.stratifiedTexture.reset())}update(){this.material.onBeforeRender(),this.isCompiling||(this._task||(this._task=Eg.call(this)),this._task.next())}}const Rg=new Me,Cg=new Me,Pg=new xc,Ig=new wr;class Lg extends Po{constructor(t=512,e=512){super(new Float32Array(t*e*4),t,e,at,tt,F,k,z,j,j),this.generationCallback=null}update(){this.dispose(),this.needsUpdate=!0;const{data:t,width:e,height:n}=this.image;for(let r=0;r<e;r++)for(let i=0;i<n;i++){Cg.set(e,n),Rg.set(r/e,i/n),Rg.x-=.5,Rg.y=1-Rg.y,Pg.theta=2*Rg.x*Math.PI,Pg.phi=Rg.y*Math.PI,Pg.radius=1,this.generationCallback(Pg,Rg,Cg,Ig);const a=4*(i*e+r);t[a+0]=Ig.r,t[a+1]=Ig.g,t[a+2]=Ig.b,t[a+3]=1}}copy(t){return super.copy(t),this.generationCallback=t.generationCallback,this}}const Dg=new Qe;class Og extends Lg{constructor(t=512){super(t,t),this.topColor=(new wr).set(16777215),this.bottomColor=(new wr).set(0),this.exponent=2,this.generationCallback=(t,e,n,r)=>{Dg.setFromSpherical(t);const i=.5*Dg.y+.5;r.lerpColors(this.bottomColor,this.topColor,i**this.exponent)}}copy(t){return super.copy(t),this.topColor.copy(t.topColor),this.bottomColor.copy(t.bottomColor),this}}class Ng extends li{get map(){return this.uniforms.map.value}set map(t){this.uniforms.map.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}constructor(t){super({uniforms:{map:{value:null},opacity:{value:1}},vertexShader:"\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float opacity;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\n\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\n\n\t\t\t\t\t#if defined( TONE_MAPPING )\n\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\n\n\t\t\t\t\t#endif\n\n\t\t\t  \t\treturn linearToOutputTexel( res );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\n\t\t\t\t\tvec2 pxUv = vUv * size;\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\n\t\t\t\t\tvec2 pxOffset;\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\n\n\t\t\t\t\tvec4 p1 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tvec4 p2 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t"}),this.setValues(t)}}class Ug extends li{constructor(){super({uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:`\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\t\tuniform samplerCube envMap;\n\t\t\t\tuniform float flipEnvMap;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${wg}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\trayDirection.x *= flipEnvMap;\n\t\t\t\t\tgl_FragColor = textureCube( envMap, rayDirection );\n\n\t\t\t\t}`}),this.depthWrite=!1,this.depthTest=!1}}class Fg{constructor(t){this._renderer=t,this._quad=new Im(new Ug)}generate(t,e=null,n=null){if(!t.isCubeTexture)throw new Error("CubeToEquirectMaterial: Source can only be cube textures.");const r=t.images[0],i=this._renderer,a=this._quad;null===e&&(e=4*r.height),null===n&&(n=2*r.height);const s=new Ye(e,n,{type:tt,colorSpace:r.colorSpace}),o=r.height,l=Math.log2(o)-2,c=1/o,u=1/(3*Math.max(Math.pow(2,l),112));a.material.defines.CUBEUV_MAX_MIP=`${l}.0`,a.material.defines.CUBEUV_TEXEL_WIDTH=u,a.material.defines.CUBEUV_TEXEL_HEIGHT=c,a.material.uniforms.envMap.value=t,a.material.uniforms.flipEnvMap.value=t.isRenderTargetTexture?1:-1,a.material.needsUpdate=!0;const h=i.getRenderTarget(),d=i.autoClear;i.autoClear=!0,i.setRenderTarget(s),a.render(i),i.setRenderTarget(h),i.autoClear=d;const p=new Uint16Array(e*n*4),f=new Float32Array(e*n*4);i.readRenderTargetPixels(s,0,0,e,n,f),s.dispose();for(let t=0,e=f.length;t<e;t++)p[t]=Cr.toHalfFloat(f[t]);const m=new Po(p,e,n,at,et);return m.minFilter=1008,m.magFilter=j,m.wrapS=k,m.wrapT=k,m.mapping=F,m.needsUpdate=!0,m}dispose(){this._quad.dispose()}}const Bg=new Me;class kg{get multipleImportanceSampling(){return Boolean(this._pathTracer.material.defines.FEATURE_MIS)}set multipleImportanceSampling(t){this._pathTracer.material.setDefine("FEATURE_MIS",t?1:0)}get transmissiveBounces(){return this._pathTracer.material.transmissiveBounces}set transmissiveBounces(t){this._pathTracer.material.transmissiveBounces=t}get bounces(){return this._pathTracer.material.bounces}set bounces(t){this._pathTracer.material.bounces=t}get filterGlossyFactor(){return this._pathTracer.material.filterGlossyFactor}set filterGlossyFactor(t){this._pathTracer.material.filterGlossyFactor=t}get samples(){return this._pathTracer.samples}get target(){return this._pathTracer.target}get tiles(){return this._pathTracer.tiles}get stableNoise(){return this._pathTracer.stableNoise}set stableNoise(t){this._pathTracer.stableNoise=t}get isCompiling(){return Boolean(this._pathTracer.isCompiling)}constructor(t){this._renderer=t,this._generator=new Rm,this._pathTracer=new Ag(t),this._queueReset=!1,this._clock=new lc,this._compilePromise=null,this._lowResPathTracer=new Ag(t),this._lowResPathTracer.tiles.set(1,1),this._quad=new Im(new Ng({map:null,transparent:!0,blending:0,premultipliedAlpha:t.getContextAttributes().premultipliedAlpha})),this._materials=null,this._previousEnvironment=null,this._previousBackground=null,this._internalBackground=null,this.renderDelay=100,this.minSamples=5,this.fadeDuration=500,this.enablePathTracing=!0,this.pausePathTracing=!1,this.dynamicLowRes=!1,this.lowResScale=.25,this.renderScale=1,this.synchronizeRenderSize=!0,this.rasterizeScene=!0,this.renderToCanvas=!0,this.textureSize=new Me(1024,1024),this.rasterizeSceneCallback=(t,e)=>{this._renderer.render(t,e)},this.renderToCanvasCallback=(t,e,n)=>{const r=e.autoClear;e.autoClear=!1,n.render(e),e.autoClear=r},this.setScene(new mo,new pi)}setBVHWorker(t){this._generator.setBVHWorker(t)}setScene(t,e,n={}){t.updateMatrixWorld(!0),e.updateMatrixWorld();const r=this._generator;if(r.setObjects(t),this._buildAsync)return r.generateAsync(n.onProgress).then((n=>this._updateFromResults(t,e,n)));{const n=r.generate();return this._updateFromResults(t,e,n)}}setSceneAsync(...t){this._buildAsync=!0;const e=this.setScene(...t);return this._buildAsync=!1,e}setCamera(t){this.camera=t,this.updateCamera()}updateCamera(){const t=this.camera;t.updateMatrixWorld(),this._pathTracer.setCamera(t),this._lowResPathTracer.setCamera(t),this.reset()}updateMaterials(){const t=this._pathTracer.material,e=this._renderer,n=this._materials,r=this.textureSize,i=function(t){const e=new Set;for(let n=0,r=t.length;n<r;n++){const r=t[n];for(const t in r){const n=r[t];n&&n.isTexture&&e.add(n)}}return function(t){const e=new Set,n=[];for(let r=0,i=t.length;r<i;r++){const i=t[r],a=lg(i);e.has(a)||(e.add(a),n.push(i))}return n}(Array.from(e)).sort(og)}(n);t.textures.setTextures(e,i,r.x,r.y),t.materials.updateFrom(n,i),this.reset()}updateLights(){const t=this.scene,e=this._renderer,n=this._pathTracer.material,r=function(t){const e=[];return t.traverse((t=>{t.visible&&(t.isRectAreaLight||t.isSpotLight||t.isPointLight||t.isDirectionalLight)&&e.push(t)})),e.sort(og)}(t),i=function(t){const e=t.map((t=>t.iesMap||null)).filter((t=>t)),n=new Set(e);return Array.from(n).sort(og)}(r);n.lights.updateFrom(r,i),n.iesProfiles.setTextures(e,i),this.reset()}updateEnvironment(){const t=this.scene,e=this._pathTracer.material;if(this._internalBackground&&(this._internalBackground.dispose(),this._internalBackground=null),e.backgroundBlur=t.backgroundBlurriness,e.backgroundIntensity=t.backgroundIntensity??1,e.backgroundRotation.makeRotationFromEuler(t.backgroundRotation).invert(),null===t.background)e.backgroundMap=null,e.backgroundAlpha=0;else if(t.background.isColor){this._colorBackground=this._colorBackground||new Og(16);const n=this._colorBackground;n.topColor.equals(t.background)||(n.topColor.set(t.background),n.bottomColor.set(t.background),n.update()),e.backgroundMap=n,e.backgroundAlpha=1}else if(t.background.isCubeTexture){if(t.background!==this._previousBackground){const n=new Fg(this._renderer).generate(t.background);this._internalBackground=n,e.backgroundMap=n,e.backgroundAlpha=1}}else e.backgroundMap=t.background,e.backgroundAlpha=1;if(e.environmentIntensity=t.environmentIntensity??1,e.environmentRotation.makeRotationFromEuler(t.environmentRotation).invert(),this._previousEnvironment!==t.environment)if(null!==t.environment)if(t.environment.isCubeTexture){const n=new Fg(this._renderer).generate(t.environment);e.envMapInfo.updateFrom(n)}else e.envMapInfo.updateFrom(t.environment);else e.environmentIntensity=0;this._previousEnvironment=t.environment,this._previousBackground=t.background,this.reset()}_updateFromResults(t,e,n){const{materials:r,geometry:i,bvh:a,bvhChanged:s}=n;this._materials=r;const o=this._pathTracer.material;return s&&(o.bvh.updateFrom(a),o.attributesArray.updateFrom(i.attributes.normal,i.attributes.tangent,i.attributes.uv,i.attributes.color),o.materialIndexAttribute.updateFrom(i.attributes.materialIndex)),this._previousScene=t,this.scene=t,this.camera=e,this.updateCamera(),this.updateMaterials(),this.updateEnvironment(),this.updateLights(),n}renderSample(){const t=this._lowResPathTracer,e=this._pathTracer,n=this._renderer,r=this._clock,i=this._quad;this._updateScale(),this._queueReset&&(e.reset(),t.reset(),this._queueReset=!1,i.material.opacity=0,r.start());const a=1e3*r.getDelta(),s=1e3*r.getElapsedTime();if(!this.pausePathTracing&&this.enablePathTracing&&this.renderDelay<=s&&!this.isCompiling&&e.update(),e.alpha=1!==e.material.backgroundAlpha||!function(t){return t.extensions.get("EXT_float_blend")}(n),t.alpha=e.alpha,this.renderToCanvas){const n=this._renderer,r=this.minSamples;if(s>=this.renderDelay&&this.samples>=this.minSamples&&(0!==this.fadeDuration?i.material.opacity=Math.min(i.material.opacity+a/this.fadeDuration,1):i.material.opacity=1),!this.enablePathTracing||this.samples<r||i.material.opacity<1){if(this.dynamicLowRes&&!this.isCompiling){t.samples<1&&(t.material=e.material,t.update());const r=i.material.opacity;i.material.opacity=1-i.material.opacity,i.material.map=t.target.texture,i.render(n),i.material.opacity=r}(!this.dynamicLowRes&&this.rasterizeScene||this.dynamicLowRes&&this.isCompiling)&&this.rasterizeSceneCallback(this.scene,this.camera)}this.enablePathTracing&&i.material.opacity>0&&(i.material.opacity<1&&(i.material.blending=this.dynamicLowRes?2:1),i.material.map=e.target.texture,this.renderToCanvasCallback(e.target,n,i),i.material.blending=0)}}reset(){this._queueReset=!0,this._pathTracer.samples=0}dispose(){this._renderQuad.dispose(),this._renderQuad.material.dispose(),this._pathTracer.dispose()}_updateScale(){if(this.synchronizeRenderSize){this._renderer.getDrawingBufferSize(Bg);const t=Math.floor(this.renderScale*Bg.x),e=Math.floor(this.renderScale*Bg.y);if(this._pathTracer.getSize(Bg),Bg.x!==t||Bg.y!==e){const n=this.lowResScale;this._pathTracer.setSize(t,e),this._lowResPathTracer.setSize(Math.floor(t*n),Math.floor(e*n))}}}}var zg=function(t,e,n,r){return new(n||(n=Promise))((function(i,a){function s(t){try{l(r.next(t))}catch(t){a(t)}}function o(t){try{l(r.throw(t))}catch(t){a(t)}}function l(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,o)}l((r=r.apply(t,e||[])).next())}))};const Hg=(t,e="#000000",n="status-line-1")=>{console.log(`Status information: ${t}`);const r=document.getElementById(n);r&&(r.innerText=t,r.style.setProperty("color",e))},Gg=window.location.search,Vg=new URLSearchParams(Gg);let Wg=Vg.get("id");Wg||(Wg="usm:frame:9C4BC73D19BAAD07675CDDEA721F493BB126939392FF80318204B089BD55C71A"),Wg&&console.log(`id: ${Wg}`);let jg=Vg.get("envUrl");jg&&console.log(`envUrl: ${jg}`);const qg=document.getElementById("three_canvas");if(null===qg)throw new Error("three_canvas not found");((t,e)=>{const n=new fo({canvas:t,alpha:!0});n.setSize(window.innerWidth,window.innerHeight),document.body.appendChild(n.domElement),n.toneMapping=4,n.setSize(window.innerWidth,window.innerHeight),n.setPixelRatio(window.devicePixelRatio);const r=new Md;r.setDecoderPath("./draco/"),r.setDecoderConfig({type:"js"});const i=new Gu(r),{tiles:a,renderScale:s}=(()=>{let t=3,e=Math.max(1/window.devicePixelRatio,.5);return window.innerWidth/window.innerHeight<.65&&(t=4,e=.5/window.devicePixelRatio),{tiles:t,renderScale:e}})();console.log("tiles",a),console.log("renderScale",s);const o=new kg(n);o.filterGlossyFactor=.5,o.renderScale=s,o.tiles.set(a,a),o.setBVHWorker(new rm);const l=new pi(60,window.innerWidth/window.innerHeight,.1,20);l.position.set(-2,2,3),l.updateMatrixWorld();const c=new Qu(l,n.domElement);c.target.set(0,.5,0),c.addEventListener("change",(()=>o.updateCamera())),c.update();const u=new xd,h=new bd,d=new mo;d.background=new wr(16777215);const p=new Ai(10,10);p.rotateX(-Math.PI/2);const f=new gl({color:16777215,metalness:.7,roughness:.5}),m=new ei(p,f);m.receiveShadow=!0,d.add(m);const g=new io;d.add(g);const v=new ri(1,1,1),_=new gl({color:14688288}),y=new ei(v,_);y.castShadow=!0,y.receiveShadow=!0,y.position.y=.5,g.add(y);const x=new bh(l,n.domElement);x.addEventListener("dragging-changed",(t=>{c.enabled=!t.value})),x.attach(g),x.getHelper().visible=!1,x.enabled=!1,d.add(x.getHelper());const b=new Sd;document.body.appendChild(b.dom),window.addEventListener("resize",(()=>{const t=window.innerWidth,e=window.innerHeight;l.aspect=t/e,l.updateProjectionMatrix(),n.setSize(t,e),o.updateCamera()}),!1);const w=t=>{o.renderSample(),Hg(`samples ${Math.floor(o.samples)}`,"#000000","status-line-2"),requestAnimationFrame(w),b.update()};zg(void 0,void 0,void 0,(function*(){if(e){const r=null!=jg?jg:"https://raw.githubusercontent.com/gkjohnson/3d-demo-data/master/hdri/chinese_garden_1k.hdr",a=r.toLowerCase();a.endsWith(".hdr")?yield(n=r,zg(void 0,void 0,void 0,(function*(){const t=yield h.loadAsync(n);t.mapping=F,d.background=t,d.environment=t}))):a.endsWith(".exr")&&(yield(t=>zg(void 0,void 0,void 0,(function*(){const e=yield u.loadAsync(t);e.mapping=F,d.background=e,d.environment=e})))(r)),yield(t=e,zg(void 0,void 0,void 0,(function*(){let e=i.getScene(t);e||(Hg(`load ${t}`,"#ff0000"),e=yield i.loadSceneFromId(t)),Hg(`render ${t}`,"#ff0000"),g.clear(),g.add(e.sceneObject),Hg(`${t}`)}))),yield o.setSceneAsync(d,l,{onProgress:t=>Hg(`loading scene ${Math.floor(100*t)}%`,"#000000","status-line-2")})}var t,n;requestAnimationFrame(w)}))})(qg,Wg)})()})();